// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* WARNING: This file is auto generated.
 *
 * Do not edit directly.
 */
let math = require('./math.js')
let keys = Object.keys(math);
for (let index in keys){
    global[keys[index]] = math[keys[index]]
}
let tr = (function () {

    function exportPath(name) {
        const parts = name.split('.');
        let cur = global;
        for (let part; parts.length && (part = parts.shift());) {
            if (part in cur) {
                cur = cur[part];
            } else {
                cur = cur[part] = {};
            }
        }
        return cur;
    }

    function isExported(name) {
        const parts = name.split('.');
        let cur = global;
        for (let part; parts.length && (part = parts.shift());) {
            if (part in cur) {
                cur = cur[part];
            } else {
                return false;
            }
        }
        return true;
    }

    function isDefined(name) {
        const parts = name.split('.');
        let curObject = global;
        for (let i = 0; i < parts.length; i++) {
            const partName = parts[i];
            const nextObject = curObject[partName];
            if (nextObject === undefined) return false;
            curObject = nextObject;
        }
        return true;
    }

    let panicElement = undefined;
    const rawPanicMessages = [];

    function showPanicElementIfNeeded() {
        if (panicElement) return;
        const panicOverlay = document.createElement('div');
        panicOverlay.style.backgroundColor = 'white';
        panicOverlay.style.border = '3px solid red';
        panicOverlay.style.boxSizing = 'border-box';
        panicOverlay.style.color = 'black';
        panicOverlay.style.display = 'flex';
        panicOverlay.style.height = '100%';
        panicOverlay.style.left = 0;
        panicOverlay.style.padding = '8px';
        panicOverlay.style.position = 'fixed';
        panicOverlay.style.top = 0;
        panicOverlay.style.webkitFlexDirection = 'column';
        panicOverlay.style.width = '100%';
        panicElement = document.createElement('div');
        panicElement.style.webkitFlex = '1 1 auto';
        panicElement.style.overflow = 'auto';
        panicOverlay.appendChild(panicElement);
        if (!document.body) {
            setTimeout(function () {
                document.body.appendChild(panicOverlay);
            }, 150);
        } else {
            document.body.appendChild(panicOverlay);
        }
    }

    function showPanic(panicTitle, panicDetails) {
        if (tr.isHeadless) {
            if (panicDetails instanceof Error) throw panicDetails;
            throw new Error('Panic: ' + panicTitle + ':\n' + panicDetails);
        }
        if (panicDetails instanceof Error) {
            panicDetails = panicDetails.stack;
        }
        showPanicElementIfNeeded();
        const panicMessageEl = document.createElement('div');
        panicMessageEl.innerHTML = '<h2 id="message"></h2>' + '<pre id="details"></pre>';
        panicMessageEl.querySelector('#message').textContent = panicTitle;
        panicMessageEl.querySelector('#details').textContent = panicDetails;
        panicElement.appendChild(panicMessageEl);
        rawPanicMessages.push({title: panicTitle, details: panicDetails});
    }

    function hasPanic() {
        return rawPanicMessages.length !== 0;
    }

    function getPanicText() {
        return rawPanicMessages.map(function (msg) {
            return msg.title;
        }).join(', ');
    }

    function exportTo(namespace, fn) {
        const obj = exportPath(namespace);
        const exports = fn();
        for (const propertyName in exports) {
            const propertyDescriptor = Object.getOwnPropertyDescriptor(exports, propertyName);
            if (propertyDescriptor) {
                Object.defineProperty(obj, propertyName, propertyDescriptor);
            }
        }
    }

    function initialize() {
        if (global.isVinn) {
            tr.isVinn = true;
        } else if (global.process && global.process.versions.node) {
            tr.isNode = true;
        } else {
            tr.isVinn = false;
            tr.isNode = false;
            tr.doc = document;
            tr.isMac = /Mac/.test(navigator.platform);
            tr.isWindows = /Win/.test(navigator.platform);
            tr.isChromeOS = /CrOS/.test(navigator.userAgent);
            tr.isLinux = /Linux/.test(navigator.userAgent);
        }
        tr.isHeadless = tr.isVinn || tr.isNode;
    }

    return {initialize, exportTo, isExported, isDefined, showPanic, hasPanic, getPanicText,};
})();
tr.initialize();
global.tr = tr;
'use strict';
tr.exportTo('tr.b', function () {
    function EventTarget() {
    }

    EventTarget.decorate = function (target) {
        for (const k in EventTarget.prototype) {
            if (k === 'decorate') continue;
            const v = EventTarget.prototype[k];
            if (typeof v !== 'function') continue;
            target[k] = v;
        }
    };
    EventTarget.prototype = {
        addEventListener(type, handler) {
            if (!this.listeners_) {
                this.listeners_ = Object.create(null);
            }
            if (!(type in this.listeners_)) {
                this.listeners_[type] = [handler];
            } else {
                const handlers = this.listeners_[type];
                if (handlers.indexOf(handler) < 0) {
                    handlers.push(handler);
                }
            }
        }, removeEventListener(type, handler) {
            if (!this.listeners_) return;
            if (type in this.listeners_) {
                const handlers = this.listeners_[type];
                const index = handlers.indexOf(handler);
                if (index >= 0) {
                    if (handlers.length === 1) {
                        delete this.listeners_[type];
                    } else {
                        handlers.splice(index, 1);
                    }
                }
            }
        }, dispatchEvent(event) {
            if (!this.listeners_) return true;
            event.__defineGetter__('target', () => this);
            const realPreventDefault = event.preventDefault;
            event.preventDefault = function () {
                realPreventDefault.call(this);
                this.rawReturnValue = false;
            };
            const type = event.type;
            let prevented = 0;
            if (type in this.listeners_) {
                const handlers = this.listeners_[type].concat();
                for (let i = 0, handler; handler = handlers[i]; i++) {
                    if (handler.handleEvent) {
                        prevented |= handler.handleEvent.call(handler, event) === false;
                    } else {
                        prevented |= handler.call(this, event) === false;
                    }
                }
            }
            return !prevented && event.rawReturnValue;
        }, async dispatchAsync(event) {
            if (!this.listeners_) return true;
            const listeners = this.listeners_[event.type];
            if (listeners === undefined) return;
            await Promise.all(listeners.slice().map(listener => {
                if (listener.handleEvent) {
                    return listener.handleEvent.call(listener, event);
                }
                return listener.call(this, event);
            }));
        }, hasEventListener(type) {
            return (this.listeners_ !== undefined && this.listeners_[type] !== undefined);
        }
    };
    return {EventTarget,};
});
'use strict';
tr.exportTo('tr.b', function () {
    function RegisteredTypeInfo(constructor, metadata) {
        this.constructor = constructor;
        this.metadata = metadata;
    }

    const BASIC_REGISTRY_MODE = 'BASIC_REGISTRY_MODE';
    const TYPE_BASED_REGISTRY_MODE = 'TYPE_BASED_REGISTRY_MODE';
    const ALL_MODES = {BASIC_REGISTRY_MODE: true, TYPE_BASED_REGISTRY_MODE: true};

    function ExtensionRegistryOptions(mode) {
        if (mode === undefined) {
            throw new Error('Mode is required');
        }
        if (!ALL_MODES[mode]) {
            throw new Error('Not a mode.');
        }
        this.mode_ = mode;
        this.defaultMetadata_ = {};
        this.defaultConstructor_ = undefined;
        this.defaultTypeInfo_ = undefined;
        this.frozen_ = false;
    }

    ExtensionRegistryOptions.prototype = {
        freeze() {
            if (this.frozen_) {
                throw new Error('Frozen');
            }
            this.frozen_ = true;
        }, get mode() {
            return this.mode_;
        }, get defaultMetadata() {
            return this.defaultMetadata_;
        }, set defaultMetadata(defaultMetadata) {
            if (this.frozen_) {
                throw new Error('Frozen');
            }
            this.defaultMetadata_ = defaultMetadata;
            this.defaultTypeInfo_ = undefined;
        }, get defaultConstructor() {
            return this.defaultConstructor_;
        }, set defaultConstructor(defaultConstructor) {
            if (this.frozen_) {
                throw new Error('Frozen');
            }
            this.defaultConstructor_ = defaultConstructor;
            this.defaultTypeInfo_ = undefined;
        }, get defaultTypeInfo() {
            if (this.defaultTypeInfo_ === undefined && this.defaultConstructor_) {
                this.defaultTypeInfo_ = new RegisteredTypeInfo(this.defaultConstructor, this.defaultMetadata);
            }
            return this.defaultTypeInfo_;
        }, validateConstructor(constructor) {
            if (!this.mandatoryBaseClass) return;
            let curProto = constructor.prototype.__proto__;
            let ok = false;
            while (curProto) {
                if (curProto === this.mandatoryBaseClass.prototype) {
                    ok = true;
                    break;
                }
                curProto = curProto.__proto__;
            }
            if (!ok) {
                throw new Error(constructor + 'must be subclass of ' + registry);
            }
        }
    };
    return {BASIC_REGISTRY_MODE, TYPE_BASED_REGISTRY_MODE, ExtensionRegistryOptions, RegisteredTypeInfo,};
});
'use strict';
tr.exportTo('tr.b', function () {
    let Event;
    if (tr.isHeadless) {
        function HeadlessEvent(type, opt_bubbles, opt_preventable) {
            this.type = type;
            this.bubbles = (opt_bubbles !== undefined ? !!opt_bubbles : false);
            this.cancelable = (opt_preventable !== undefined ? !!opt_preventable : false);
            this.defaultPrevented = false;
            this.cancelBubble = false;
        }

        HeadlessEvent.prototype = {
            preventDefault() {
                this.defaultPrevented = true;
            }, stopPropagation() {
                this.cancelBubble = true;
            }
        };
        Event = HeadlessEvent;
    } else {
        function TrEvent(type, opt_bubbles, opt_preventable) {
            const e = tr.doc.createEvent('Event');
            e.initEvent(type, !!opt_bubbles, !!opt_preventable);
            e.__proto__ = global.Event.prototype;
            return e;
        }

        TrEvent.prototype = {__proto__: global.Event.prototype};
        Event = TrEvent;
    }

    function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable, opt_fields) {
        const e = new tr.b.Event(type, opt_bubbles, opt_cancelable);
        Object.assign(e, opt_fields);
        return target.dispatchEvent(e);
    }

    async function dispatchSimpleEventAsync(target, type, opt_fields) {
        const e = new tr.b.Event(type, false, false);
        Object.assign(e, opt_fields);
        return await target.dispatchAsync(e);
    }

    return {Event, dispatchSimpleEvent, dispatchSimpleEventAsync,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
    const ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;

    function decorateBasicExtensionRegistry(registry, extensionRegistryOptions) {
        const savedStateStack = [];
        registry.registeredTypeInfos_ = [];
        registry.register = function (constructor, opt_metadata) {
            if (registry.findIndexOfRegisteredConstructor(constructor) !== undefined) {
                throw new Error('Handler already registered for ' + constructor);
            }
            extensionRegistryOptions.validateConstructor(constructor);
            const metadata = {};
            for (const k in extensionRegistryOptions.defaultMetadata) {
                metadata[k] = extensionRegistryOptions.defaultMetadata[k];
            }
            if (opt_metadata) {
                for (const k in opt_metadata) {
                    metadata[k] = opt_metadata[k];
                }
            }
            const typeInfo = new RegisteredTypeInfo(constructor, metadata);
            let e = new tr.b.Event('will-register');
            e.typeInfo = typeInfo;
            registry.dispatchEvent(e);
            registry.registeredTypeInfos_.push(typeInfo);
            e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.pushCleanStateBeforeTest = function () {
            savedStateStack.push(registry.registeredTypeInfos_);
            registry.registeredTypeInfos_ = [];
            const e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.popCleanStateAfterTest = function () {
            registry.registeredTypeInfos_ = savedStateStack[0];
            savedStateStack.splice(0, 1);
            const e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.findIndexOfRegisteredConstructor = function (constructor) {
            for (let i = 0; i < registry.registeredTypeInfos_.length; i++) {
                if (registry.registeredTypeInfos_[i].constructor === constructor) {
                    return i;
                }
            }
            return undefined;
        };
        registry.unregister = function (constructor) {
            const foundIndex = registry.findIndexOfRegisteredConstructor(constructor);
            if (foundIndex === undefined) {
                throw new Error(constructor + ' not registered');
            }
            registry.registeredTypeInfos_.splice(foundIndex, 1);
            const e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.getAllRegisteredTypeInfos = function () {
            return registry.registeredTypeInfos_;
        };
        registry.findTypeInfo = function (constructor) {
            const foundIndex = this.findIndexOfRegisteredConstructor(constructor);
            if (foundIndex !== undefined) {
                return this.registeredTypeInfos_[foundIndex];
            }
            return undefined;
        };
        registry.findTypeInfoMatching = function (predicate, opt_this) {
            opt_this = opt_this ? opt_this : undefined;
            for (let i = 0; i < registry.registeredTypeInfos_.length; ++i) {
                const typeInfo = registry.registeredTypeInfos_[i];
                if (predicate.call(opt_this, typeInfo)) {
                    return typeInfo;
                }
            }
            return extensionRegistryOptions.defaultTypeInfo;
        };
        registry.findTypeInfoWithName = function (name) {
            if (typeof (name) !== 'string') {
                throw new Error('Name is not a string.');
            }
            const typeInfo = registry.findTypeInfoMatching(function (ti) {
                return ti.constructor.name === name;
            });
            if (typeInfo) return typeInfo;
            return undefined;
        };
    }

    return {_decorateBasicExtensionRegistry: decorateBasicExtensionRegistry};
});
'use strict';
tr.exportTo('tr.b', function () {
    const categoryPartsFor = {};

    function getCategoryParts(category) {
        let parts = categoryPartsFor[category];
        if (parts !== undefined) return parts;
        parts = category.split(',');
        categoryPartsFor[category] = parts;
        return parts;
    }

    return {getCategoryParts,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const getCategoryParts = tr.b.getCategoryParts;
    const RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
    const ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;

    function decorateTypeBasedExtensionRegistry(registry, extensionRegistryOptions) {
        const savedStateStack = [];
        registry.registeredTypeInfos_ = [];
        registry.categoryPartToTypeInfoMap_ = new Map();
        registry.typeNameToTypeInfoMap_ = new Map();
        registry.register = function (constructor, metadata) {
            extensionRegistryOptions.validateConstructor(constructor);
            const typeInfo = new RegisteredTypeInfo(constructor, metadata || extensionRegistryOptions.defaultMetadata);
            typeInfo.typeNames = [];
            typeInfo.categoryParts = [];
            if (metadata && metadata.typeName) {
                typeInfo.typeNames.push(metadata.typeName);
            }
            if (metadata && metadata.typeNames) {
                typeInfo.typeNames.push.apply(typeInfo.typeNames, metadata.typeNames);
            }
            if (metadata && metadata.categoryParts) {
                typeInfo.categoryParts.push.apply(typeInfo.categoryParts, metadata.categoryParts);
            }
            if (typeInfo.typeNames.length === 0 && typeInfo.categoryParts.length === 0) {
                throw new Error('typeName or typeNames must be provided');
            }
            typeInfo.typeNames.forEach(function (typeName) {
                if (registry.typeNameToTypeInfoMap_.has(typeName)) {
                    throw new Error('typeName ' + typeName + ' already registered');
                }
            });
            typeInfo.categoryParts.forEach(function (categoryPart) {
                if (registry.categoryPartToTypeInfoMap_.has(categoryPart)) {
                    throw new Error('categoryPart ' + categoryPart + ' already registered');
                }
            });
            let e = new tr.b.Event('will-register');
            e.typeInfo = typeInfo;
            registry.dispatchEvent(e);
            typeInfo.typeNames.forEach(function (typeName) {
                registry.typeNameToTypeInfoMap_.set(typeName, typeInfo);
            });
            typeInfo.categoryParts.forEach(function (categoryPart) {
                registry.categoryPartToTypeInfoMap_.set(categoryPart, typeInfo);
            });
            registry.registeredTypeInfos_.push(typeInfo);
            e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.pushCleanStateBeforeTest = function () {
            savedStateStack.push({
                registeredTypeInfos: registry.registeredTypeInfos_,
                typeNameToTypeInfoMap: registry.typeNameToTypeInfoMap_,
                categoryPartToTypeInfoMap: registry.categoryPartToTypeInfoMap_
            });
            registry.registeredTypeInfos_ = [];
            registry.typeNameToTypeInfoMap_ = new Map();
            registry.categoryPartToTypeInfoMap_ = new Map();
            const e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.popCleanStateAfterTest = function () {
            const state = savedStateStack[0];
            savedStateStack.splice(0, 1);
            registry.registeredTypeInfos_ = state.registeredTypeInfos;
            registry.typeNameToTypeInfoMap_ = state.typeNameToTypeInfoMap;
            registry.categoryPartToTypeInfoMap_ = state.categoryPartToTypeInfoMap;
            const e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.unregister = function (constructor) {
            let typeInfoIndex = -1;
            for (let i = 0; i < registry.registeredTypeInfos_.length; i++) {
                if (registry.registeredTypeInfos_[i].constructor === constructor) {
                    typeInfoIndex = i;
                    break;
                }
            }
            if (typeInfoIndex === -1) {
                throw new Error(constructor + ' not registered');
            }
            const typeInfo = registry.registeredTypeInfos_[typeInfoIndex];
            registry.registeredTypeInfos_.splice(typeInfoIndex, 1);
            typeInfo.typeNames.forEach(function (typeName) {
                registry.typeNameToTypeInfoMap_.delete(typeName);
            });
            typeInfo.categoryParts.forEach(function (categoryPart) {
                registry.categoryPartToTypeInfoMap_.delete(categoryPart);
            });
            const e = new tr.b.Event('registry-changed');
            registry.dispatchEvent(e);
        };
        registry.getTypeInfo = function (category, typeName) {
            if (category) {
                const categoryParts = getCategoryParts(category);
                for (let i = 0; i < categoryParts.length; i++) {
                    const categoryPart = categoryParts[i];
                    const typeInfo = registry.categoryPartToTypeInfoMap_.get(categoryPart);
                    if (typeInfo !== undefined) return typeInfo;
                }
            }
            const typeInfo = registry.typeNameToTypeInfoMap_.get(typeName);
            if (typeInfo !== undefined) return typeInfo;
            return extensionRegistryOptions.defaultTypeInfo;
        };
        registry.getConstructor = function (category, typeName) {
            const typeInfo = registry.getTypeInfo(category, typeName);
            if (typeInfo) return typeInfo.constructor;
            return undefined;
        };
    }

    return {_decorateTypeBasedExtensionRegistry: decorateTypeBasedExtensionRegistry};
});
'use strict';
tr.exportTo('tr.b', function () {
    const URL_REGEX = /^(https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b|file:\/\/)([-a-zA-Z0-9@:%_\+.~#?&//=]*)$/;

    function deepCopy(value) {
        if (!(value instanceof Object)) {
            if (value === undefined || value === null) return value;
            if (typeof value === 'string') return value.substring();
            if (typeof value === 'boolean') return value;
            if (typeof value === 'number') return value;
            throw new Error('Unrecognized: ' + typeof value);
        }
        const object = value;
        if (object instanceof Array) {
            const res = new Array(object.length);
            for (let i = 0; i < object.length; i++) {
                res[i] = deepCopy(object[i]);
            }
            return res;
        }
        if (object.__proto__ !== Object.prototype) {
            throw new Error('Can only clone simple types');
        }
        const res = {};
        for (const key in object) {
            res[key] = deepCopy(object[key]);
        }
        return res;
    }

    function normalizeException(e) {
        if (e === undefined || e === null) {
            return {typeName: 'UndefinedError', message: 'Unknown: null or undefined exception', stack: 'Unknown'};
        }
        if (typeof (e) === 'string') {
            return {typeName: 'StringError', message: e, stack: [e]};
        }
        let typeName;
        if (e.name) {
            typeName = e.name;
        } else if (e.constructor) {
            if (e.constructor.name) {
                typeName = e.constructor.name;
            } else {
                typeName = 'AnonymousError';
            }
        } else {
            typeName = 'ErrorWithNoConstructor';
        }
        const msg = e.message ? e.message : 'Unknown';
        return {typeName, message: msg, stack: e.stack ? e.stack : [msg]};
    }

    function stackTraceAsString() {
        return new Error().stack + '';
    }

    function stackTrace() {
        let stack = stackTraceAsString();
        stack = stack.split('\n');
        return stack.slice(2);
    }

    function getUsingPath(path, fromDict) {
        const parts = path.split('.');
        let cur = fromDict;
        for (let part; parts.length && (part = parts.shift());) {
            if (!parts.length) {
                return cur[part];
            } else if (part in cur) {
                cur = cur[part];
            } else {
                return undefined;
            }
        }
        return undefined;
    }

    function formatDate(date) {
        return date.toISOString().replace('T', ' ').slice(0, 19);
    }

    function numberToJson(n) {
        if (isNaN(n)) return 'NaN';
        if (n === Infinity) return 'Infinity';
        if (n === -Infinity) return '-Infinity';
        return n;
    }

    function numberFromJson(n) {
        if (n === 'NaN' || n === null) return NaN;
        if (n === 'Infinity') return Infinity;
        if (n === '-Infinity') return -Infinity;
        return n;
    }

    function runLengthEncoding(ary) {
        const encodedArray = [];
        for (const element of ary) {
            if (encodedArray.length === 0 || encodedArray[encodedArray.length - 1].value !== element) {
                encodedArray.push({value: element, count: 1,});
            } else {
                encodedArray[encodedArray.length - 1].count += 1;
            }
        }
        return encodedArray;
    }

    function isUrl(s) {
        return typeof (s) === 'string' && s.match(URL_REGEX) !== null;
    }

    function getOnlyElement(iterable) {
        const iterator = iterable[Symbol.iterator]();
        const firstIteration = iterator.next();
        if (firstIteration.done) {
            throw new Error('getOnlyElement was passed an empty iterable.');
        }
        const secondIteration = iterator.next();
        if (!secondIteration.done) {
            throw new Error('getOnlyElement was passed an iterable with multiple elements.');
        }
        return firstIteration.value;
    }

    function getFirstElement(iterable) {
        const iterator = iterable[Symbol.iterator]();
        const result = iterator.next();
        if (result.done) {
            throw new Error('getFirstElement was passed an empty iterable.');
        }
        return result.value;
    }

    function compareArrays(x, y, elementCmp) {
        const minLength = Math.min(x.length, y.length);
        let i;
        for (i = 0; i < minLength; i++) {
            const tmp = elementCmp(x[i], y[i]);
            if (tmp) return tmp;
        }
        if (x.length === y.length) return 0;
        if (x[i] === undefined) return -1;
        return 1;
    }

    function groupIntoMap(ary, callback, opt_this, opt_arrayConstructor) {
        const arrayConstructor = opt_arrayConstructor || Array;
        const results = new Map();
        for (const element of ary) {
            const key = callback.call(opt_this, element);
            let items = results.get(key);
            if (items === undefined) {
                items = new arrayConstructor();
                results.set(key, items);
            }
            items.push(element);
        }
        return results;
    }

    function inPlaceFilter(array, predicate, opt_this) {
        opt_this = opt_this || this;
        let nextPosition = 0;
        for (let i = 0; i < array.length; i++) {
            if (!predicate.call(opt_this, array[i], i)) continue;
            if (nextPosition < i) {
                array[nextPosition] = array[i];
            }
            nextPosition++;
        }
        if (nextPosition < array.length) {
            array.length = nextPosition;
        }
    }

    function invertArrayOfDicts(array, opt_dictGetter, opt_this) {
        opt_this = opt_this || this;
        const result = {};
        for (let i = 0; i < array.length; i++) {
            const item = array[i];
            if (item === undefined) continue;
            const dict = opt_dictGetter ? opt_dictGetter.call(opt_this, item) : item;
            if (dict === undefined) continue;
            for (const key in dict) {
                let valueList = result[key];
                if (valueList === undefined) {
                    result[key] = valueList = new Array(array.length);
                }
                valueList[i] = dict[key];
            }
        }
        return result;
    }

    function setsEqual(a, b) {
        if (!(a instanceof Set) || !(b instanceof Set)) return false;
        if (a.size !== b.size) return false;
        for (const x of a) {
            if (!b.has(x)) return false;
        }
        return true;
    }

    function findLowIndexInSortedArray(ary, mapFn, loVal) {
        if (ary.length === 0) return 1;
        let low = 0;
        let high = ary.length - 1;
        let i;
        let comparison;
        let hitPos = -1;
        while (low <= high) {
            i = Math.floor((low + high) / 2);
            comparison = mapFn(ary[i]) - loVal;
            if (comparison < 0) {
                low = i + 1;
                continue;
            } else if (comparison > 0) {
                high = i - 1;
                continue;
            } else {
                hitPos = i;
                high = i - 1;
            }
        }
        return hitPos !== -1 ? hitPos : low;
    }

    function findIndexInSortedIntervals(ary, mapLoFn, mapWidthFn, loVal) {
        const first = findLowIndexInSortedArray(ary, mapLoFn, loVal);
        if (first === 0) {
            if (loVal >= mapLoFn(ary[0]) && loVal < mapLoFn(ary[0]) + mapWidthFn(ary[0], 0)) {
                return 0;
            }
            return -1;
        }
        if (first < ary.length) {
            if (loVal >= mapLoFn(ary[first]) && loVal < mapLoFn(ary[first]) + mapWidthFn(ary[first], first)) {
                return first;
            }
            if (loVal >= mapLoFn(ary[first - 1]) && loVal < mapLoFn(ary[first - 1]) +
                mapWidthFn(ary[first - 1], first - 1)) {
                return first - 1;
            }
            return ary.length;
        }
        if (first === ary.length) {
            if (loVal >= mapLoFn(ary[first - 1]) && loVal < mapLoFn(ary[first - 1]) +
                mapWidthFn(ary[first - 1], first - 1)) {
                return first - 1;
            }
            return ary.length;
        }
        return ary.length;
    }

    function findIndexInSortedClosedIntervals(ary, mapLoFn, mapHiFn, val) {
        const i = findLowIndexInSortedArray(ary, mapLoFn, val);
        if (i === 0) {
            if (val >= mapLoFn(ary[0], 0) && val <= mapHiFn(ary[0], 0)) {
                return 0;
            }
            return -1;
        }
        if (i < ary.length) {
            if (val >= mapLoFn(ary[i - 1], i - 1) && val <= mapHiFn(ary[i - 1], i - 1)) {
                return i - 1;
            }
            if (val >= mapLoFn(ary[i], i) && val <= mapHiFn(ary[i], i)) {
                return i;
            }
            return ary.length;
        }
        if (i === ary.length) {
            if (val >= mapLoFn(ary[i - 1], i - 1) && val <= mapHiFn(ary[i - 1], i - 1)) {
                return i - 1;
            }
            return ary.length;
        }
        return ary.length;
    }

    function iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal, cb) {
        if (ary.length === 0) return;
        if (loVal > hiVal) return;
        let i = findLowIndexInSortedArray(ary, mapLoFn, loVal);
        if (i === -1) {
            return;
        }
        if (i > 0) {
            const hi = mapLoFn(ary[i - 1]) + mapWidthFn(ary[i - 1], i - 1);
            if (hi >= loVal) {
                cb(ary[i - 1], i - 1);
            }
        }
        if (i === ary.length) {
            return;
        }
        for (let n = ary.length; i < n; i++) {
            const lo = mapLoFn(ary[i]);
            if (lo >= hiVal) break;
            cb(ary[i], i);
        }
    }

    function findClosestElementInSortedArray(ary, mapFn, val, maxDiff) {
        if (ary.length === 0) return null;
        let aftIdx = findLowIndexInSortedArray(ary, mapFn, val);
        const befIdx = aftIdx > 0 ? aftIdx - 1 : 0;
        if (aftIdx === ary.length) aftIdx -= 1;
        const befDiff = Math.abs(val - mapFn(ary[befIdx]));
        const aftDiff = Math.abs(val - mapFn(ary[aftIdx]));
        if (befDiff > maxDiff && aftDiff > maxDiff) return null;
        const idx = befDiff < aftDiff ? befIdx : aftIdx;
        return ary[idx];
    }

    function findClosestIntervalInSortedIntervals(ary, mapLoFn, mapHiFn, val, maxDiff) {
        if (ary.length === 0) return null;
        let idx = findLowIndexInSortedArray(ary, mapLoFn, val);
        if (idx > 0) idx -= 1;
        const hiInt = ary[idx];
        let loInt = hiInt;
        if (val > mapHiFn(hiInt) && idx + 1 < ary.length) {
            loInt = ary[idx + 1];
        }
        const loDiff = Math.abs(val - mapLoFn(loInt));
        const hiDiff = Math.abs(val - mapHiFn(hiInt));
        if (loDiff > maxDiff && hiDiff > maxDiff) return null;
        if (loDiff < hiDiff) return loInt;
        return hiInt;
    }

    function findFirstTrueIndexInSortedArray(array, test) {
        let i0 = 0;
        let i1 = array.length;
        while (i0 < i1) {
            const i = Math.trunc((i0 + i1) / 2);
            if (test(array[i])) {
                i1 = i;
            } else {
                i0 = i + 1;
            }
        }
        return i1;
    }

    return {
        compareArrays,
        deepCopy,
        findClosestElementInSortedArray,
        findClosestIntervalInSortedIntervals,
        findFirstTrueIndexInSortedArray,
        findIndexInSortedClosedIntervals,
        findIndexInSortedIntervals,
        findLowIndexInSortedArray,
        formatDate,
        getFirstElement,
        getOnlyElement,
        getUsingPath,
        groupIntoMap,
        inPlaceFilter,
        invertArrayOfDicts,
        isUrl,
        iterateOverIntersectingIntervals,
        normalizeException,
        numberFromJson,
        numberToJson,
        runLengthEncoding,
        setsEqual,
        stackTrace,
        stackTraceAsString,
    };
});
'use strict';
tr.exportTo('tr.b', function () {
    function decorateExtensionRegistry(registry, registryOptions) {
        if (registry.register) {
            throw new Error('Already has registry');
        }
        registryOptions.freeze();
        if (registryOptions.mode === tr.b.BASIC_REGISTRY_MODE) {
            tr.b._decorateBasicExtensionRegistry(registry, registryOptions);
        } else if (registryOptions.mode === tr.b.TYPE_BASED_REGISTRY_MODE) {
            tr.b._decorateTypeBasedExtensionRegistry(registry, registryOptions);
        } else {
            throw new Error('Unrecognized mode');
        }
        if (registry.addEventListener === undefined) {
            tr.b.EventTarget.decorate(registry);
        }
    }

    return {decorateExtensionRegistry,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    function Importer() {
    }

    Importer.prototype = {
        __proto__: Object.prototype, get importerName() {
            return 'Importer';
        }, isTraceDataContainer() {
            return false;
        }, extractSubtraces() {
            return [];
        }, importClockSyncMarkers() {
        }, importEvents() {
        }, importSampleData() {
        }, finalizeImport() {
        }
    };
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    options.defaultMetadata = {};
    options.mandatoryBaseClass = Importer;
    tr.b.decorateExtensionRegistry(Importer, options);
    Importer.findImporterFor = function (eventData) {
        const typeInfo = Importer.findTypeInfoMatching(function (ti) {
            return ti.constructor.canImport(eventData);
        });
        if (typeInfo) {
            return typeInfo.constructor;
        }
        return undefined;
    };
    return {Importer,};
});
'use strict';
tr.exportTo('tr.e.importer.gcloud_trace', function () {
    function GcloudTraceImporter(model, eventData) {
        this.importPriority = 2;
        this.eventData_ = eventData;
    }

    GcloudTraceImporter.canImport = function (eventData) {
        if (typeof (eventData) !== 'string' && !(eventData instanceof String)) {
            return false;
        }
        const normalizedEventData = eventData.slice(0, 20).replace(/\s/g, '');
        if (normalizedEventData.length < 14) return false;
        return normalizedEventData.slice(0, 14) === '{"projectId":"';
    };
    GcloudTraceImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'GcloudTraceImporter';
        }, extractSubtraces() {
            const traceEvents = this.createEventsForTrace();
            return traceEvents ? [traceEvents] : [];
        }, createEventsForTrace() {
            const events = [];
            const trace = JSON.parse(this.eventData_);
            const spanLength = trace.spans.length;
            for (let i = 0; i < spanLength; i++) {
                events.push(this.createEventForSpan(trace.traceId, trace.spans[i]));
            }
            return {'traceEvents': events};
        }, createEventForSpan(traceId, span) {
            let newArgs = {};
            if (span.labels) {
                newArgs = JSON.parse(JSON.stringify(span.labels));
            }
            newArgs['Span ID'] = span.spanId;
            newArgs['Start Time'] = span.startTime;
            newArgs['End Time'] = span.endTime;
            if (span.parentSpanId) {
                newArgs['Parent Span ID'] = span.parentSpanId;
            }
            return {
                name: span.name,
                args: newArgs,
                pid: traceId,
                ts: Date.parse(span.startTime) * 1000,
                dur: (Date.parse(span.endTime) - Date.parse(span.startTime)) * 1000,
                cat: 'tracespan',
                tid: traceId,
                ph: 'X'
            };
        }
    };
    tr.importer.Importer.register(GcloudTraceImporter);
    return {GcloudTraceImporter,};
});
'use strict';
tr.exportTo('tr.b.math', function () {
    function convertEventsToRanges(events) {
        return events.map(function (event) {
            return tr.b.math.Range.fromExplicitRange(event.start, event.end);
        });
    }

    function mergeRanges(inRanges, mergeThreshold, mergeFunction) {
        const remainingEvents = inRanges.slice();
        remainingEvents.sort(function (x, y) {
            return x.min - y.min;
        });
        if (remainingEvents.length <= 1) {
            const merged = [];
            if (remainingEvents.length === 1) {
                merged.push(mergeFunction(remainingEvents));
            }
            return merged;
        }
        const mergedEvents = [];
        let currentMergeBuffer = [];
        let rightEdge;

        function beginMerging() {
            currentMergeBuffer.push(remainingEvents[0]);
            remainingEvents.splice(0, 1);
            rightEdge = currentMergeBuffer[0].max;
        }

        function flushCurrentMergeBuffer() {
            if (currentMergeBuffer.length === 0) return;
            mergedEvents.push(mergeFunction(currentMergeBuffer));
            currentMergeBuffer = [];
            if (remainingEvents.length !== 0) beginMerging();
        }

        beginMerging();
        while (remainingEvents.length) {
            const currentEvent = remainingEvents[0];
            const distanceFromRightEdge = currentEvent.min - rightEdge;
            if (distanceFromRightEdge < mergeThreshold) {
                rightEdge = Math.max(rightEdge, currentEvent.max);
                remainingEvents.splice(0, 1);
                currentMergeBuffer.push(currentEvent);
                continue;
            }
            flushCurrentMergeBuffer();
        }
        flushCurrentMergeBuffer();
        return mergedEvents;
    }

    function findEmptyRangesBetweenRanges(inRanges, opt_totalRange) {
        if (opt_totalRange && opt_totalRange.isEmpty) opt_totalRange = undefined;
        const emptyRanges = [];
        if (!inRanges.length) {
            if (opt_totalRange) emptyRanges.push(opt_totalRange);
            return emptyRanges;
        }
        inRanges = inRanges.slice();
        inRanges.sort(function (x, y) {
            return x.min - y.min;
        });
        if (opt_totalRange && (opt_totalRange.min < inRanges[0].min)) {
            emptyRanges.push(tr.b.math.Range.fromExplicitRange(opt_totalRange.min, inRanges[0].min));
        }
        inRanges.forEach(function (range, index) {
            for (let otherIndex = 0; otherIndex < inRanges.length; ++otherIndex) {
                if (index === otherIndex) continue;
                const other = inRanges[otherIndex];
                if (other.min > range.max) {
                    emptyRanges.push(tr.b.math.Range.fromExplicitRange(range.max, other.min));
                    return;
                }
                if (other.max > range.max) {
                    return;
                }
            }
            if (opt_totalRange && (range.max < opt_totalRange.max)) {
                emptyRanges.push(tr.b.math.Range.fromExplicitRange(range.max, opt_totalRange.max));
            }
        });
        return emptyRanges;
    }

    return {convertEventsToRanges, findEmptyRangesBetweenRanges, mergeRanges,};
});
'use strict';
tr.exportTo('tr.b.math', function () {
    const PREFERRED_NUMBER_SERIES_MULTIPLIERS = [1, 2, 5, 10];

    function approximately(x, y, delta) {
        if (delta === undefined) delta = 1e-9;
        return Math.abs(x - y) < delta;
    }

    function clamp(x, lo, hi) {
        return Math.min(Math.max(x, lo), hi);
    }

    function lerp(percentage, lo, hi) {
        const range = hi - lo;
        return lo + percentage * range;
    }

    function normalize(value, lo, hi) {
        return (value - lo) / (hi - lo);
    }

    function deg2rad(deg) {
        return (Math.PI * deg) / 180.0;
    }

    function erf(x) {
        const sign = (x >= 0) ? 1 : -1;
        x = Math.abs(x);
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        return sign * y;
    }

    const tmpVec2 = vec2.create();
    const tmpVec2b = vec2.create();
    const tmpVec4 = vec4.create();
    const tmpMat2d = mat2d.create();
    vec2.createFromArray = function (arr) {
        if (arr.length !== 2) throw new Error('Should be length 2');
        const v = vec2.create();
        vec2.set(v, arr[0], arr[1]);
        return v;
    };
    vec2.createXY = function (x, y) {
        const v = vec2.create();
        vec2.set(v, x, y);
        return v;
    };
    vec2.toString = function (a) {
        return '[' + a[0] + ', ' + a[1] + ']';
    };
    vec2.addTwoScaledUnitVectors = function (out, u1, scale1, u2, scale2) {
        vec2.scale(tmpVec2, u1, scale1);
        vec2.scale(tmpVec2b, u2, scale2);
        vec2.add(out, tmpVec2, tmpVec2b);
    };
    vec2.interpolatePiecewiseFunction = function (points, x) {
        if (x < points[0][0]) return points[0][1];
        for (let i = 1; i < points.length; ++i) {
            if (x < points[i][0]) {
                const percent = normalize(x, points[i - 1][0], points[i][0]);
                return lerp(percent, points[i - 1][1], points[i][1]);
            }
        }
        return points[points.length - 1][1];
    };
    vec3.createXYZ = function (x, y, z) {
        const v = vec3.create();
        vec3.set(v, x, y, z);
        return v;
    };
    vec3.toString = function (a) {
        return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
    };
    mat2d.translateXY = function (out, x, y) {
        vec2.set(tmpVec2, x, y);
        mat2d.translate(out, out, tmpVec2);
    };
    mat2d.scaleXY = function (out, x, y) {
        vec2.set(tmpVec2, x, y);
        mat2d.scale(out, out, tmpVec2);
    };
    vec4.unitize = function (out, a) {
        out[0] = a[0] / a[3];
        out[1] = a[1] / a[3];
        out[2] = a[2] / a[3];
        out[3] = 1;
        return out;
    };
    vec2.copyFromVec4 = function (out, a) {
        vec4.unitize(tmpVec4, a);
        vec2.copy(out, tmpVec4);
    };

    function logOrLog10(x, base) {
        if (base === 10) return Math.log10(x);
        return Math.log(x) / Math.log(base);
    }

    function lesserPower(x, opt_base) {
        const base = opt_base || 10;
        return Math.pow(base, Math.floor(logOrLog10(x, base)));
    }

    function greaterPower(x, opt_base) {
        const base = opt_base || 10;
        return Math.pow(base, Math.ceil(logOrLog10(x, base)));
    }

    function lesserWholeNumber(x) {
        if (x === 0) return 0;
        const pow10 = (x < 0) ? -lesserPower(-x) : lesserPower(x);
        return pow10 * Math.floor(x / pow10);
    }

    function greaterWholeNumber(x) {
        if (x === 0) return 0;
        const pow10 = (x < 0) ? -lesserPower(-x) : lesserPower(x);
        return pow10 * Math.ceil(x / pow10);
    }

    function truncate(value, digits) {
        const pow10 = Math.pow(10, digits);
        return Math.round(value * pow10) / pow10;
    }

    function preferredNumberLargerThanMin(min) {
        const absMin = Math.abs(min);
        const conservativeGuess = tr.b.math.lesserPower(absMin);
        let minPreferedNumber = undefined;
        for (const multiplier of PREFERRED_NUMBER_SERIES_MULTIPLIERS) {
            const tightenedGuess = conservativeGuess * multiplier;
            if (tightenedGuess >= absMin) {
                minPreferedNumber = tightenedGuess;
                break;
            }
        }
        if (minPreferedNumber === undefined) {
            throw new Error('Could not compute preferred number for ' + min);
        }
        if (min < 0) minPreferedNumber *= -1;
        return minPreferedNumber;
    }

    return {
        approximately,
        clamp,
        lerp,
        normalize,
        deg2rad,
        erf,
        lesserPower,
        greaterPower,
        lesserWholeNumber,
        greaterWholeNumber,
        preferredNumberLargerThanMin,
        truncate,
    };
});
'use strict';
tr.exportTo('tr.b.math', function () {
    function Range() {
        this.isEmpty_ = true;
        this.min_ = undefined;
        this.max_ = undefined;
    }

    Range.prototype = {
        __proto__: Object.prototype, clone() {
            if (this.isEmpty) return new Range();
            return Range.fromExplicitRange(this.min_, this.max_);
        }, reset() {
            this.isEmpty_ = true;
            this.min_ = undefined;
            this.max_ = undefined;
        }, get isEmpty() {
            return this.isEmpty_;
        }, addRange(range) {
            if (range.isEmpty) return;
            this.addValue(range.min);
            this.addValue(range.max);
        }, addValue(value) {
            if (this.isEmpty_) {
                this.max_ = value;
                this.min_ = value;
                this.isEmpty_ = false;
                return;
            }
            this.max_ = Math.max(this.max_, value);
            this.min_ = Math.min(this.min_, value);
        }, set min(min) {
            this.isEmpty_ = false;
            this.min_ = min;
        }, get min() {
            if (this.isEmpty_) return undefined;
            return this.min_;
        }, get max() {
            if (this.isEmpty_) return undefined;
            return this.max_;
        }, set max(max) {
            this.isEmpty_ = false;
            this.max_ = max;
        }, get range() {
            if (this.isEmpty_) return undefined;
            return this.max_ - this.min_;
        }, get center() {
            return (this.min_ + this.max_) * 0.5;
        }, get duration() {
            if (this.isEmpty_) return 0;
            return this.max_ - this.min_;
        }, enclosingPowers(opt_base) {
            if (this.isEmpty) return new Range();
            return Range.fromExplicitRange(tr.b.math.lesserPower(this.min_, opt_base), tr.b.math.greaterPower(this.max_, opt_base));
        }, normalize(x) {
            return tr.b.math.normalize(x, this.min, this.max);
        }, lerp(x) {
            return tr.b.math.lerp(x, this.min, this.max);
        }, clamp(x) {
            return tr.b.math.clamp(x, this.min, this.max);
        }, equals(that) {
            if (this.isEmpty && that.isEmpty) return true;
            if (this.isEmpty !== that.isEmpty) return false;
            return (tr.b.math.approximately(this.min, that.min) && tr.b.math.approximately(this.max, that.max));
        }, containsExplicitRangeInclusive(min, max) {
            if (this.isEmpty) return false;
            return this.min_ <= min && max <= this.max_;
        }, containsExplicitRangeExclusive(min, max) {
            if (this.isEmpty) return false;
            return this.min_ < min && max < this.max_;
        }, intersectsExplicitRangeInclusive(min, max) {
            if (this.isEmpty) return false;
            return this.min_ <= max && min <= this.max_;
        }, intersectsExplicitRangeExclusive(min, max) {
            if (this.isEmpty) return false;
            return this.min_ < max && min < this.max_;
        }, containsRangeInclusive(range) {
            if (range.isEmpty) return false;
            return this.containsExplicitRangeInclusive(range.min_, range.max_);
        }, containsRangeExclusive(range) {
            if (range.isEmpty) return false;
            return this.containsExplicitRangeExclusive(range.min_, range.max_);
        }, intersectsRangeInclusive(range) {
            if (range.isEmpty) return false;
            return this.intersectsExplicitRangeInclusive(range.min_, range.max_);
        }, intersectsRangeExclusive(range) {
            if (range.isEmpty) return false;
            return this.intersectsExplicitRangeExclusive(range.min_, range.max_);
        }, findExplicitIntersectionDuration(min, max) {
            min = Math.max(this.min, min);
            max = Math.min(this.max, max);
            if (max < min) return 0;
            return max - min;
        }, findIntersection(range) {
            if (this.isEmpty || range.isEmpty) return new Range();
            const min = Math.max(this.min, range.min);
            const max = Math.min(this.max, range.max);
            if (max < min) return new Range();
            return Range.fromExplicitRange(min, max);
        }, toJSON() {
            if (this.isEmpty_) return {isEmpty: true};
            return {isEmpty: false, max: this.max, min: this.min};
        }, filterArray(sortedArray, opt_keyFunc, opt_this) {
            if (this.isEmpty_) return [];
            const keyFunc = opt_keyFunc || (x => x);

            function getValue(obj) {
                return keyFunc.call(opt_this, obj);
            }

            const first = tr.b.findFirstTrueIndexInSortedArray(sortedArray, obj => this.min_ === undefined || this.min_ <= getValue(obj));
            const last = tr.b.findFirstTrueIndexInSortedArray(sortedArray, obj => this.max_ !== undefined && this.max_ < getValue(obj));
            return sortedArray.slice(first, last);
        }
    };
    Range.fromDict = function (d) {
        if (d.isEmpty === true) return new Range();
        if (d.isEmpty === false) {
            const range = new Range();
            range.min = d.min;
            range.max = d.max;
            return range;
        }
        throw new Error('Not a range');
    };
    Range.fromExplicitRange = function (min, max) {
        const range = new Range();
        range.min = min;
        range.max = max;
        return range;
    };
    Range.compareByMinTimes = function (a, b) {
        if (!a.isEmpty && !b.isEmpty) return a.min_ - b.min_;
        if (a.isEmpty && !b.isEmpty) return -1;
        if (!a.isEmpty && b.isEmpty) return 1;
        return 0;
    };
    Range.findDifference = function (rangeA, rangeB) {
        if (!rangeA || rangeA.duration < 0 || !rangeB || rangeB.duration < 0) {
            throw new Error(`Couldn't subtract ranges`);
        }
        const resultRanges = [];
        if (rangeA.isEmpty) return resultRanges;
        if (rangeB.isEmpty) return [rangeA.clone()];
        const intersection = rangeA.findIntersection(rangeB);
        if (intersection.isEmpty) {
            return [rangeA.clone()];
        }
        if (rangeA.duration === 0 && rangeB.duration === 0) {
            if (intersection.empty) return [rangeA.clone()]; else if (intersection.duration === 0) return resultRanges;
            throw new Error(`Two points' intersection can only be a point or empty`);
        }
        const leftRange = tr.b.math.Range.fromExplicitRange(rangeA.min, intersection.min);
        if (leftRange.duration > 0) {
            resultRanges.push(leftRange);
        }
        const rightRange = tr.b.math.Range.fromExplicitRange(intersection.max, rangeA.max);
        if (rightRange.duration > 0) {
            resultRanges.push(rightRange);
        }
        return resultRanges;
    };
    Range.PERCENT_RANGE = Range.fromExplicitRange(0, 1);
    Object.freeze(Range.PERCENT_RANGE);
    return {Range,};
});
'use strict';
(function (exports) {
    var rank = {
        standard: function (array, key) {
            array = array.sort(function (a, b) {
                var x = a[key];
                var y = b[key];
                return ((x < y) ? -1 : ((x > y) ? 1 : 0));
            });
            for (var i = 1; i < array.length + 1; i++) {
                array[i - 1]['rank'] = i;
            }
            return array;
        }, fractional: function (array, key) {
            array = this.standard(array, key);
            var pos = 0;
            while (pos < array.length) {
                var sum = 0;
                var i = 0;
                for (i = 0; array[pos + i + 1] && (array[pos + i][key] === array[pos + i + 1][key]); i++) {
                    sum += array[pos + i]['rank'];
                }
                sum += array[pos + i]['rank'];
                var endPos = pos + i + 1;
                for (pos; pos < endPos; pos++) {
                    array[pos]['rank'] = sum / (i + 1);
                }
                pos = endPos;
            }
            return array;
        }, rank: function (x, y) {
            var nx = x.length, ny = y.length, combined = [], ranked;
            while (nx--) {
                combined.push({set: 'x', val: x[nx]});
            }
            while (ny--) {
                combined.push({set: 'y', val: y[ny]});
            }
            ranked = this.fractional(combined, 'val');
            return ranked
        }
    };
    var erf = function erf(x) {
        var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2, -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4, 4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6, 1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8, 6.529054439e-9, 5.059343495e-9, -9.91364156e-10, -2.27365122e-10, 9.6467911e-11, 2.394038e-12, -6.886027e-12, 8.94487e-13, 3.13092e-13, -1.12708e-13, 3.81e-16, 7.106e-15, -1.523e-15, -9.4e-17, 1.21e-16, -2.8e-17];
        var j = cof.length - 1;
        var isneg = false;
        var d = 0;
        var dd = 0;
        var t, ty, tmp, res;
        if (x < 0) {
            x = -x;
            isneg = true;
        }
        t = 2 / (2 + x);
        ty = 4 * t - 2;
        for (; j > 0; j--) {
            tmp = d;
            d = ty * d - dd + cof[j];
            dd = tmp;
        }
        res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
        return isneg ? res - 1 : 1 - res;
    };
    var dnorm = function (x, mean, std) {
        return 0.5 * (1 + erf((x - mean) / Math.sqrt(2 * std * std)));
    }
    var statistic = function (x, y) {
        var ranked = rank.rank(x, y), nr = ranked.length, nx = x.length, ny = y.length, ranksums = {x: 0, y: 0},
            i = 0, t = 0, nt = 1, tcf, ux, uy;
        while (i < nr) {
            if (i > 0) {
                if (ranked[i].val == ranked[i - 1].val) {
                    nt++;
                } else {
                    if (nt > 1) {
                        t += Math.pow(nt, 3) - nt
                        nt = 1;
                    }
                }
            }
            ranksums[ranked[i].set] += ranked[i].rank
            i++;
        }
        tcf = 1 - (t / (Math.pow(nr, 3) - nr))
        ux = nx * ny + (nx * (nx + 1) / 2) - ranksums.x;
        uy = nx * ny - ux;
        return {tcf: tcf, ux: ux, uy: uy, big: Math.max(ux, uy), small: Math.min(ux, uy)}
    }
    exports.test = function (x, y, alt, corr) {
        alt = typeof alt !== 'undefined' ? alt : 'two-sided';
        corr = typeof corr !== 'undefined' ? corr : true;
        var nx = x.length, ny = y.length, f = 1, u, mu, std, z, p;
        u = statistic(x, y);
        if (corr) {
            mu = (nx * ny / 2) + 0.5;
        } else {
            mu = nx * ny / 2;
        }
        std = Math.sqrt(u.tcf * nx * ny * (nx + ny + 1) / 12);
        if (alt == 'less') {
            z = (u.ux - mu) / std;
        } else if (alt == 'greater') {
            z = (u.uy - mu) / std;
        } else if (alt == 'two-sided') {
            z = Math.abs((u.big - mu) / std);
        } else {
            console.log('Unknown alternative argument');
        }
        if (alt == 'two-sided') {
            f = 2;
        }
        p = dnorm(-z, 0, 1) * f;
        return {U: u.small, p: p};
    }
})(typeof exports === 'undefined' ? this['mannwhitneyu'] = {} : exports);
// 'use strict';
// (function (global) {
//     if (tr.isNode) {
//         const mwuAbsPath = HTMLImportsLoader.hrefToAbsolutePath('/mannwhitneyu.js');
//         const mwuModule = require(mwuAbsPath);
//         for (const exportName in mwuModule) {
//             global[exportName] = mwuModule[exportName];
//         }
//     }
// })(this);
'use strict';
tr.exportTo('tr.b.math', function () {
    const Statistics = {};
    Statistics.divideIfPossibleOrZero = function (numerator, denominator) {
        if (denominator === 0) return 0;
        return numerator / denominator;
    };
    Statistics.sum = function (ary, opt_func, opt_this) {
        const func = opt_func || (x => x);
        let ret = 0;
        let i = 0;
        for (const elt of ary) {
            ret += func.call(opt_this, elt, i++);
        }
        return ret;
    };
    Statistics.mean = function (ary, opt_func, opt_this) {
        const func = opt_func || (x => x);
        let sum = 0;
        let i = 0;
        for (const elt of ary) {
            sum += func.call(opt_this, elt, i++);
        }
        if (i === 0) return undefined;
        return sum / i;
    };
    Statistics.geometricMean = function (ary, opt_func, opt_this) {
        const func = opt_func || (x => x);
        let i = 0;
        let logsum = 0;
        for (const elt of ary) {
            const x = func.call(opt_this, elt, i++);
            if (x <= 0) return 0;
            logsum += Math.log(Math.abs(x));
        }
        if (i === 0) return 1;
        return Math.exp(logsum / i);
    };
    Statistics.weightedMean = function (ary, weightCallback, opt_valueCallback, opt_this) {
        const valueCallback = opt_valueCallback || (x => x);
        let numerator = 0;
        let denominator = 0;
        let i = -1;
        for (const elt of ary) {
            i++;
            const value = valueCallback.call(opt_this, elt, i);
            if (value === undefined) continue;
            const weight = weightCallback.call(opt_this, elt, i, value);
            numerator += weight * value;
            denominator += weight;
        }
        if (denominator === 0) return undefined;
        return numerator / denominator;
    };
    Statistics.variance = function (ary, opt_func, opt_this) {
        if (ary.length === 0) return undefined;
        if (ary.length === 1) return 0;
        const func = opt_func || (x => x);
        const mean = Statistics.mean(ary, func, opt_this);
        const sumOfSquaredDistances = Statistics.sum(ary, function (d, i) {
            const v = func.call(this, d, i) - mean;
            return v * v;
        }, opt_this);
        return sumOfSquaredDistances / (ary.length - 1);
    };
    Statistics.stddev = function (ary, opt_func, opt_this) {
        if (ary.length === 0) return undefined;
        return Math.sqrt(Statistics.variance(ary, opt_func, opt_this));
    };
    Statistics.max = function (ary, opt_func, opt_this) {
        const func = opt_func || (x => x);
        let ret = -Infinity;
        let i = 0;
        for (const elt of ary) {
            ret = Math.max(ret, func.call(opt_this, elt, i++));
        }
        return ret;
    };
    Statistics.min = function (ary, opt_func, opt_this) {
        const func = opt_func || (x => x);
        let ret = Infinity;
        let i = 0;
        for (const elt of ary) {
            ret = Math.min(ret, func.call(opt_this, elt, i++));
        }
        return ret;
    };
    Statistics.range = function (ary, opt_func, opt_this) {
        const func = opt_func || (x => x);
        const ret = new tr.b.math.Range();
        let i = 0;
        for (const elt of ary) {
            ret.addValue(func.call(opt_this, elt, i++));
        }
        return ret;
    };
    Statistics.percentile = function (ary, percent, opt_func, opt_this) {
        if (!(percent >= 0 && percent <= 1)) {
            throw new Error('percent must be [0,1]');
        }
        const func = opt_func || (x => x);
        const tmp = new Array(ary.length);
        let i = 0;
        for (const elt of ary) {
            tmp[i] = func.call(opt_this, elt, i++);
        }
        tmp.sort((a, b) => a - b);
        const idx = Math.floor((ary.length - 1) * percent);
        return tmp[idx];
    };
    Statistics.normalizeSamples = function (samples) {
        if (samples.length === 0) {
            return {normalized_samples: samples, scale: 1.0};
        }
        samples = samples.slice().sort(function (a, b) {
            return a - b;
        });
        const low = Math.min.apply(null, samples);
        const high = Math.max.apply(null, samples);
        const newLow = 0.5 / samples.length;
        const newHigh = (samples.length - 0.5) / samples.length;
        if (high - low === 0.0) {
            samples = Array.apply(null, new Array(samples.length)).map(function () {
                return 0.5;
            });
            return {normalized_samples: samples, scale: 1.0};
        }
        const scale = (newHigh - newLow) / (high - low);
        for (let i = 0; i < samples.length; i++) {
            samples[i] = (samples[i] - low) * scale + newLow;
        }
        return {normalized_samples: samples, scale};
    };
    Statistics.discrepancy = function (samples, opt_locationCount) {
        if (samples.length === 0) return 0.0;
        let maxLocalDiscrepancy = 0;
        const invSampleCount = 1.0 / samples.length;
        const locations = [];
        const countLess = [];
        const countLessEqual = [];
        if (opt_locationCount !== undefined) {
            let sampleIndex = 0;
            for (let i = 0; i < opt_locationCount; i++) {
                const location = i / (opt_locationCount - 1);
                locations.push(location);
                while (sampleIndex < samples.length && samples[sampleIndex] < location) {
                    sampleIndex += 1;
                }
                countLess.push(sampleIndex);
                while (sampleIndex < samples.length && samples[sampleIndex] <= location) {
                    sampleIndex += 1;
                }
                countLessEqual.push(sampleIndex);
            }
        } else {
            if (samples[0] > 0.0) {
                locations.push(0.0);
                countLess.push(0);
                countLessEqual.push(0);
            }
            for (let i = 0; i < samples.length; i++) {
                locations.push(samples[i]);
                countLess.push(i);
                countLessEqual.push(i + 1);
            }
            if (samples[-1] < 1.0) {
                locations.push(1.0);
                countLess.push(samples.length);
                countLessEqual.push(samples.length);
            }
        }
        let maxDiff = 0;
        let minDiff = 0;
        for (let i = 1; i < locations.length; i++) {
            const length = locations[i] - locations[i - 1];
            const countClosed = countLessEqual[i] - countLess[i - 1];
            const countOpen = countLess[i] - countLessEqual[i - 1];
            const countClosedIncrement = countLessEqual[i] - countLessEqual[i - 1];
            const countOpenIncrement = countLess[i] - countLess[i - 1];
            maxDiff = Math.max(countClosedIncrement * invSampleCount - length + maxDiff, countClosed * invSampleCount - length);
            minDiff = Math.min(countOpenIncrement * invSampleCount - length + minDiff, countOpen * invSampleCount - length);
            maxLocalDiscrepancy = Math.max(maxDiff, -minDiff, maxLocalDiscrepancy);
        }
        return maxLocalDiscrepancy;
    };
    Statistics.timestampsDiscrepancy = function (timestamps, opt_absolute, opt_locationCount) {
        if (timestamps.length === 0) return 0.0;
        if (opt_absolute === undefined) opt_absolute = true;
        if (Array.isArray(timestamps[0])) {
            const rangeDiscrepancies = timestamps.map(function (r) {
                return Statistics.timestampsDiscrepancy(r);
            });
            return Math.max.apply(null, rangeDiscrepancies);
        }
        const s = Statistics.normalizeSamples(timestamps);
        const samples = s.normalized_samples;
        const sampleScale = s.scale;
        let discrepancy = Statistics.discrepancy(samples, opt_locationCount);
        const invSampleCount = 1.0 / samples.length;
        if (opt_absolute === true) {
            discrepancy /= sampleScale;
        } else {
            discrepancy = tr.b.math.clamp((discrepancy - invSampleCount) / (1.0 - invSampleCount), 0.0, 1.0);
        }
        return discrepancy;
    };
    Statistics.uniformlySampleArray = function (samples, count) {
        if (samples.length <= count) {
            return samples;
        }
        while (samples.length > count) {
            const i = parseInt(Math.random() * samples.length);
            samples.splice(i, 1);
        }
        return samples;
    };
    Statistics.uniformlySampleStream = function (samples, streamLength, newElement, numSamples) {
        if (streamLength <= numSamples) {
            if (samples.length >= streamLength) {
                samples[streamLength - 1] = newElement;
            } else {
                samples.push(newElement);
            }
            return;
        }
        const probToKeep = numSamples / streamLength;
        if (Math.random() > probToKeep) return;
        const index = Math.floor(Math.random() * numSamples);
        samples[index] = newElement;
    };
    Statistics.mergeSampledStreams = function (samplesA, streamLengthA, samplesB, streamLengthB, numSamples) {
        if (streamLengthB < numSamples) {
            const nbElements = Math.min(streamLengthB, samplesB.length);
            for (let i = 0; i < nbElements; ++i) {
                Statistics.uniformlySampleStream(samplesA, streamLengthA + i + 1, samplesB[i], numSamples);
            }
            return;
        }
        if (streamLengthA < numSamples) {
            const nbElements = Math.min(streamLengthA, samplesA.length);
            const tempSamples = samplesB.slice();
            for (let i = 0; i < nbElements; ++i) {
                Statistics.uniformlySampleStream(tempSamples, streamLengthB + i + 1, samplesA[i], numSamples);
            }
            for (let i = 0; i < tempSamples.length; ++i) {
                samplesA[i] = tempSamples[i];
            }
            return;
        }
        const nbElements = Math.min(numSamples, samplesB.length);
        const probOfSwapping = streamLengthB / (streamLengthA + streamLengthB);
        for (let i = 0; i < nbElements; ++i) {
            if (Math.random() < probOfSwapping) {
                samplesA[i] = samplesB[i];
            }
        }
    };

    function Distribution() {
    }

    Distribution.prototype = {
        computeDensity(x) {
            throw Error('Not implemented');
        }, computePercentile(x) {
            throw Error('Not implemented');
        }, computeComplementaryPercentile(x) {
            return 1 - this.computePercentile(x);
        }, get mean() {
            throw Error('Not implemented');
        }, get mode() {
            throw Error('Not implemented');
        }, get median() {
            throw Error('Not implemented');
        }, get standardDeviation() {
            throw Error('Not implemented');
        }, get variance() {
            throw Error('Not implemented');
        }
    };
    Statistics.UniformDistribution = function (opt_range) {
        if (!opt_range) opt_range = tr.b.math.Range.fromExplicitRange(0, 1);
        this.range = opt_range;
    };
    Statistics.UniformDistribution.prototype = {
        __proto__: Distribution.prototype, computeDensity(x) {
            return 1 / this.range.range;
        }, computePercentile(x) {
            return tr.b.math.normalize(x, this.range.min, this.range.max);
        }, get mean() {
            return this.range.center;
        }, get mode() {
            return undefined;
        }, get median() {
            return this.mean;
        }, get standardDeviation() {
            return Math.sqrt(this.variance);
        }, get variance() {
            return Math.pow(this.range.range, 2) / 12;
        }
    };
    Statistics.NormalDistribution = function (opt_mean, opt_variance) {
        this.mean_ = opt_mean || 0;
        this.variance_ = opt_variance || 1;
        this.standardDeviation_ = Math.sqrt(this.variance_);
    };
    Statistics.NormalDistribution.prototype = {
        __proto__: Distribution.prototype, computeDensity(x) {
            const scale = (1.0 / (this.standardDeviation * Math.sqrt(2.0 * Math.PI)));
            const exponent = -Math.pow(x - this.mean, 2) / (2.0 * this.variance);
            return scale * Math.exp(exponent);
        }, computePercentile(x) {
            const standardizedX = ((x - this.mean) / Math.sqrt(2.0 * this.variance));
            return (1.0 + tr.b.math.erf(standardizedX)) / 2.0;
        }, get mean() {
            return this.mean_;
        }, get median() {
            return this.mean;
        }, get mode() {
            return this.mean;
        }, get standardDeviation() {
            return this.standardDeviation_;
        }, get variance() {
            return this.variance_;
        }
    };
    Statistics.LogNormalDistribution = function (opt_location, opt_shape) {
        this.normalDistribution_ = new Statistics.NormalDistribution(opt_location, Math.pow(opt_shape || 1, 2));
    };
    Statistics.LogNormalDistribution.prototype = {
        __proto__: Statistics.NormalDistribution.prototype, computeDensity(x) {
            return this.normalDistribution_.computeDensity(Math.log(x)) / x;
        }, computePercentile(x) {
            return this.normalDistribution_.computePercentile(Math.log(x));
        }, get mean() {
            return Math.exp(this.normalDistribution_.mean +
                (this.normalDistribution_.variance / 2));
        }, get variance() {
            const nm = this.normalDistribution_.mean;
            const nv = this.normalDistribution_.variance;
            return (Math.exp(2 * (nm + nv)) -
                Math.exp(2 * nm + nv));
        }, get standardDeviation() {
            return Math.sqrt(this.variance);
        }, get median() {
            return Math.exp(this.normalDistribution_.mean);
        }, get mode() {
            return Math.exp(this.normalDistribution_.mean -
                this.normalDistribution_.variance);
        }
    };
    Statistics.LogNormalDistribution.fromMedianAndDiminishingReturns = function (median, diminishingReturns) {
        diminishingReturns = Math.log(diminishingReturns / median);
        const shape = Math.sqrt(1 - 3 * diminishingReturns -
            Math.sqrt(Math.pow(diminishingReturns - 3, 2) - 8)) / 2;
        const location = Math.log(median);
        return new Statistics.LogNormalDistribution(location, shape);
    };
    Statistics.DEFAULT_ALPHA = 0.01;
    Statistics.MAX_SUGGESTED_SAMPLE_SIZE = 20;
    Statistics.Significance = {
        SIGNIFICANT: 'REJECT',
        INSIGNIFICANT: 'FAIL_TO_REJECT',
        NEED_MORE_DATA: 'NEED_MORE_DATA',
        DONT_CARE: 'DONT_CARE',
    };

    class HypothesisTestResult {
        constructor(p, u, needMoreData, opt_alpha) {
            this.p_ = p;
            this.u_ = u;
            this.needMoreData_ = needMoreData;
            this.compare(opt_alpha);
        }

        get p() {
            return this.p_;
        }

        get U() {
            return this.u_;
        }

        get significance() {
            return this.significance_;
        }

        compare(opt_alpha) {
            const alpha = opt_alpha || Statistics.DEFAULT_ALPHA;
            if (this.p < alpha) {
                this.significance_ = Statistics.Significance.SIGNIFICANT;
            } else if (this.needMoreData_) {
                this.significance_ = Statistics.Significance.NEED_MORE_DATA;
            } else {
                this.significance_ = Statistics.Significance.INSIGNIFICANT;
            }
            return this.significance_;
        }

        asDict() {
            return {p: this.p, U: this.U, significance: this.significance,};
        }
    }

    Statistics.mwu = function (a, b, opt_alpha, opt_reqSampleSize) {
        const result = mannwhitneyu.test(a, b);
        const needMoreData = opt_reqSampleSize && Math.min(a.length, b.length) < opt_reqSampleSize;
        return new HypothesisTestResult(result.p, result.U, needMoreData, opt_alpha);
    };
    return {Statistics,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const GREEK_SMALL_LETTER_MU = String.fromCharCode(956);
    const SECONDS_IN_A_MINUTE = 60;
    const SECONDS_IN_AN_HOUR = SECONDS_IN_A_MINUTE * 60;
    const SECONDS_IN_A_DAY = SECONDS_IN_AN_HOUR * 24;
    const SECONDS_IN_A_WEEK = SECONDS_IN_A_DAY * 7;
    const SECONDS_IN_A_YEAR = SECONDS_IN_A_DAY * 365.2422;
    const SECONDS_IN_A_MONTH = SECONDS_IN_A_YEAR / 12;
    const UnitPrefixScale = {};
    const UnitScale = {};

    function defineUnitPrefixScale(name, prefixes) {
        if (UnitPrefixScale[name] !== undefined) {
            throw new Error('Unit prefix scale \'' + name + '\' already exists');
        }
        if (prefixes.AUTO !== undefined) {
            throw new Error('The \'AUTO\' unit prefix is not supported for unit' + 'prefix scales and cannot be added to scale \'' + name + '\'');
        }
        UnitPrefixScale[name] = prefixes;
    }

    UnitScale.defineUnitScale = function (name, unitScale) {
        if (UnitScale[name] !== undefined) {
            throw new Error('Unit scale \'' + name + '\' already exists');
        }
        if (unitScale.AUTO !== undefined) {
            throw new Error('\'AUTO\' unit scale will be added automatically ' + 'for unit scale \'' + name + '\'');
        }
        unitScale.AUTO = Object.values(unitScale);
        unitScale.AUTO.sort((a, b) => a.value - b.value);
        if (name) UnitScale[name] = unitScale;
        return unitScale;
    };

    function definePrefixScaleFromUnitScale(prefixName, unitScale) {
        if (!unitScale) {
            throw new Error('Cannot create PrefixScale without a unit scale.');
        }
        const prefixScale = {};
        for (const [curPrefix, curScale] of Object.entries(unitScale)) {
            if (curPrefix === 'AUTO') {
                continue;
            }
            if (curScale.symbol === undefined || !curScale.value) {
                throw new Error(`Cannot create PrefixScale from malformed unit ${curScale}.`);
            }
            prefixScale[curPrefix] = {value: curScale.value, symbol: curScale.symbol};
        }
        return defineUnitPrefixScale(prefixName, prefixScale);
    }

    UnitScale.defineUnitScaleFromPrefixScale = function (baseSymbol, baseName, prefixScale, opt_scaleName) {
        if (baseSymbol === undefined) {
            throw new Error('Cannot create UnitScale with undefined baseSymbol.');
        }
        if (!baseName) {
            throw new Error('Cannot create UnitScale without a baseName.');
        }
        if (!prefixScale) {
            throw new Error('Cannot create UnitScale without a prefix scale.');
        }
        const unitScale = {};
        for (const curPrefix of Object.keys(prefixScale)) {
            const curScale = prefixScale[curPrefix];
            if (curScale.symbol === undefined || !curScale.value) {
                throw new Error(`Cannot convert PrefixScale with malformed prefix ${curScale}.`);
            }
            const name = curPrefix === 'NONE' ? baseName : `${curPrefix}_${baseName}`;
            unitScale[name] = {value: curScale.value, symbol: curScale.symbol + baseSymbol, baseSymbol};
        }
        return UnitScale.defineUnitScale(opt_scaleName, unitScale);
    };

    function convertUnit(value, fromScale, toScale) {
        if (value === undefined) return undefined;
        const fromScaleBase = fromScale.baseSymbol;
        const toScaleBase = toScale.baseSymbol;
        if (fromScaleBase !== undefined && toScaleBase !== undefined && fromScaleBase !== toScaleBase) {
            throw new Error('Cannot convert between units with different base symbols.');
        }
        return value * (fromScale.value / toScale.value);
    }

    defineUnitPrefixScale('BINARY', {
        NONE: {value: Math.pow(1024, 0), symbol: ''},
        KIBI: {value: Math.pow(1024, 1), symbol: 'Ki'},
        MEBI: {value: Math.pow(1024, 2), symbol: 'Mi'},
        GIBI: {value: Math.pow(1024, 3), symbol: 'Gi'},
        TEBI: {value: Math.pow(1024, 4), symbol: 'Ti'}
    });
    defineUnitPrefixScale('METRIC', {
        NANO: {value: 1e-9, symbol: 'n'},
        MICRO: {value: 1e-6, symbol: GREEK_SMALL_LETTER_MU},
        MILLI: {value: 1e-3, symbol: 'm'},
        NONE: {value: 1, symbol: ''},
        KILO: {value: 1e3, symbol: 'k'},
        MEGA: {value: 1e6, symbol: 'M'},
        GIGA: {value: 1e9, symbol: 'G'}
    });
    UnitScale.defineUnitScale('TIME', {
        NANO_SEC: {value: 1e-9, symbol: 'ns', baseSymbol: 's'},
        MICRO_SEC: {value: 1e-6, symbol: GREEK_SMALL_LETTER_MU + 's', baseSymbol: 's'},
        MILLI_SEC: {value: 1e-3, symbol: 'ms', baseSymbol: 's'},
        SEC: {value: 1, symbol: 's', baseSymbol: 's'},
        MINUTE: {value: SECONDS_IN_A_MINUTE, symbol: 'min', baseSymbol: 's'},
        HOUR: {value: SECONDS_IN_AN_HOUR, symbol: 'hr', baseSymbol: 's'},
        DAY: {value: SECONDS_IN_A_DAY, symbol: 'days', baseSymbol: 's'},
        WEEK: {value: SECONDS_IN_A_WEEK, symbol: 'weeks', baseSymbol: 's'},
        MONTH: {value: SECONDS_IN_A_MONTH, symbol: 'months', baseSymbol: 's'},
        YEAR: {value: SECONDS_IN_A_YEAR, symbol: 'years', baseSymbol: 's'}
    });
    UnitScale.defineUnitScaleFromPrefixScale('B', 'BYTE', UnitPrefixScale.BINARY, 'MEMORY');
    definePrefixScaleFromUnitScale('DATA_SIZE', UnitScale.MEMORY);
    UnitScale.defineUnitScaleFromPrefixScale('/s', 'SECONDS', UnitPrefixScale.DATA_SIZE, 'BANDWIDTH_BYTES');
    return {UnitPrefixScale, UnitScale, convertUnit, GREEK_SMALL_LETTER_MU,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const msDisplayMode = {
        scale: 1e-3, suffix: 'ms', roundedLess(a, b) {
            return Math.round(a * 1000) < Math.round(b * 1000);
        }, formatSpec: {unitScale: [tr.b.UnitScale.TIME.MILLI_SEC], minimumFractionDigits: 3,}
    };
    const nsDisplayMode = {
        scale: 1e-9, suffix: 'ns', roundedLess(a, b) {
            return Math.round(a * 1000000) < Math.round(b * 1000000);
        }, formatSpec: {unitScale: [tr.b.UnitScale.TIME.NANO_SEC], maximumFractionDigits: 0}
    };
    const TimeDisplayModes = {ns: nsDisplayMode, ms: msDisplayMode};
    return {TimeDisplayModes,};
});
'use strict';
tr.exportTo('tr.ui.b', function () {
    function iterateElementDeeplyImpl(element, cb, thisArg, includeElement) {
        if (includeElement && cb.call(thisArg, element)) return true;
        if (element.root && element.root !== element && iterateElementDeeplyImpl(element.root, cb, thisArg, false)) {
            return true;
        }
        const children = Polymer.dom(element).children;
        for (let i = 0; i < children.length; i++) {
            if (iterateElementDeeplyImpl(children[i], cb, thisArg, true)) {
                return true;
            }
        }
        return false;
    }

    function iterateElementDeeply(element, cb, thisArg) {
        iterateElementDeeplyImpl(element, cb, thisArg, false);
    }

    function findDeepElementMatchingPredicate(element, predicate) {
        let foundElement = undefined;

        function matches(element) {
            const match = predicate(element);
            if (!match) {
                return false;
            }
            foundElement = element;
            return true;
        }

        iterateElementDeeply(element, matches);
        return foundElement;
    }

    function findDeepElementsMatchingPredicate(element, predicate) {
        const foundElements = [];

        function matches(element) {
            const match = predicate(element);
            if (match) {
                foundElements.push(element);
            }
            return false;
        }

        iterateElementDeeply(element, matches);
        return foundElements;
    }

    function findDeepElementMatching(element, selector) {
        return findDeepElementMatchingPredicate(element, function (element) {
            return element.matches(selector);
        });
    }

    function findDeepElementsMatching(element, selector) {
        return findDeepElementsMatchingPredicate(element, function (element) {
            return element.matches(selector);
        });
    }

    function findDeepElementWithTextContent(element, re) {
        return findDeepElementMatchingPredicate(element, function (element) {
            if (element.children.length !== 0) return false;
            return re.test(Polymer.dom(element).textContent);
        });
    }

    return {
        findDeepElementMatching,
        findDeepElementsMatching,
        findDeepElementMatchingPredicate,
        findDeepElementsMatchingPredicate,
        findDeepElementWithTextContent,
    };
});
'use strict';
tr.exportTo('tr.b', function () {
    const TimeDisplayModes = tr.b.TimeDisplayModes;
    const PLUS_MINUS_SIGN = String.fromCharCode(177);
    const CACHED_FORMATTERS = {};

    function getNumberFormatter(minSpec, maxSpec, minCtx, maxCtx) {
        const key = minSpec + '-' + maxSpec + '-' + minCtx + '-' + maxCtx;
        let formatter = CACHED_FORMATTERS[key];
        if (formatter === undefined) {
            let minimumFractionDigits = minCtx !== undefined ? minCtx : minSpec;
            let maximumFractionDigits = maxCtx !== undefined ? maxCtx : maxSpec;
            if (minimumFractionDigits > maximumFractionDigits) {
                if (minCtx !== undefined && maxCtx === undefined) {
                    maximumFractionDigits = minimumFractionDigits;
                } else if (minCtx === undefined && maxCtx !== undefined) {
                    minimumFractionDigits = maximumFractionDigits;
                }
            }
            formatter = new Intl.NumberFormat(undefined, {minimumFractionDigits, maximumFractionDigits,});
            CACHED_FORMATTERS[key] = formatter;
        }
        return formatter;
    }

    function max(a, b) {
        if (a === undefined) return b;
        if (b === undefined) return a;
        return a.scale > b.scale ? a : b;
    }

    const ImprovementDirection = {DONT_CARE: 0, BIGGER_IS_BETTER: 1, SMALLER_IS_BETTER: 2};

    function Unit(unitName, jsonName, scaleBaseUnit, isDelta, improvementDirection, formatSpec) {
        this.unitName = unitName;
        this.jsonName = jsonName;
        this.scaleBaseUnit = scaleBaseUnit;
        this.isDelta = isDelta;
        this.improvementDirection = improvementDirection;
        this.formatSpec_ = formatSpec;
        this.baseUnit = undefined;
        this.correspondingDeltaUnit = undefined;
    }

    Unit.prototype = {
        asJSON() {
            return this.jsonName;
        }, asJSON2() {
            return this.asJSON().replace('_smallerIsBetter', '-').replace('_biggerIsBetter', '+');
        }, truncate(value) {
            if (typeof value !== 'number') return value;
            if (0 === (value % 1)) return value;
            if (typeof this.formatSpec_ !== 'function' && (!this.formatSpec_.unitScale || ((this.formatSpec_.unitScale.length === 1) && (this.formatSpec_.unitScale[0].value === 1)))) {
                const digits = this.formatSpec_.maximumFractionDigits || this.formatSpec_.minimumFractionDigits;
                return tr.b.math.truncate(value, digits + 1);
            }
            const formatted = this.format(value);
            let test = Math.round(value);
            if (formatted === this.format(test)) return test;
            let lo = 1;
            let hi = 16;
            while (lo < hi - 1) {
                const digits = parseInt((lo + hi) / 2);
                test = tr.b.math.truncate(value, digits);
                if (formatted === this.format(test)) {
                    hi = digits;
                } else {
                    lo = digits;
                }
            }
            test = tr.b.math.truncate(value, lo);
            if (formatted === this.format(test)) return test;
            return tr.b.math.truncate(value, hi);
        }, getUnitScale_(opt_context) {
            let formatSpec = this.formatSpec_;
            let formatSpecWasFunction = false;
            if (typeof formatSpec === 'function') {
                formatSpecWasFunction = true;
                formatSpec = formatSpec();
            }
            const context = opt_context || {};
            let scale = undefined;
            if (context.unitScale) {
                scale = context.unitScale;
            } else if (context.unitPrefix) {
                const symbol = formatSpec.baseSymbol ? formatSpec.baseSymbol : this.scaleBaseUnit.baseSymbol;
                scale = tr.b.UnitScale.defineUnitScaleFromPrefixScale(symbol, symbol, [context.unitPrefix]).AUTO;
            } else {
                scale = formatSpec.unitScale;
                if (!scale) {
                    scale = [{
                        value: 1,
                        symbol: formatSpec.baseSymbol || '',
                        baseSymbol: formatSpec.baseSymbol || ''
                    }];
                    if (!formatSpecWasFunction) formatSpec.unitScale = scale;
                }
            }
            if (!(scale instanceof Array)) {
                throw new Error('Unit has a malformed unit scale.');
            }
            return scale;
        }, get unitString() {
            const scale = this.getUnitScale_();
            if (!scale) {
                throw new Error('A UnitScale could not be found for Unit ' + this.unitName);
            }
            return scale[0].symbol;
        }, format(value, opt_context) {
            let signString = '';
            if (value < 0) {
                signString = '-';
                value = -value;
            } else if (this.isDelta) {
                signString = value === 0 ? PLUS_MINUS_SIGN : '+';
            }
            const context = opt_context || {};
            const scale = this.getUnitScale_(context);
            let deltaValue = context.deltaValue === undefined ? value : context.deltaValue;
            deltaValue = Math.abs(deltaValue) * this.scaleBaseUnit.value;
            if (deltaValue === 0) {
                deltaValue = 1;
            }
            let i = 0;
            while (i < scale.length - 1 && deltaValue / scale[i + 1].value >= 1) {
                i++;
            }
            const selectedSubUnit = scale[i];
            let formatSpec = this.formatSpec_;
            if (typeof formatSpec === 'function') formatSpec = formatSpec();
            let unitString = '';
            if (selectedSubUnit.symbol) {
                if (!formatSpec.avoidSpacePrecedingUnit) unitString = ' ';
                unitString += selectedSubUnit.symbol;
            }
            value = tr.b.convertUnit(value, this.scaleBaseUnit, selectedSubUnit);
            const numberString = getNumberFormatter(formatSpec.minimumFractionDigits, formatSpec.maximumFractionDigits, context.minimumFractionDigits, context.maximumFractionDigits).format(value);
            return signString + numberString + unitString;
        }
    };
    Unit.reset = function () {
        Unit.currentTimeDisplayMode = TimeDisplayModes.ms;
    };
    Unit.timestampFromUs = function (us) {
        return tr.b.convertUnit(us, tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
    };
    Object.defineProperty(Unit, 'currentTimeDisplayMode', {
        get() {
            return Unit.currentTimeDisplayMode_;
        }, set(value) {
            if (Unit.currentTimeDisplayMode_ === value) return;
            Unit.currentTimeDisplayMode_ = value;
            Unit.dispatchEvent(new tr.b.Event('display-mode-changed'));
        }
    });
    Unit.didPreferredTimeDisplayUnitChange = function () {
        let largest = undefined;
        const els = tr.ui.b.findDeepElementsMatching(document.body, 'tr-v-ui-preferred-display-unit');
        els.forEach(function (el) {
            largest = max(largest, el.preferredTimeDisplayMode);
        });
        Unit.currentTimeDisplayMode = largest === undefined ? TimeDisplayModes.ms : largest;
    };
    Unit.byName = {};
    Unit.byJSONName = {};
    Unit.fromJSON = function (object) {
        if (typeof (object) === 'string') {
            if (object.endsWith('+')) {
                object = object.slice(0, object.length - 1) + '_biggerIsBetter';
            } else if (object.endsWith('-')) {
                object = object.slice(0, object.length - 1) + '_smallerIsBetter';
            }
            const u = Unit.byJSONName[object];
            if (u) return u;
        }
        throw new Error(`Unrecognized unit "${object}"`);
    };
    Unit.define = function (params) {
        const definedUnits = [];
        for (const improvementDirection of Object.values(ImprovementDirection)) {
            const regularUnit = Unit.defineUnitVariant_(params, false, improvementDirection);
            const deltaUnit = Unit.defineUnitVariant_(params, true, improvementDirection);
            regularUnit.correspondingDeltaUnit = deltaUnit;
            deltaUnit.correspondingDeltaUnit = deltaUnit;
            definedUnits.push(regularUnit, deltaUnit);
        }
        const baseUnit = Unit.byName[params.baseUnitName];
        definedUnits.forEach(u => u.baseUnit = baseUnit);
    };
    Unit.nameSuffixForImprovementDirection = function (improvementDirection) {
        switch (improvementDirection) {
            case ImprovementDirection.DONT_CARE:
                return '';
            case ImprovementDirection.BIGGER_IS_BETTER:
                return '_biggerIsBetter';
            case ImprovementDirection.SMALLER_IS_BETTER:
                return '_smallerIsBetter';
            default:
                throw new Error('Unknown improvement direction: ' + improvementDirection);
        }
    };
    Unit.defineUnitVariant_ = function (params, isDelta, improvementDirection) {
        let nameSuffix = isDelta ? 'Delta' : '';
        nameSuffix += Unit.nameSuffixForImprovementDirection(improvementDirection);
        const unitName = params.baseUnitName + nameSuffix;
        const jsonName = params.baseJsonName + nameSuffix;
        if (Unit.byName[unitName] !== undefined) {
            throw new Error('Unit \'' + unitName + '\' already exists');
        }
        if (Unit.byJSONName[jsonName] !== undefined) {
            throw new Error('JSON unit \'' + jsonName + '\' alread exists');
        }
        let scaleBaseUnit = params.scaleBaseUnit;
        if (!scaleBaseUnit) {
            let formatSpec = params.formatSpec;
            if (typeof formatSpec === 'function') formatSpec = formatSpec();
            const baseSymbol = formatSpec.unitScale ? formatSpec.unitScale[0].baseSymbol : (formatSpec.baseSymbol || '');
            scaleBaseUnit = {value: 1, symbol: baseSymbol, baseSymbol};
        }
        const unit = new Unit(unitName, jsonName, scaleBaseUnit, isDelta, improvementDirection, params.formatSpec);
        Unit.byName[unitName] = unit;
        Unit.byJSONName[jsonName] = unit;
        return unit;
    };
    tr.b.EventTarget.decorate(Unit);
    Unit.reset();
    Unit.define({
        baseUnitName: 'timeInMsAutoFormat',
        baseJsonName: 'msBestFitFormat',
        scaleBaseUnit: tr.b.UnitScale.TIME.MILLI_SEC,
        formatSpec: {unitScale: tr.b.UnitScale.TIME.AUTO, minimumFractionDigits: 0, maximumFractionDigits: 3}
    });
    Unit.define({
        baseUnitName: 'timeDurationInMs',
        baseJsonName: 'ms',
        scaleBaseUnit: tr.b.UnitScale.TIME.MILLI_SEC,
        formatSpec() {
            return Unit.currentTimeDisplayMode_.formatSpec;
        }
    });
    Unit.define({
        baseUnitName: 'timeStampInMs',
        baseJsonName: 'tsMs',
        scaleBaseUnit: tr.b.UnitScale.TIME.MILLI_SEC,
        formatSpec() {
            return Unit.currentTimeDisplayMode_.formatSpec;
        }
    });
    Unit.define({
        baseUnitName: 'normalizedPercentage',
        baseJsonName: 'n%',
        formatSpec: {
            unitScale: [{value: 0.01, symbol: '%'}],
            avoidSpacePrecedingUnit: true,
            minimumFractionDigits: 1,
            maximumFractionDigits: 1
        }
    });
    Unit.define({
        baseUnitName: 'sizeInBytes',
        baseJsonName: 'sizeInBytes',
        formatSpec: {unitScale: tr.b.UnitScale.MEMORY.AUTO, minimumFractionDigits: 1, maximumFractionDigits: 1}
    });
    Unit.define({
        baseUnitName: 'bandwidthInBytesPerSecond',
        baseJsonName: 'bytesPerSecond',
        formatSpec: {
            unitScale: tr.b.UnitScale.BANDWIDTH_BYTES.AUTO,
            minimumFractionDigits: 1,
            maximumFractionDigits: 1
        }
    });
    Unit.define({
        baseUnitName: 'energyInJoules',
        baseJsonName: 'J',
        formatSpec: {
            unitScale: tr.b.UnitScale.defineUnitScaleFromPrefixScale('J', 'JOULE', tr.b.UnitPrefixScale.METRIC, 'JOULE').AUTO,
            minimumFractionDigits: 3
        }
    });
    Unit.define({
        baseUnitName: 'powerInWatts',
        baseJsonName: 'W',
        formatSpec: {
            unitScale: tr.b.UnitScale.defineUnitScaleFromPrefixScale('W', 'WATT', tr.b.UnitPrefixScale.METRIC, 'WATT').AUTO,
            minimumFractionDigits: 3
        }
    });
    Unit.define({
        baseUnitName: 'electricCurrentInAmperes',
        baseJsonName: 'A',
        formatSpec: {
            baseSymbol: 'A',
            unitScale: tr.b.UnitScale.defineUnitScaleFromPrefixScale('A', 'AMPERE', tr.b.UnitPrefixScale.METRIC, 'AMPERE').AUTO,
            minimumFractionDigits: 3
        }
    });
    Unit.define({
        baseUnitName: 'electricPotentialInVolts',
        baseJsonName: 'V',
        formatSpec: {
            baseSymbol: 'V',
            unitScale: tr.b.UnitScale.defineUnitScaleFromPrefixScale('V', 'VOLT', tr.b.UnitPrefixScale.METRIC, 'VOLT').AUTO,
            minimumFractionDigits: 3
        }
    });
    Unit.define({
        baseUnitName: 'frequencyInHertz',
        baseJsonName: 'Hz',
        formatSpec: {
            baseSymbol: 'Hz',
            unitScale: tr.b.UnitScale.defineUnitScaleFromPrefixScale('Hz', 'HERTZ', tr.b.UnitPrefixScale.METRIC, 'HERTZ').AUTO,
            minimumFractionDigits: 3
        }
    });
    Unit.define({
        baseUnitName: 'unitlessNumber',
        baseJsonName: 'unitless',
        formatSpec: {minimumFractionDigits: 3, maximumFractionDigits: 3}
    });
    Unit.define({
        baseUnitName: 'count',
        baseJsonName: 'count',
        formatSpec: {minimumFractionDigits: 0, maximumFractionDigits: 0}
    });
    Unit.define({
        baseUnitName: 'sigma',
        baseJsonName: 'sigma',
        formatSpec: {baseSymbol: String.fromCharCode(963), minimumFractionDigits: 1, maximumFractionDigits: 1}
    });
    return {ImprovementDirection, Unit,};
});
'use strict';
tr.exportTo('tr.b', function () {
    class Scalar {
        constructor(unit, value) {
            if (!(unit instanceof tr.b.Unit)) {
                throw new Error('Expected Unit');
            }
            if (!(typeof (value) === 'number')) {
                throw new Error('Expected value to be number');
            }
            this.unit = unit;
            this.value = value;
        }

        asDict() {
            return {unit: this.unit.asJSON(), value: tr.b.numberToJson(this.value),};
        }

        toString() {
            return this.unit.format(this.value);
        }

        static fromDict(d) {
            return new Scalar(tr.b.Unit.fromJSON(d.unit), tr.b.numberFromJson(d.value));
        }
    }

    return {Scalar,};
});
'use strict';
tr.exportTo('tr.c', function () {
    function Auditor(model) {
        this.model_ = model;
    }

    Auditor.prototype = {
        __proto__: Object.prototype, get model() {
            return this.model_;
        }, runAnnotate() {
        }, installUserFriendlyCategoryDriverIfNeeded() {
        }, runAudit() {
        }
    };
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    options.defaultMetadata = {};
    options.mandatoryBaseClass = Auditor;
    tr.b.decorateExtensionRegistry(Auditor, options);
    return {Auditor,};
});
'use strict';
tr.exportTo('tr.b', function () {
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function Color(opt_r, opt_g, opt_b, opt_a) {
        this.r = Math.floor(opt_r) || 0;
        this.g = Math.floor(opt_g) || 0;
        this.b = Math.floor(opt_b) || 0;
        this.a = opt_a;
    }

    Color.fromString = function (str) {
        let tmp;
        let values;
        if (str.substr(0, 4) === 'rgb(') {
            tmp = str.substr(4, str.length - 5);
            values = tmp.split(',').map(function (v) {
                return v.replace(/^\s+/, '', 'g');
            });
            if (values.length !== 3) {
                throw new Error('Malformatted rgb-expression');
            }
            return new Color(parseInt(values[0]), parseInt(values[1]), parseInt(values[2]));
        }
        if (str.substr(0, 5) === 'rgba(') {
            tmp = str.substr(5, str.length - 6);
            values = tmp.split(',').map(function (v) {
                return v.replace(/^\s+/, '', 'g');
            });
            if (values.length !== 4) {
                throw new Error('Malformatted rgb-expression');
            }
            return new Color(parseInt(values[0]), parseInt(values[1]), parseInt(values[2]), parseFloat(values[3]));
        }
        if (str[0] === '#' && str.length === 7) {
            return new Color(parseInt(str.substr(1, 2), 16), parseInt(str.substr(3, 2), 16), parseInt(str.substr(5, 2), 16));
        }
        throw new Error('Unrecognized string format.');
    };
    Color.lerp = function (a, b, percent) {
        if (a.a !== undefined && b.a !== undefined) {
            return Color.lerpRGBA(a, b, percent);
        }
        return Color.lerpRGB(a, b, percent);
    };
    Color.lerpRGB = function (a, b, percent) {
        return new Color(((b.r - a.r) * percent) + a.r, ((b.g - a.g) * percent) + a.g, ((b.b - a.b) * percent) + a.b);
    };
    Color.lerpRGBA = function (a, b, percent) {
        return new Color(((b.r - a.r) * percent) + a.r, ((b.g - a.g) * percent) + a.g, ((b.b - a.b) * percent) + a.b, ((b.a - a.a) * percent) + a.a);
    };
    Color.fromDict = function (dict) {
        return new Color(dict.r, dict.g, dict.b, dict.a);
    };
    Color.fromHSLExplicit = function (h, s, l, a) {
        let r;
        let g;
        let b;

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        if (s === 0) {
            r = g = b = l;
        } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return new Color(Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), a);
    };
    Color.fromHSL = function (hsl) {
        return Color.fromHSLExplicit(hsl.h, hsl.s, hsl.l, hsl.a);
    };
    Color.prototype = {
        clone() {
            const c = new Color();
            c.r = this.r;
            c.g = this.g;
            c.b = this.b;
            c.a = this.a;
            return c;
        }, blendOver(bgColor) {
            const oneMinusThisAlpha = 1 - this.a;
            const outA = this.a + bgColor.a * oneMinusThisAlpha;
            const bgBlend = (bgColor.a * oneMinusThisAlpha) / bgColor.a;
            return new Color(this.r * this.a + bgColor.r * bgBlend, this.g * this.a + bgColor.g * bgBlend, this.b * this.a + bgColor.b * bgBlend, outA);
        }, brighten(opt_k) {
            const k = opt_k || 0.45;
            return new Color(Math.min(255, this.r + Math.floor(this.r * k)), Math.min(255, this.g + Math.floor(this.g * k)), Math.min(255, this.b + Math.floor(this.b * k)), this.a);
        }, lighten(k, opt_maxL) {
            const maxL = opt_maxL !== undefined ? opt_maxL : 1.0;
            const hsl = this.toHSL();
            hsl.l = Math.min(hsl.l + k, maxL);
            return Color.fromHSL(hsl);
        }, darken(opt_k) {
            let k;
            if (opt_k !== undefined) {
                k = opt_k;
            } else {
                k = 0.45;
            }
            return new Color(Math.min(255, this.r - Math.floor(this.r * k)), Math.min(255, this.g - Math.floor(this.g * k)), Math.min(255, this.b - Math.floor(this.b * k)), this.a);
        }, desaturate(opt_desaturateFactor) {
            let desaturateFactor;
            if (opt_desaturateFactor !== undefined) {
                desaturateFactor = opt_desaturateFactor;
            } else {
                desaturateFactor = 1;
            }
            const hsl = this.toHSL();
            hsl.s = clamp01(hsl.s * (1 - desaturateFactor));
            return Color.fromHSL(hsl);
        }, withAlpha(a) {
            return new Color(this.r, this.g, this.b, a);
        }, toString() {
            if (this.a !== undefined) {
                return 'rgba(' +
                    this.r + ',' + this.g + ',' +
                    this.b + ',' + this.a + ')';
            }
            return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
        }, toHSL() {
            const r = this.r / 255;
            const g = this.g / 255;
            const b = this.b / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h;
            let s;
            const l = (max + min) / 2;
            if (min === max) {
                h = 0;
                s = 0;
            } else {
                const delta = max - min;
                if (l > 0.5) {
                    s = delta / (2 - max - min);
                } else {
                    s = delta / (max + min);
                }
                if (r === max) {
                    h = (g - b) / delta;
                    if (g < b) h += 6;
                } else if (g === max) {
                    h = 2 + ((b - r) / delta);
                } else {
                    h = 4 + ((r - g) / delta);
                }
                h /= 6;
            }
            return {h, s, l, a: this.a};
        }, toStringWithAlphaOverride(alpha) {
            return 'rgba(' +
                this.r + ',' + this.g + ',' +
                this.b + ',' + alpha + ')';
        }
    };
    return {Color,};
});
'use strict';
tr.exportTo('tr.b', function () {
    function SinebowColorGenerator(opt_a, opt_brightness) {
        this.a_ = (opt_a === undefined) ? 1 : opt_a;
        this.brightness_ = (opt_brightness === undefined) ? 1 : opt_brightness;
        this.colorIndex_ = 0;
        this.keyToColor = {};
    }

    SinebowColorGenerator.prototype = {
        colorForKey(key) {
            if (!this.keyToColor[key]) {
                this.keyToColor[key] = this.nextColor();
            }
            return this.keyToColor[key];
        }, nextColor() {
            const components = SinebowColorGenerator.nthColor(this.colorIndex_++);
            return tr.b.Color.fromString(SinebowColorGenerator.calculateColor(components[0], components[1], components[2], this.a_, this.brightness_));
        }
    };
    SinebowColorGenerator.PHI = (1 + Math.sqrt(5)) / 2;
    SinebowColorGenerator.sinebow = function (h) {
        h += 0.5;
        h = -h;
        let r = Math.sin(Math.PI * h);
        let g = Math.sin(Math.PI * (h + 1 / 3));
        let b = Math.sin(Math.PI * (h + 2 / 3));
        r *= r;
        g *= g;
        b *= b;
        const y = 2 * (0.2989 * r + 0.5870 * g + 0.1140 * b);
        r /= y;
        g /= y;
        b /= y;
        return [256 * r, 256 * g, 256 * b];
    };
    SinebowColorGenerator.nthColor = function (n) {
        return SinebowColorGenerator.sinebow(n * this.PHI);
    };
    SinebowColorGenerator.calculateColor = function (r, g, b, a, brightness) {
        if (brightness <= 1) {
            r *= brightness;
            g *= brightness;
            b *= brightness;
        } else {
            r = tr.b.math.lerp(tr.b.math.normalize(brightness, 1, 2), r, 255);
            g = tr.b.math.lerp(tr.b.math.normalize(brightness, 1, 2), g, 255);
            b = tr.b.math.lerp(tr.b.math.normalize(brightness, 1, 2), b, 255);
        }
        r = Math.round(r);
        g = Math.round(g);
        b = Math.round(b);
        return 'rgba(' + r + ',' + g + ',' + b + ', ' + a + ')';
    };
    return {SinebowColorGenerator,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const numGeneralPurposeColorIds = 23;
    const generalPurposeColors = new Array(numGeneralPurposeColorIds);
    const sinebowAlpha = 1.0;
    const sinebowBrightness = 1.5;
    const sinebowColorGenerator = new tr.b.SinebowColorGenerator(sinebowAlpha, sinebowBrightness);
    for (let i = 0; i < numGeneralPurposeColorIds; i++) {
        generalPurposeColors[i] = sinebowColorGenerator.nextColor();
    }
    const reservedColorsByName = {
        thread_state_uninterruptible: new tr.b.Color(182, 125, 143),
        thread_state_iowait: new tr.b.Color(255, 140, 0),
        thread_state_running: new tr.b.Color(126, 200, 148),
        thread_state_runnable: new tr.b.Color(133, 160, 210),
        thread_state_sleeping: new tr.b.Color(240, 240, 240),
        thread_state_unknown: new tr.b.Color(199, 155, 125),
        background_memory_dump: new tr.b.Color(0, 180, 180),
        light_memory_dump: new tr.b.Color(0, 0, 180),
        detailed_memory_dump: new tr.b.Color(180, 0, 180),
        vsync_highlight_color: new tr.b.Color(0, 0, 255),
        generic_work: new tr.b.Color(125, 125, 125),
        good: new tr.b.Color(0, 125, 0),
        bad: new tr.b.Color(180, 125, 0),
        terrible: new tr.b.Color(180, 0, 0),
        black: new tr.b.Color(0, 0, 0),
        grey: new tr.b.Color(221, 221, 221),
        white: new tr.b.Color(255, 255, 255),
        yellow: new tr.b.Color(255, 255, 0),
        olive: new tr.b.Color(100, 100, 0),
        rail_response: new tr.b.Color(67, 135, 253),
        rail_animation: new tr.b.Color(244, 74, 63),
        rail_idle: new tr.b.Color(238, 142, 0),
        rail_load: new tr.b.Color(13, 168, 97),
        startup: new tr.b.Color(230, 230, 0),
        heap_dump_stack_frame: new tr.b.Color(128, 128, 128),
        heap_dump_object_type: new tr.b.Color(0, 0, 255),
        heap_dump_child_node_arrow: new tr.b.Color(204, 102, 0),
        cq_build_running: new tr.b.Color(255, 255, 119),
        cq_build_passed: new tr.b.Color(153, 238, 102),
        cq_build_failed: new tr.b.Color(238, 136, 136),
        cq_build_abandoned: new tr.b.Color(187, 187, 187),
        cq_build_attempt_runnig: new tr.b.Color(222, 222, 75),
        cq_build_attempt_passed: new tr.b.Color(103, 218, 35),
        cq_build_attempt_failed: new tr.b.Color(197, 81, 81)
    };
    const numReservedColorIds = Object.keys(reservedColorsByName).length;
    const numColorsPerVariant = numGeneralPurposeColorIds + numReservedColorIds;

    function ColorScheme() {
    }

    const paletteBase = [];
    paletteBase.push.apply(paletteBase, generalPurposeColors);
    paletteBase.push.apply(paletteBase, Object.values(reservedColorsByName));
    ColorScheme.colors = [];
    ColorScheme.properties = {};
    ColorScheme.properties = {numColorsPerVariant,};

    function pushVariant(func) {
        const variantColors = paletteBase.map(func);
        ColorScheme.colors.push.apply(ColorScheme.colors, variantColors);
    }

    pushVariant(function (c) {
        return c;
    });
    ColorScheme.properties.brightenedOffsets = [];
    ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
    pushVariant(function (c) {
        return c.lighten(0.3, 0.8);
    });
    ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
    pushVariant(function (c) {
        return c.lighten(0.48, 0.85);
    });
    ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
    pushVariant(function (c) {
        return c.lighten(0.65, 0.9);
    });
    ColorScheme.properties.dimmedOffsets = [];
    ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
    pushVariant(function (c) {
        return c.desaturate();
    });
    ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
    pushVariant(function (c) {
        return c.desaturate(0.5);
    });
    ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
    pushVariant(function (c) {
        return c.desaturate(0.3);
    });
    ColorScheme.colorsAsStrings = ColorScheme.colors.map(function (c) {
        return c.toString();
    });
    const reservedColorNameToIdMap = (function () {
        const m = new Map();
        let i = generalPurposeColors.length;
        for (const key of Object.keys(reservedColorsByName)) {
            m.set(key, i++);
        }
        return m;
    })();
    ColorScheme.getColorIdForReservedName = function (name) {
        const id = reservedColorNameToIdMap.get(name);
        if (id === undefined) {
            throw new Error('Unrecognized color ' + name);
        }
        return id;
    };
    ColorScheme.getColorForReservedNameAsString = function (reservedName) {
        const id = ColorScheme.getColorIdForReservedName(reservedName);
        return ColorScheme.colorsAsStrings[id];
    };
    ColorScheme.getStringHash = function (name) {
        let hash = 0;
        for (let i = 0; i < name.length; ++i) {
            hash = (hash + 37 * hash + 11 * name.charCodeAt(i)) % 0xFFFFFFFF;
        }
        return hash;
    };
    const stringColorIdCache = new Map();
    ColorScheme.getColorIdForGeneralPurposeString = function (string) {
        if (stringColorIdCache.get(string) === undefined) {
            const hash = ColorScheme.getStringHash(string);
            stringColorIdCache.set(string, hash % numGeneralPurposeColorIds);
        }
        return stringColorIdCache.get(string);
    };
    ColorScheme.getAnotherColorId = function (colorId, n) {
        return (colorId + n) % numColorsPerVariant;
    };
    ColorScheme.getVariantColorId = function (colorId, offset) {
        return colorId + offset;
    };
    return {ColorScheme,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ColorScheme = tr.b.ColorScheme;

    function EventInfo(title, description, docLinks) {
        this.title = title;
        this.description = description;
        this.docLinks = docLinks;
        this.colorId = ColorScheme.getColorIdForGeneralPurposeString(title);
    }

    return {EventInfo,};
});
'use strict';
tr.exportTo('tr.b', function () {
    let nextGUID = 1;
    const UUID4_PATTERN = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    const GUID = {
        allocateSimple() {
            return nextGUID++;
        }, getLastSimpleGuid() {
            return nextGUID - 1;
        }, allocateUUID4() {
            return UUID4_PATTERN.replace(/[xy]/g, function (c) {
                let r = parseInt(Math.random() * 16);
                if (c === 'y') r = (r & 3) + 8;
                return r.toString(16);
            });
        }
    };
    return {GUID,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function EventRegistry() {
    }

    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    tr.b.decorateExtensionRegistry(EventRegistry, options);
    EventRegistry.addEventListener('will-register', function (e) {
        const metadata = e.typeInfo.metadata;
        if (metadata.name === undefined) {
            throw new Error('Registered events must provide name metadata');
        }
        if (metadata.pluralName === undefined) {
            throw new Error('Registered events must provide pluralName metadata');
        }
        if (metadata.subTypes === undefined) {
            metadata.subTypes = {};
            const options = new tr.b.ExtensionRegistryOptions(tr.b.TYPE_BASED_REGISTRY_MODE);
            options.mandatoryBaseClass = e.typeInfo.constructor;
            options.defaultConstructor = e.typeInfo.constructor;
            tr.b.decorateExtensionRegistry(metadata.subTypes, options);
        } else {
            if (!metadata.subTypes.register) {
                throw new Error('metadata.subTypes must be an extension registry.');
            }
        }
        e.typeInfo.constructor.subTypes = metadata.subTypes;
    });
    let eventsByTypeName = undefined;
    EventRegistry.getEventTypeInfoByTypeName = function (typeName) {
        if (eventsByTypeName === undefined) {
            eventsByTypeName = {};
            EventRegistry.getAllRegisteredTypeInfos().forEach(function (typeInfo) {
                eventsByTypeName[typeInfo.metadata.name] = typeInfo;
            });
        }
        return eventsByTypeName[typeName];
    };
    EventRegistry.addEventListener('registry-changed', function () {
        eventsByTypeName = undefined;
    });

    function convertCamelCaseToTitleCase(name) {
        let result = name.replace(/[A-Z]/g, ' $&');
        result = result.charAt(0).toUpperCase() + result.slice(1);
        return result;
    }

    EventRegistry.getUserFriendlySingularName = function (typeName) {
        const typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
        const str = typeInfo.metadata.name;
        return convertCamelCaseToTitleCase(str);
    };
    EventRegistry.getUserFriendlyPluralName = function (typeName) {
        const typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
        const str = typeInfo.metadata.pluralName;
        return convertCamelCaseToTitleCase(str);
    };
    return {EventRegistry,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const EventRegistry = tr.model.EventRegistry;
    const RequestSelectionChangeEvent = tr.b.Event.bind(undefined, 'requestSelectionChange', true, false);

    function EventSet(opt_events) {
        this.bounds_ = new tr.b.math.Range();
        this.events_ = new Set();
        this.guid_ = tr.b.GUID.allocateSimple();
        if (opt_events) {
            if (opt_events instanceof Array) {
                for (const event of opt_events) {
                    this.push(event);
                }
            } else if (opt_events instanceof EventSet) {
                this.addEventSet(opt_events);
            } else {
                this.push(opt_events);
            }
        }
    }

    EventSet.prototype = {
        __proto__: Object.prototype, get bounds() {
            return this.bounds_;
        }, get duration() {
            if (this.bounds_.isEmpty) return 0;
            return this.bounds_.max - this.bounds_.min;
        }, get length() {
            return this.events_.size;
        }, get guid() {
            return this.guid_;
        }, * [Symbol.iterator]() {
            for (const event of this.events_) {
                yield event;
            }
        }, clear() {
            this.bounds_ = new tr.b.math.Range();
            this.events_.clear();
        }, push(...events) {
            let numPushed;
            for (const event of events) {
                if (event.guid === undefined) {
                    throw new Error('Event must have a GUID');
                }
                if (!this.events_.has(event)) {
                    this.events_.add(event);
                    if (event.addBoundsToRange) {
                        if (this.bounds_ !== undefined) {
                            event.addBoundsToRange(this.bounds_);
                        }
                    }
                }
                numPushed++;
            }
            return numPushed;
        }, contains(event) {
            if (this.events_.has(event)) return event;
            return undefined;
        }, addEventSet(eventSet) {
            for (const event of eventSet) {
                this.push(event);
            }
        }, intersectionIsEmpty(otherEventSet) {
            return !this.some(event => otherEventSet.contains(event));
        }, equals(that) {
            if (this.length !== that.length) return false;
            return this.every(event => that.contains(event));
        }, sortEvents(compare) {
            const ary = this.toArray();
            ary.sort(compare);
            this.clear();
            for (const event of ary) {
                this.push(event);
            }
        }, getEventsOrganizedByBaseType(opt_pruneEmpty) {
            const allTypeInfos = EventRegistry.getAllRegisteredTypeInfos();
            const events = this.getEventsOrganizedByCallback(function (event) {
                let maxEventIndex = -1;
                let maxEventTypeInfo = undefined;
                allTypeInfos.forEach(function (eventTypeInfo, eventIndex) {
                    if (!(event instanceof eventTypeInfo.constructor)) return;
                    if (eventIndex > maxEventIndex) {
                        maxEventIndex = eventIndex;
                        maxEventTypeInfo = eventTypeInfo;
                    }
                });
                if (maxEventIndex === -1) {
                    throw new Error(`Unrecognized event type: ${event.constructor.name}`);
                }
                return maxEventTypeInfo.metadata.name;
            });
            if (!opt_pruneEmpty) {
                allTypeInfos.forEach(function (eventTypeInfo) {
                    if (events[eventTypeInfo.metadata.name] === undefined) {
                        events[eventTypeInfo.metadata.name] = new EventSet();
                    }
                });
            }
            return events;
        }, getEventsOrganizedByTitle() {
            return this.getEventsOrganizedByCallback(function (event) {
                if (event.title === undefined) {
                    throw new Error('An event didn\'t have a title!');
                }
                return event.title;
            });
        }, getEventsOrganizedByCallback(cb, opt_this) {
            const groupedEvents = tr.b.groupIntoMap(this, cb, opt_this || this);
            const groupedEventsDict = {};
            for (const [k, events] of groupedEvents) {
                groupedEventsDict[k] = new EventSet(events);
            }
            return groupedEventsDict;
        }, enumEventsOfType(type, func) {
            for (const event of this) {
                if (event instanceof type) {
                    func(event);
                }
            }
        }, get userFriendlyName() {
            if (this.length === 0) {
                throw new Error('Empty event set');
            }
            const eventsByBaseType = this.getEventsOrganizedByBaseType(true);
            const eventTypeName = Object.keys(eventsByBaseType)[0];
            if (this.length === 1) {
                const tmp = EventRegistry.getUserFriendlySingularName(eventTypeName);
                return tr.b.getOnlyElement(this.events_).userFriendlyName;
            }
            const numEventTypes = Object.keys(eventsByBaseType).length;
            if (numEventTypes !== 1) {
                return this.length + ' events of various types';
            }
            const tmp = EventRegistry.getUserFriendlyPluralName(eventTypeName);
            return this.length + ' ' + tmp;
        }, filter(fn, opt_this) {
            const res = new EventSet();
            for (const event of this) {
                if (fn.call(opt_this, event)) {
                    res.push(event);
                }
            }
            return res;
        }, toArray() {
            const ary = [];
            for (const event of this) {
                ary.push(event);
            }
            return ary;
        }, forEach(fn, opt_this) {
            for (const event of this) {
                fn.call(opt_this, event);
            }
        }, map(fn, opt_this) {
            const res = [];
            for (const event of this) {
                res.push(fn.call(opt_this, event));
            }
            return res;
        }, every(fn, opt_this) {
            for (const event of this) {
                if (!fn.call(opt_this, event)) {
                    return false;
                }
            }
            return true;
        }, some(fn, opt_this) {
            for (const event of this) {
                if (fn.call(opt_this, event)) {
                    return true;
                }
            }
            return false;
        }, asDict() {
            const stableIds = [];
            for (const event of this) {
                stableIds.push(event.stableId);
            }
            return {'events': stableIds};
        }, asSet() {
            return this.events_;
        }
    };
    EventSet.IMMUTABLE_EMPTY_SET = (function () {
        const s = new EventSet();
        s.push = function () {
            throw new Error('Cannot push to an immutable event set');
        };
        s.addEventSet = function () {
            throw new Error('Cannot add to an immutable event set');
        };
        Object.freeze(s);
        return s;
    })();
    return {EventSet, RequestSelectionChangeEvent,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ColorScheme = tr.b.ColorScheme;
    const SelectionState = {
        NONE: 0,
        SELECTED: ColorScheme.properties.brightenedOffsets[0],
        HIGHLIGHTED: ColorScheme.properties.brightenedOffsets[1],
        DIMMED: ColorScheme.properties.dimmedOffsets[0],
        BRIGHTENED0: ColorScheme.properties.brightenedOffsets[0],
        BRIGHTENED1: ColorScheme.properties.brightenedOffsets[1],
        BRIGHTENED2: ColorScheme.properties.brightenedOffsets[2],
        DIMMED0: ColorScheme.properties.dimmedOffsets[0],
        DIMMED1: ColorScheme.properties.dimmedOffsets[1],
        DIMMED2: ColorScheme.properties.dimmedOffsets[2]
    };
    const brighteningLevels = [SelectionState.NONE, SelectionState.BRIGHTENED0, SelectionState.BRIGHTENED1, SelectionState.BRIGHTENED2];
    SelectionState.getFromBrighteningLevel = function (level) {
        return brighteningLevels[level];
    };
    const dimmingLevels = [SelectionState.DIMMED0, SelectionState.DIMMED1, SelectionState.DIMMED2];
    SelectionState.getFromDimmingLevel = function (level) {
        return dimmingLevels[level];
    };
    return {SelectionState,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const SelectionState = tr.model.SelectionState;

    function SelectableItem(modelItem) {
        this.modelItem_ = modelItem;
    }

    SelectableItem.prototype = {
        get modelItem() {
            return this.modelItem_;
        }, get selected() {
            return this.selectionState === SelectionState.SELECTED;
        }, addToSelection(selection) {
            const modelItem = this.modelItem_;
            if (!modelItem) return;
            selection.push(modelItem);
        }, addToTrackMap(eventToTrackMap, track) {
            const modelItem = this.modelItem_;
            if (!modelItem) return;
            eventToTrackMap.addEvent(modelItem, track);
        }
    };
    return {SelectableItem,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const SelectableItem = tr.model.SelectableItem;
    const SelectionState = tr.model.SelectionState;
    const IMMUTABLE_EMPTY_SET = tr.model.EventSet.IMMUTABLE_EMPTY_SET;

    function Event() {
        SelectableItem.call(this, this);
        this.guid_ = tr.b.GUID.allocateSimple();
        this.selectionState = SelectionState.NONE;
        this.info = undefined;
    }

    Event.prototype = {
        __proto__: SelectableItem.prototype, get guid() {
            return this.guid_;
        }, get stableId() {
            return undefined;
        }, get range() {
            const range = new tr.b.math.Range();
            this.addBoundsToRange(range);
            return range;
        }, associatedAlerts: IMMUTABLE_EMPTY_SET, addAssociatedAlert(alert) {
            if (this.associatedAlerts === IMMUTABLE_EMPTY_SET) {
                this.associatedAlerts = new tr.model.EventSet();
            }
            this.associatedAlerts.push(alert);
        }, addBoundsToRange(range) {
        }
    };
    return {Event,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function TimedEvent(start) {
        tr.model.Event.call(this);
        this.start = start;
        this.duration = 0;
        this.cpuStart = undefined;
        this.cpuDuration = undefined;
        this.contexts = Object.freeze([]);
    }

    TimedEvent.prototype = {
        __proto__: tr.model.Event.prototype, get end() {
            return this.start + this.duration;
        }, get boundsRange() {
            return tr.b.math.Range.fromExplicitRange(this.start, this.end);
        }, addBoundsToRange(range) {
            range.addValue(this.start);
            range.addValue(this.end);
        }, bounds(that, opt_precisionUnit) {
            if (opt_precisionUnit === undefined) {
                opt_precisionUnit = tr.b.TimeDisplayModes.ms;
            }
            const startsBefore = opt_precisionUnit.roundedLess(that.start, this.start);
            const endsAfter = opt_precisionUnit.roundedLess(this.end, that.end);
            return !startsBefore && !endsAfter;
        }
    };
    return {TimedEvent,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function Alert(info, start, opt_associatedEvents, opt_args) {
        tr.model.TimedEvent.call(this, start);
        this.info = info;
        this.args = opt_args || {};
        this.associatedEvents = new tr.model.EventSet(opt_associatedEvents);
        this.associatedEvents.forEach(function (event) {
            event.addAssociatedAlert(this);
        }, this);
    }

    Alert.prototype = {
        __proto__: tr.model.TimedEvent.prototype, get title() {
            return this.info.title;
        }, get colorId() {
            return this.info.colorId;
        }, get userFriendlyName() {
            return 'Alert ' + this.title + ' at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }
    };
    tr.model.EventRegistry.register(Alert, {name: 'alert', pluralName: 'alerts'});
    return {Alert,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Statistics = tr.b.math.Statistics;
    const FRAME_PERF_CLASS = {GOOD: 'good', BAD: 'bad', TERRIBLE: 'terrible', NEUTRAL: 'generic_work'};

    function Frame(associatedEvents, threadTimeRanges, opt_args) {
        tr.model.Event.call(this);
        this.threadTimeRanges = threadTimeRanges;
        this.associatedEvents = new tr.model.EventSet(associatedEvents);
        this.args = opt_args || {};
        this.title = 'Frame';
        this.start = Statistics.min(threadTimeRanges, function (x) {
            return x.start;
        });
        this.end = Statistics.max(threadTimeRanges, function (x) {
            return x.end;
        });
        this.totalDuration = Statistics.sum(threadTimeRanges, function (x) {
            return x.end - x.start;
        });
        this.perfClass = FRAME_PERF_CLASS.NEUTRAL;
    }

    Frame.prototype = {
        __proto__: tr.model.Event.prototype, set perfClass(perfClass) {
            this.colorId = ColorScheme.getColorIdForReservedName(perfClass);
            this.perfClass_ = perfClass;
        }, get perfClass() {
            return this.perfClass_;
        }, shiftTimestampsForward(amount) {
            this.start += amount;
            this.end += amount;
            for (let i = 0; i < this.threadTimeRanges.length; i++) {
                this.threadTimeRanges[i].start += amount;
                this.threadTimeRanges[i].end += amount;
            }
        }, addBoundsToRange(range) {
            range.addValue(this.start);
            range.addValue(this.end);
        }
    };
    tr.model.EventRegistry.register(Frame, {name: 'frame', pluralName: 'frames'});
    return {Frame, FRAME_PERF_CLASS,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const Frame = tr.model.Frame;
    const Statistics = tr.b.math.Statistics;
    const UI_DRAW_TYPE = {NONE: 'none', LEGACY: 'legacy', MARSHMALLOW: 'marshmallow'};
    const UI_THREAD_DRAW_NAMES = {
        'performTraversals': UI_DRAW_TYPE.LEGACY,
        'Choreographer#doFrame': UI_DRAW_TYPE.MARSHMALLOW
    };
    const RENDER_THREAD_DRAW_NAME = 'DrawFrame';
    const RENDER_THREAD_INDEP_DRAW_NAME = 'doFrame';
    const RENDER_THREAD_QUEUE_NAME = 'queueBuffer';
    const RENDER_THREAD_SWAP_NAME = 'eglSwapBuffers';
    const THREAD_SYNC_NAME = 'syncFrameState';

    function getSlicesForThreadTimeRanges(threadTimeRanges) {
        const ret = [];
        threadTimeRanges.forEach(function (threadTimeRange) {
            const slices = [];
            threadTimeRange.thread.sliceGroup.iterSlicesInTimeRange(function (slice) {
                slices.push(slice);
            }, threadTimeRange.start, threadTimeRange.end);
            ret.push.apply(ret, slices);
        });
        return ret;
    }

    function makeFrame(threadTimeRanges, surfaceFlinger) {
        const args = {};
        if (surfaceFlinger && surfaceFlinger.hasVsyncs) {
            const start = Statistics.min(threadTimeRanges, function (threadTimeRanges) {
                return threadTimeRanges.start;
            });
            args.deadline = surfaceFlinger.getFrameDeadline(start);
            args.frameKickoff = surfaceFlinger.getFrameKickoff(start);
        }
        const events = getSlicesForThreadTimeRanges(threadTimeRanges);
        return new Frame(events, threadTimeRanges, args);
    }

    function findOverlappingDrawFrame(renderThread, uiDrawSlice) {
        if (!renderThread) return undefined;
        let overlappingDrawFrame;
        const slices = tr.b.iterateOverIntersectingIntervals(renderThread.sliceGroup.slices, function (range) {
            return range.start;
        }, function (range) {
            return range.end;
        }, uiDrawSlice.start, uiDrawSlice.end, function (rtDrawSlice) {
            if (rtDrawSlice.title === RENDER_THREAD_DRAW_NAME) {
                const rtSyncSlice = rtDrawSlice.findDescendentSlice(THREAD_SYNC_NAME);
                if (rtSyncSlice && rtSyncSlice.start >= uiDrawSlice.start && rtSyncSlice.end <= uiDrawSlice.end) {
                    overlappingDrawFrame = rtDrawSlice;
                }
            }
        });
        return overlappingDrawFrame;
    }

    function getPreTraversalWorkRanges(uiThread) {
        if (!uiThread) return [];
        const preFrameEvents = [];
        uiThread.sliceGroup.slices.forEach(function (slice) {
            if (slice.title === 'obtainView' || slice.title === 'setupListItem' || slice.title === 'deliverInputEvent' || slice.title === 'RV Scroll') {
                preFrameEvents.push(slice);
            }
        });
        uiThread.asyncSliceGroup.slices.forEach(function (slice) {
            if (slice.title === 'deliverInputEvent') {
                preFrameEvents.push(slice);
            }
        });
        return tr.b.math.mergeRanges(tr.b.math.convertEventsToRanges(preFrameEvents), 3, function (events) {
            return {start: events[0].min, end: events[events.length - 1].max};
        });
    }

    function getFrameStartTime(traversalStart, preTraversalWorkRanges) {
        const preTraversalWorkRange = tr.b.findClosestIntervalInSortedIntervals(preTraversalWorkRanges, function (range) {
            return range.start;
        }, function (range) {
            return range.end;
        }, traversalStart, 3);
        if (preTraversalWorkRange) {
            return preTraversalWorkRange.start;
        }
        return traversalStart;
    }

    function getRtFrameEndTime(rtDrawSlice) {
        const rtQueueSlice = rtDrawSlice.findDescendentSlice(RENDER_THREAD_QUEUE_NAME);
        if (rtQueueSlice) {
            return rtQueueSlice.end;
        }
        const rtSwapSlice = rtDrawSlice.findDescendentSlice(RENDER_THREAD_SWAP_NAME);
        if (rtSwapSlice) {
            return rtSwapSlice.end;
        }
        return rtDrawSlice.end;
    }

    function getUiThreadDrivenFrames(app) {
        if (!app.uiThread) return [];
        let preTraversalWorkRanges = [];
        if (app.uiDrawType === UI_DRAW_TYPE.LEGACY) {
            preTraversalWorkRanges = getPreTraversalWorkRanges(app.uiThread);
        }
        const frames = [];
        app.uiThread.sliceGroup.slices.forEach(function (slice) {
            if (!(slice.title in UI_THREAD_DRAW_NAMES)) {
                return;
            }
            const threadTimeRanges = [];
            const uiThreadTimeRange = {
                thread: app.uiThread,
                start: getFrameStartTime(slice.start, preTraversalWorkRanges),
                end: slice.end
            };
            threadTimeRanges.push(uiThreadTimeRange);
            const rtDrawSlice = findOverlappingDrawFrame(app.renderThread, slice);
            if (rtDrawSlice) {
                const rtSyncSlice = rtDrawSlice.findDescendentSlice(THREAD_SYNC_NAME);
                if (rtSyncSlice) {
                    uiThreadTimeRange.end = Math.min(uiThreadTimeRange.end, rtSyncSlice.start);
                }
                threadTimeRanges.push({
                    thread: app.renderThread,
                    start: rtDrawSlice.start,
                    end: getRtFrameEndTime(rtDrawSlice)
                });
            }
            frames.push(makeFrame(threadTimeRanges, app.surfaceFlinger));
        });
        return frames;
    }

    function getRenderThreadDrivenFrames(app) {
        if (!app.renderThread) return [];
        const frames = [];
        app.renderThread.sliceGroup.getSlicesOfName(RENDER_THREAD_INDEP_DRAW_NAME).forEach(function (slice) {
            const threadTimeRanges = [{thread: app.renderThread, start: slice.start, end: slice.end}];
            frames.push(makeFrame(threadTimeRanges, app.surfaceFlinger));
        });
        return frames;
    }

    function getUiDrawType(uiThread) {
        if (!uiThread) {
            return UI_DRAW_TYPE.NONE;
        }
        const slices = uiThread.sliceGroup.slices;
        for (let i = 0; i < slices.length; i++) {
            if (slices[i].title in UI_THREAD_DRAW_NAMES) {
                return UI_THREAD_DRAW_NAMES[slices[i].title];
            }
        }
        return UI_DRAW_TYPE.NONE;
    }

    function getInputSamples(process) {
        let samples = undefined;
        for (const counterName in process.counters) {
            if (/^android\.aq\:pending/.test(counterName) && process.counters[counterName].numSeries === 1) {
                samples = process.counters[counterName].series[0].samples;
                break;
            }
        }
        if (!samples) return [];
        const inputSamples = [];
        let lastValue = 0;
        samples.forEach(function (sample) {
            if (sample.value > lastValue) {
                inputSamples.push(sample);
            }
            lastValue = sample.value;
        });
        return inputSamples;
    }

    function getAnimationAsyncSlices(uiThread) {
        if (!uiThread) return [];
        const slices = [];
        for (const slice of uiThread.asyncSliceGroup.getDescendantEvents()) {
            if (/^animator\:/.test(slice.title)) {
                slices.push(slice);
            }
        }
        return slices;
    }

    function AndroidApp(process, uiThread, renderThread, surfaceFlinger, uiDrawType) {
        this.process = process;
        this.uiThread = uiThread;
        this.renderThread = renderThread;
        this.surfaceFlinger = surfaceFlinger;
        this.uiDrawType = uiDrawType;
        this.frames_ = undefined;
        this.inputs_ = undefined;
    }

    AndroidApp.createForProcessIfPossible = function (process, surfaceFlinger) {
        let uiThread = process.getThread(process.pid);
        const uiDrawType = getUiDrawType(uiThread);
        if (uiDrawType === UI_DRAW_TYPE.NONE) {
            uiThread = undefined;
        }
        const renderThreads = process.findAllThreadsNamed('RenderThread');
        const renderThread = (renderThreads.length === 1 ? renderThreads[0] : undefined);
        if (uiThread || renderThread) {
            return new AndroidApp(process, uiThread, renderThread, surfaceFlinger, uiDrawType);
        }
    };
    AndroidApp.prototype = {
        getFrames() {
            if (!this.frames_) {
                const uiFrames = getUiThreadDrivenFrames(this);
                const rtFrames = getRenderThreadDrivenFrames(this);
                this.frames_ = uiFrames.concat(rtFrames);
                this.frames_.sort(function (a, b) {
                    a.end - b.end;
                });
            }
            return this.frames_;
        }, getInputSamples() {
            if (!this.inputs_) {
                this.inputs_ = getInputSamples(this.process);
            }
            return this.inputs_;
        }, getAnimationAsyncSlices() {
            if (!this.animations_) {
                this.animations_ = getAnimationAsyncSlices(this.uiThread);
            }
            return this.animations_;
        }
    };
    return {AndroidApp,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const findLowIndexInSortedArray = tr.b.findLowIndexInSortedArray;
    const VSYNC_SF_NAME = 'android.VSYNC-sf';
    const VSYNC_APP_NAME = 'android.VSYNC-app';
    const VSYNC_FALLBACK_NAME = 'android.VSYNC';
    const TIMESTAMP_FUDGE_MS = 0.01;

    function getVsyncTimestamps(process, counterName) {
        let vsync = process.counters[counterName];
        if (!vsync) {
            vsync = process.counters[VSYNC_FALLBACK_NAME];
        }
        if (vsync && vsync.numSeries === 1 && vsync.numSamples > 1) {
            return vsync.series[0].timestamps;
        }
        return undefined;
    }

    function AndroidSurfaceFlinger(process, thread) {
        this.process = process;
        this.thread = thread;
        this.appVsync_ = undefined;
        this.sfVsync_ = undefined;
        this.appVsyncTimestamps_ = getVsyncTimestamps(process, VSYNC_APP_NAME);
        this.sfVsyncTimestamps_ = getVsyncTimestamps(process, VSYNC_SF_NAME);
        this.deadlineDelayMs_ = this.appVsyncTimestamps_ !== this.sfVsyncTimestamps_ ? 5 : TIMESTAMP_FUDGE_MS;
    }

    AndroidSurfaceFlinger.createForProcessIfPossible = function (process) {
        const mainThread = process.getThread(process.pid);
        if (mainThread && mainThread.name && /surfaceflinger/.test(mainThread.name)) {
            return new AndroidSurfaceFlinger(process, mainThread);
        }
        const primaryThreads = process.findAllThreadsNamed('SurfaceFlinger');
        if (primaryThreads.length === 1) {
            return new AndroidSurfaceFlinger(process, primaryThreads[0]);
        }
        return undefined;
    };
    AndroidSurfaceFlinger.prototype = {
        get hasVsyncs() {
            return !!this.appVsyncTimestamps_ && !!this.sfVsyncTimestamps_;
        }, getFrameKickoff(timestamp) {
            if (!this.hasVsyncs) {
                throw new Error('cannot query vsync info without vsyncs');
            }
            const firstGreaterIndex = findLowIndexInSortedArray(this.appVsyncTimestamps_, function (x) {
                return x;
            }, timestamp + TIMESTAMP_FUDGE_MS);
            if (firstGreaterIndex < 1) return undefined;
            return this.appVsyncTimestamps_[firstGreaterIndex - 1];
        }, getFrameDeadline(timestamp) {
            if (!this.hasVsyncs) {
                throw new Error('cannot query vsync info without vsyncs');
            }
            const firstGreaterIndex = findLowIndexInSortedArray(this.sfVsyncTimestamps_, function (x) {
                return x;
            }, timestamp + this.deadlineDelayMs_);
            if (firstGreaterIndex >= this.sfVsyncTimestamps_.length) {
                return undefined;
            }
            return this.sfVsyncTimestamps_[firstGreaterIndex];
        }
    };
    return {AndroidSurfaceFlinger,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const AndroidApp = tr.model.helpers.AndroidApp;
    const AndroidSurfaceFlinger = tr.model.helpers.AndroidSurfaceFlinger;
    const IMPORTANT_SURFACE_FLINGER_SLICES = {
        'doComposition': true,
        'updateTexImage': true,
        'postFramebuffer': true
    };
    const IMPORTANT_UI_THREAD_SLICES = {
        'Choreographer#doFrame': true,
        'performTraversals': true,
        'deliverInputEvent': true
    };
    const IMPORTANT_RENDER_THREAD_SLICES = {'doFrame': true};

    function iterateImportantThreadSlices(thread, important, callback) {
        if (!thread) return;
        thread.sliceGroup.slices.forEach(function (slice) {
            if (slice.title in important) {
                callback(slice);
            }
        });
    }

    function AndroidModelHelper(model) {
        this.model = model;
        this.apps = [];
        this.surfaceFlinger = undefined;
        const processes = model.getAllProcesses();
        for (let i = 0; i < processes.length && !this.surfaceFlinger; i++) {
            this.surfaceFlinger = AndroidSurfaceFlinger.createForProcessIfPossible(processes[i]);
        }
        model.getAllProcesses().forEach(function (process) {
            const app = AndroidApp.createForProcessIfPossible(process, this.surfaceFlinger);
            if (app) {
                this.apps.push(app);
            }
        }, this);
    }

    AndroidModelHelper.guid = tr.b.GUID.allocateSimple();
    AndroidModelHelper.supportsModel = function (model) {
        return true;
    };
    AndroidModelHelper.prototype = {
        iterateImportantSlices(callback) {
            if (this.surfaceFlinger) {
                iterateImportantThreadSlices(this.surfaceFlinger.thread, IMPORTANT_SURFACE_FLINGER_SLICES, callback);
            }
            this.apps.forEach(function (app) {
                iterateImportantThreadSlices(app.uiThread, IMPORTANT_UI_THREAD_SLICES, callback);
                iterateImportantThreadSlices(app.renderThread, IMPORTANT_RENDER_THREAD_SLICES, callback);
            });
        }
    };
    return {AndroidModelHelper,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function Slice(category, title, colorId, start, args, opt_duration, opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId) {
        if (new.target) {
            throw new Error('Can\'t instantiate pure virtual class Slice');
        }
        tr.model.TimedEvent.call(this, start);
        this.category = category || '';
        this.title = title;
        this.colorId = colorId;
        this.args = args;
        this.startStackFrame = undefined;
        this.endStackFrame = undefined;
        this.didNotFinish = false;
        this.inFlowEvents = [];
        this.outFlowEvents = [];
        this.subSlices = [];
        this.selfTime = undefined;
        this.cpuSelfTime = undefined;
        this.important = false;
        this.parentContainer = undefined;
        this.argsStripped = false;
        this.bind_id_ = opt_bindId;
        this.parentSlice = undefined;
        this.isTopLevel = false;
        if (opt_duration !== undefined) {
            this.duration = opt_duration;
        }
        if (opt_cpuStart !== undefined) {
            this.cpuStart = opt_cpuStart;
        }
        if (opt_cpuDuration !== undefined) {
            this.cpuDuration = opt_cpuDuration;
        }
        if (opt_argsStripped !== undefined) {
            this.argsStripped = true;
        }
    }

    Slice.prototype = {
        __proto__: tr.model.TimedEvent.prototype, get analysisTypeName() {
            return this.title;
        }, get userFriendlyName() {
            return 'Slice ' + this.title + ' at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }, get stableId() {
            const parentSliceGroup = this.parentContainer.sliceGroup;
            return parentSliceGroup.stableId + '.' +
                parentSliceGroup.slices.indexOf(this);
        }, get bindId() {
            return this.bind_id_;
        }, findDescendentSlice(targetTitle) {
            if (!this.subSlices) {
                return undefined;
            }
            for (let i = 0; i < this.subSlices.length; i++) {
                if (this.subSlices[i].title === targetTitle) {
                    return this.subSlices[i];
                }
                const slice = this.subSlices[i].findDescendentSlice(targetTitle);
                if (slice) return slice;
            }
            return undefined;
        }, get mostTopLevelSlice() {
            if (!this.parentSlice) return this;
            return this.parentSlice.mostTopLevelSlice;
        }, getProcess() {
            const thread = this.parentContainer;
            if (thread && thread.getProcess) {
                return thread.getProcess();
            }
            return undefined;
        }, get model() {
            const process = this.getProcess();
            if (process !== undefined) {
                return this.getProcess().model;
            }
            return undefined;
        }, * findTopmostSlicesRelativeToThisSlice(eventPredicate) {
            if (eventPredicate(this)) {
                yield this;
                return;
            }
            for (const s of this.subSlices) {
                yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
            }
        }, iterateAllSubsequentSlices(callback, opt_this) {
            const parentStack = [];
            let started = false;
            const topmostSlice = this.mostTopLevelSlice;
            parentStack.push(topmostSlice);
            while (parentStack.length !== 0) {
                const curSlice = parentStack.pop();
                if (started) {
                    callback.call(opt_this, curSlice);
                } else {
                    started = (curSlice.guid === this.guid);
                }
                for (let i = curSlice.subSlices.length - 1; i >= 0; i--) {
                    parentStack.push(curSlice.subSlices[i]);
                }
            }
        }, get subsequentSlices() {
            const res = [];
            this.iterateAllSubsequentSlices(function (subseqSlice) {
                res.push(subseqSlice);
            });
            return res;
        }, * enumerateAllAncestors() {
            let curSlice = this.parentSlice;
            while (curSlice) {
                yield curSlice;
                curSlice = curSlice.parentSlice;
            }
        }, get ancestorSlices() {
            return Array.from(this.enumerateAllAncestors());
        }, iterateEntireHierarchy(callback, opt_this) {
            const mostTopLevelSlice = this.mostTopLevelSlice;
            callback.call(opt_this, mostTopLevelSlice);
            mostTopLevelSlice.iterateAllSubsequentSlices(callback, opt_this);
        }, get entireHierarchy() {
            const res = [];
            this.iterateEntireHierarchy(function (slice) {
                res.push(slice);
            });
            return res;
        }, get ancestorAndSubsequentSlices() {
            const res = [];
            res.push(this);
            for (const aSlice of this.enumerateAllAncestors()) {
                res.push(aSlice);
            }
            this.iterateAllSubsequentSlices(function (sSlice) {
                res.push(sSlice);
            });
            return res;
        }, * enumerateAllDescendents() {
            for (const slice of this.subSlices) {
                yield slice;
            }
            for (const slice of this.subSlices) {
                yield* slice.enumerateAllDescendents();
            }
        }, get descendentSlices() {
            const res = [];
            for (const slice of this.enumerateAllDescendents()) {
                res.push(slice);
            }
            return res;
        }
    };
    return {Slice,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Slice = tr.model.Slice;
    const SCHEDULING_STATE = {
        DEBUG: 'Debug',
        EXIT_DEAD: 'Exit Dead',
        RUNNABLE: 'Runnable',
        RUNNING: 'Running',
        SLEEPING: 'Sleeping',
        STOPPED: 'Stopped',
        TASK_DEAD: 'Task Dead',
        UNINTR_SLEEP: 'Uninterruptible Sleep',
        UNINTR_SLEEP_WAKE_KILL: 'Uninterruptible Sleep | WakeKill',
        UNINTR_SLEEP_WAKING: 'Uninterruptible Sleep | Waking',
        UNINTR_SLEEP_IO: 'Uninterruptible Sleep - Block I/O',
        UNINTR_SLEEP_WAKE_KILL_IO: 'Uninterruptible Sleep | WakeKill - Block I/O',
        UNINTR_SLEEP_WAKING_IO: 'Uninterruptible Sleep | Waking - Block I/O',
        UNKNOWN: 'UNKNOWN',
        WAKE_KILL: 'Wakekill',
        WAKING: 'Waking',
        ZOMBIE: 'Zombie'
    };

    function ThreadTimeSlice(thread, schedulingState, cat, start, args, opt_duration) {
        Slice.call(this, cat, schedulingState, this.getColorForState_(schedulingState), start, args, opt_duration);
        this.thread = thread;
        this.schedulingState = schedulingState;
        this.cpuOnWhichThreadWasRunning = undefined;
    }

    ThreadTimeSlice.prototype = {
        __proto__: Slice.prototype, getColorForState_(state) {
            const getColorIdForReservedName = tr.b.ColorScheme.getColorIdForReservedName;
            switch (state) {
                case SCHEDULING_STATE.RUNNABLE:
                    return getColorIdForReservedName('thread_state_runnable');
                case SCHEDULING_STATE.RUNNING:
                    return getColorIdForReservedName('thread_state_running');
                case SCHEDULING_STATE.SLEEPING:
                    return getColorIdForReservedName('thread_state_sleeping');
                case SCHEDULING_STATE.DEBUG:
                case SCHEDULING_STATE.EXIT_DEAD:
                case SCHEDULING_STATE.STOPPED:
                case SCHEDULING_STATE.TASK_DEAD:
                case SCHEDULING_STATE.UNINTR_SLEEP:
                case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:
                case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:
                case SCHEDULING_STATE.UNKNOWN:
                case SCHEDULING_STATE.WAKE_KILL:
                case SCHEDULING_STATE.WAKING:
                case SCHEDULING_STATE.ZOMBIE:
                    return getColorIdForReservedName('thread_state_uninterruptible');
                case SCHEDULING_STATE.UNINTR_SLEEP_IO:
                case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO:
                case SCHEDULING_STATE.UNINTR_SLEEP_WAKING_IO:
                    return getColorIdForReservedName('thread_state_iowait');
                default:
                    return getColorIdForReservedName('thread_state_unknown');
            }
        }, get analysisTypeName() {
            return 'tr.ui.analysis.ThreadTimeSlice';
        }, getAssociatedCpuSlice() {
            if (!this.cpuOnWhichThreadWasRunning) return undefined;
            const cpuSlices = this.cpuOnWhichThreadWasRunning.slices;
            for (let i = 0; i < cpuSlices.length; i++) {
                const cpuSlice = cpuSlices[i];
                if (cpuSlice.start !== this.start) continue;
                if (cpuSlice.duration !== this.duration) continue;
                return cpuSlice;
            }
            return undefined;
        }, getCpuSliceThatTookCpu() {
            if (this.cpuOnWhichThreadWasRunning) return undefined;
            let curIndex = this.thread.indexOfTimeSlice(this);
            let cpuSliceWhenLastRunning;
            while (curIndex >= 0) {
                const curSlice = this.thread.timeSlices[curIndex];
                if (!curSlice.cpuOnWhichThreadWasRunning) {
                    curIndex--;
                    continue;
                }
                cpuSliceWhenLastRunning = curSlice.getAssociatedCpuSlice();
                break;
            }
            if (!cpuSliceWhenLastRunning) return undefined;
            const cpu = cpuSliceWhenLastRunning.cpu;
            const indexOfSliceOnCpuWhenLastRunning = cpu.indexOf(cpuSliceWhenLastRunning);
            const nextRunningSlice = cpu.slices[indexOfSliceOnCpuWhenLastRunning + 1];
            if (!nextRunningSlice) return undefined;
            if (Math.abs(nextRunningSlice.start - cpuSliceWhenLastRunning.end) < 0.00001) {
                return nextRunningSlice;
            }
            return undefined;
        }
    };
    tr.model.EventRegistry.register(ThreadTimeSlice, {name: 'threadTimeSlice', pluralName: 'threadTimeSlices'});
    return {ThreadTimeSlice, SCHEDULING_STATE,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const CompoundEventSelectionState = {
        NOT_SELECTED: 0,
        EVENT_SELECTED: 0x1,
        SOME_ASSOCIATED_EVENTS_SELECTED: 0x2,
        ALL_ASSOCIATED_EVENTS_SELECTED: 0x4,
        EVENT_AND_SOME_ASSOCIATED_SELECTED: 0x1 | 0x2,
        EVENT_AND_ALL_ASSOCIATED_SELECTED: 0x1 | 0x4
    };
    return {CompoundEventSelectionState,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    const CompoundEventSelectionState = tr.model.CompoundEventSelectionState;

    function UserExpectation(parentModel, initiatorType, start, duration) {
        tr.model.TimedEvent.call(this, start);
        this.associatedEvents = new tr.model.EventSet();
        this.duration = duration;
        this.initiatorType_ = initiatorType;
        this.parentModel = parentModel;
        this.typeInfo_ = undefined;
        this.sourceEvents = new tr.model.EventSet();
    }

    const INITIATOR_TYPE = {
        KEYBOARD: 'Keyboard',
        MOUSE: 'Mouse',
        MOUSE_WHEEL: 'MouseWheel',
        TAP: 'Tap',
        PINCH: 'Pinch',
        FLING: 'Fling',
        TOUCH: 'Touch',
        SCROLL: 'Scroll',
        CSS: 'CSS',
        WEBGL: 'WebGL',
        VIDEO: 'Video',
        VR: 'VR',
    };
    UserExpectation.prototype = {
        __proto__: tr.model.TimedEvent.prototype, computeCompoundEvenSelectionState(selection) {
            let cess = CompoundEventSelectionState.NOT_SELECTED;
            if (selection.contains(this)) {
                cess |= CompoundEventSelectionState.EVENT_SELECTED;
            }
            if (this.associatedEvents.intersectionIsEmpty(selection)) {
                return cess;
            }
            const allContained = this.associatedEvents.every(function (event) {
                return selection.contains(event);
            });
            if (allContained) {
                cess |= CompoundEventSelectionState.ALL_ASSOCIATED_EVENTS_SELECTED;
            } else {
                cess |= CompoundEventSelectionState.SOME_ASSOCIATED_EVENTS_SELECTED;
            }
            return cess;
        }, get associatedSamples() {
            const samples = new tr.model.EventSet();
            this.associatedEvents.forEach(function (event) {
                if (event instanceof tr.model.ThreadSlice) {
                    samples.addEventSet(event.overlappingSamples);
                }
            });
            return samples;
        }, get userFriendlyName() {
            return this.title + ' User Expectation at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }, get stableId() {
            return ('UserExpectation.' + this.guid);
        }, get typeInfo() {
            if (!this.typeInfo_) {
                this.typeInfo_ = UserExpectation.subTypes.findTypeInfo(this.constructor);
            }
            if (!this.typeInfo_) {
                throw new Error('Unregistered UserExpectation');
            }
            return this.typeInfo_;
        }, get colorId() {
            return this.typeInfo.metadata.colorId;
        }, get stageTitle() {
            return this.typeInfo.metadata.stageTitle;
        }, get initiatorType() {
            return this.initiatorType_;
        }, get title() {
            if (!this.initiatorType) {
                return this.stageTitle;
            }
            return this.initiatorType + ' ' + this.stageTitle;
        }, get totalCpuMs() {
            let cpuMs = 0;
            this.associatedEvents.forEach(function (event) {
                if (event.cpuSelfTime) {
                    cpuMs += event.cpuSelfTime;
                }
            });
            return cpuMs;
        }
    };
    const subTypes = {};
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    tr.b.decorateExtensionRegistry(subTypes, options);
    subTypes.addEventListener('will-register', function (e) {
        const metadata = e.typeInfo.metadata;
        if (metadata.stageTitle === undefined) {
            throw new Error('Registered UserExpectations must provide ' + 'stageTitle');
        }
        if (metadata.colorId === undefined) {
            throw new Error('Registered UserExpectations must provide ' + 'colorId');
        }
    });
    tr.model.EventRegistry.register(UserExpectation, {
        name: 'userExpectation',
        pluralName: 'userExpectations',
        subTypes
    });
    return {UserExpectation, INITIATOR_TYPE,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    function ResponseExpectation(parentModel, initiatorTitle, start, duration, opt_isAnimationBegin) {
        tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
        this.isAnimationBegin = opt_isAnimationBegin || false;
    }

    ResponseExpectation.prototype = {
        __proto__: tr.model.um.UserExpectation.prototype,
        constructor: ResponseExpectation
    };
    tr.model.um.UserExpectation.subTypes.register(ResponseExpectation, {
        stageTitle: 'Response',
        colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_response')
    });
    return {ResponseExpectation,};
});
'use strict';
tr.exportTo('tr.e.audits', function () {
    const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
    const Auditor = tr.c.Auditor;
    const AndroidModelHelper = tr.model.helpers.AndroidModelHelper;
    const ColorScheme = tr.b.ColorScheme;
    const Statistics = tr.b.math.Statistics;
    const FRAME_PERF_CLASS = tr.model.FRAME_PERF_CLASS;
    const Alert = tr.model.Alert;
    const EventInfo = tr.model.EventInfo;
    const Scalar = tr.b.Scalar;
    const timeDurationInMs = tr.b.Unit.byName.timeDurationInMs;
    const EXPECTED_FRAME_TIME_MS = 16.67;

    function getStart(e) {
        return e.start;
    }

    function getDuration(e) {
        return e.duration;
    }

    function getCpuDuration(e) {
        return (e.cpuDuration !== undefined) ? e.cpuDuration : e.duration;
    }

    function frameIsActivityStart(frame) {
        return frame.associatedEvents.any(x => x.title === 'activityStart');
    }

    function frameMissedDeadline(frame) {
        return frame.args.deadline && frame.args.deadline < frame.end;
    }

    function DocLinkBuilder() {
        this.docLinks = [];
    }

    DocLinkBuilder.prototype = {
        addAppVideo(name, videoId) {
            this.docLinks.push({
                label: 'Video Link',
                textContent: ('Android Performance Patterns: ' + name),
                href: 'https://www.youtube.com/watch?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&v=' + videoId
            });
            return this;
        }, addDacRef(name, link) {
            this.docLinks.push({
                label: 'Doc Link',
                textContent: (name + ' documentation'),
                href: 'https://developer.android.com/reference/' + link
            });
            return this;
        }, build() {
            return this.docLinks;
        }
    };

    function AndroidAuditor(model) {
        Auditor.call(this, model);
        const helper = model.getOrCreateHelper(AndroidModelHelper);
        if (helper.apps.length || helper.surfaceFlinger) {
            this.helper = helper;
        }
    }

    AndroidAuditor.viewAlphaAlertInfo_ = new EventInfo('Inefficient View alpha usage', 'Setting an alpha between 0 and 1 has significant performance costs, if one of the fast alpha paths is not used.', new DocLinkBuilder().addAppVideo('Hidden Cost of Transparency', 'wIy8g8yNhNk').addDacRef('View#setAlpha()', 'android/view/View.html#setAlpha(float)').build());
    AndroidAuditor.saveLayerAlertInfo_ = new EventInfo('Expensive rendering with Canvas#saveLayer()', 'Canvas#saveLayer() incurs extremely high rendering cost. They disrupt the rendering pipeline when drawn, forcing a flush of drawing content. Instead use View hardware layers, or static Bitmaps. This enables the offscreen buffers to be reused in between frames, and avoids the disruptive render target switch.', new DocLinkBuilder().addAppVideo('Hidden Cost of Transparency', 'wIy8g8yNhNk').addDacRef('Canvas#saveLayerAlpha()', 'android/graphics/Canvas.html#saveLayerAlpha(android.graphics.RectF, int, int)').build());
    AndroidAuditor.getSaveLayerAlerts_ = function (frame) {
        const badAlphaRegEx = /^(.+) alpha caused (unclipped )?saveLayer (\d+)x(\d+)$/;
        const saveLayerRegEx = /^(unclipped )?saveLayer (\d+)x(\d+)$/;
        const ret = [];
        const events = [];
        frame.associatedEvents.forEach(function (slice) {
            const match = badAlphaRegEx.exec(slice.title);
            if (match) {
                const args = {'view name': match[1], 'width': parseInt(match[3]), 'height': parseInt(match[4])};
                ret.push(new Alert(AndroidAuditor.viewAlphaAlertInfo_, slice.start, [slice], args));
            } else if (saveLayerRegEx.test(slice.title)) {
                events.push(slice);
            }
        }, this);
        if (events.length > ret.length) {
            const unclippedSeen = Statistics.sum(events, function (slice) {
                return saveLayerRegEx.exec(slice.title)[1] ? 1 : 0;
            });
            const clippedSeen = events.length - unclippedSeen;
            const earliestStart = Statistics.min(events, function (slice) {
                return slice.start;
            });
            const args = {
                'Unclipped saveLayer count (especially bad!)': unclippedSeen,
                'Clipped saveLayer count': clippedSeen
            };
            events.push(frame);
            ret.push(new Alert(AndroidAuditor.saveLayerAlertInfo_, earliestStart, events, args));
        }
        return ret;
    };
    AndroidAuditor.pathAlertInfo_ = new EventInfo('Path texture churn', 'Paths are drawn with a mask texture, so when a path is modified / newly drawn, that texture must be generated and uploaded to the GPU. Ensure that you cache paths between frames and do not unnecessarily call Path#reset(). You can cut down on this cost by sharing Path object instances between drawables/views.');
    AndroidAuditor.getPathAlert_ = function (frame) {
        const uploadRegEx = /^Generate Path Texture$/;
        const events = frame.associatedEvents.filter(function (event) {
            return event.title === 'Generate Path Texture';
        });
        const start = Statistics.min(events, getStart);
        const duration = Statistics.sum(events, getDuration);
        if (duration < 3) return undefined;
        events.push(frame);
        return new Alert(AndroidAuditor.pathAlertInfo_, start, events, {'Time spent': new Scalar(timeDurationInMs, duration)});
    };
    AndroidAuditor.uploadAlertInfo_ = new EventInfo('Expensive Bitmap uploads', 'Bitmaps that have been modified / newly drawn must be uploaded to the GPU. Since this is expensive if the total number of pixels uploaded is large, reduce the amount of Bitmap churn in this animation/context, per frame.');
    AndroidAuditor.getUploadAlert_ = function (frame) {
        const uploadRegEx = /^Upload (\d+)x(\d+) Texture$/;
        const events = [];
        let start = Number.POSITIVE_INFINITY;
        let duration = 0;
        let pixelsUploaded = 0;
        frame.associatedEvents.forEach(function (event) {
            const match = uploadRegEx.exec(event.title);
            if (match) {
                events.push(event);
                start = Math.min(start, event.start);
                duration += event.duration;
                pixelsUploaded += parseInt(match[1]) * parseInt(match[2]);
            }
        });
        if (events.length === 0 || duration < 3) return undefined;
        const mPixels = (pixelsUploaded / 1000000).toFixed(2) + ' million';
        const args = {'Pixels uploaded': mPixels, 'Time spent': new Scalar(timeDurationInMs, duration)};
        events.push(frame);
        return new Alert(AndroidAuditor.uploadAlertInfo_, start, events, args);
    };
    AndroidAuditor.ListViewInflateAlertInfo_ = new EventInfo('Inflation during ListView recycling', 'ListView item recycling involved inflating views. Ensure your Adapter#getView() recycles the incoming View, instead of constructing a new one.');
    AndroidAuditor.ListViewBindAlertInfo_ = new EventInfo('Inefficient ListView recycling/rebinding', 'ListView recycling taking too much time per frame. Ensure your Adapter#getView() binds data efficiently.');
    AndroidAuditor.getListViewAlert_ = function (frame) {
        const events = frame.associatedEvents.filter(function (event) {
            return event.title === 'obtainView' || event.title === 'setupListItem';
        });
        const duration = Statistics.sum(events, getCpuDuration);
        if (events.length === 0 || duration < 3) return undefined;
        let hasInflation = false;
        for (const event of events) {
            if (event.findDescendentSlice('inflate')) {
                hasInflation = true;
            }
        }
        const start = Statistics.min(events, getStart);
        const args = {'Time spent': new Scalar(timeDurationInMs, duration)};
        args['ListView items ' + (hasInflation ? 'inflated' : 'rebound')] = events.length / 2;
        const eventInfo = hasInflation ? AndroidAuditor.ListViewInflateAlertInfo_ : AndroidAuditor.ListViewBindAlertInfo_;
        events.push(frame);
        return new Alert(eventInfo, start, events, args);
    };
    AndroidAuditor.measureLayoutAlertInfo_ = new EventInfo('Expensive measure/layout pass', 'Measure/Layout took a significant time, contributing to jank. Avoid triggering layout during animations.', new DocLinkBuilder().addAppVideo('Invalidations, Layouts, and Performance', 'we6poP0kw6E').build());
    AndroidAuditor.getMeasureLayoutAlert_ = function (frame) {
        const events = frame.associatedEvents.filter(function (event) {
            return event.title === 'measure' || event.title === 'layout';
        });
        const duration = Statistics.sum(events, getCpuDuration);
        if (events.length === 0 || duration < 3) return undefined;
        const start = Statistics.min(events, getStart);
        events.push(frame);
        return new Alert(AndroidAuditor.measureLayoutAlertInfo_, start, events, {'Time spent': new Scalar(timeDurationInMs, duration)});
    };
    AndroidAuditor.viewDrawAlertInfo_ = new EventInfo('Long View#draw()', 'Recording the drawing commands of invalidated Views took a long time. Avoid significant work in View or Drawable custom drawing, especially allocations or drawing to Bitmaps.', new DocLinkBuilder().addAppVideo('Invalidations, Layouts, and Performance', 'we6poP0kw6E').addAppVideo('Avoiding Allocations in onDraw()', 'HAK5acHQ53E').build());
    AndroidAuditor.getViewDrawAlert_ = function (frame) {
        let slice = undefined;
        for (const event of frame.associatedEvents) {
            if (event.title === 'getDisplayList' || event.title === 'Record View#draw()') {
                slice = event;
                break;
            }
        }
        if (!slice || getCpuDuration(slice) < 3) return undefined;
        return new Alert(AndroidAuditor.viewDrawAlertInfo_, slice.start, [slice, frame], {'Time spent': new Scalar(timeDurationInMs, getCpuDuration(slice))});
    };
    AndroidAuditor.blockingGcAlertInfo_ = new EventInfo('Blocking Garbage Collection', 'Blocking GCs are caused by object churn, and made worse by having large numbers of objects in the heap. Avoid allocating objects during animations/scrolling, and recycle Bitmaps to avoid triggering garbage collection.', new DocLinkBuilder().addAppVideo('Garbage Collection in Android', 'pzfzz50W5Uo').addAppVideo('Avoiding Allocations in onDraw()', 'HAK5acHQ53E').build());
    AndroidAuditor.getBlockingGcAlert_ = function (frame) {
        const events = frame.associatedEvents.filter(function (event) {
            return event.title === 'DVM Suspend' || event.title === 'GC: Wait For Concurrent';
        });
        const blockedDuration = Statistics.sum(events, getDuration);
        if (blockedDuration < 3) return undefined;
        const start = Statistics.min(events, getStart);
        events.push(frame);
        return new Alert(AndroidAuditor.blockingGcAlertInfo_, start, events, {'Blocked duration': new Scalar(timeDurationInMs, blockedDuration)});
    };
    AndroidAuditor.lockContentionAlertInfo_ = new EventInfo('Lock contention', 'UI thread lock contention is caused when another thread holds a lock that the UI thread is trying to use. UI thread progress is blocked until the lock is released. Inspect locking done within the UI thread, and ensure critical sections are short.');
    AndroidAuditor.getLockContentionAlert_ = function (frame) {
        const events = frame.associatedEvents.filter(function (event) {
            return /^Lock Contention on /.test(event.title);
        });
        const blockedDuration = Statistics.sum(events, getDuration);
        if (blockedDuration < 1) return undefined;
        const start = Statistics.min(events, getStart);
        events.push(frame);
        return new Alert(AndroidAuditor.lockContentionAlertInfo_, start, events, {'Blocked duration': new Scalar(timeDurationInMs, blockedDuration)});
    };
    AndroidAuditor.schedulingAlertInfo_ = new EventInfo('Scheduling delay', 'Work to produce this frame was descheduled for several milliseconds, contributing to jank. Ensure that code on the UI thread doesn\'t block on work being done on other threads, and that background threads (doing e.g. network or bitmap loading) are running at android.os.Process#THREAD_PRIORITY_BACKGROUND or lower so they are less likely to interrupt the UI thread. These background threads should show up with a priority number of 130 or higher in the scheduling section under the Kernel process.');
    AndroidAuditor.getSchedulingAlert_ = function (frame) {
        let totalDuration = 0;
        const totalStats = {};
        for (const ttr of frame.threadTimeRanges) {
            const stats = ttr.thread.getSchedulingStatsForRange(ttr.start, ttr.end);
            for (const [key, value] of Object.entries(stats)) {
                if (!(key in totalStats)) {
                    totalStats[key] = 0;
                }
                totalStats[key] += value;
                totalDuration += value;
            }
        }
        if (!(SCHEDULING_STATE.RUNNING in totalStats) || totalDuration === 0 || totalDuration - totalStats[SCHEDULING_STATE.RUNNING] < 3) {
            return;
        }
        const args = {};
        for (const [key, value] of Object.entries(totalStats)) {
            let newKey = key;
            if (key === SCHEDULING_STATE.RUNNABLE) {
                newKey = 'Not scheduled, but runnable';
            } else if (key === SCHEDULING_STATE.UNINTR_SLEEP) {
                newKey = 'Blocking I/O delay';
            }
            args[newKey] = new Scalar(timeDurationInMs, value);
        }
        return new Alert(AndroidAuditor.schedulingAlertInfo_, frame.start, [frame], args);
    };
    AndroidAuditor.prototype = {
        __proto__: Auditor.prototype, renameAndSort_() {
            this.model.kernel.important = false;
            this.model.getAllProcesses().forEach(function (process) {
                if (this.helper.surfaceFlinger && process === this.helper.surfaceFlinger.process) {
                    if (!process.name) {
                        process.name = 'SurfaceFlinger';
                    }
                    process.sortIndex = Number.NEGATIVE_INFINITY;
                    process.important = false;
                    return;
                }
                const uiThread = process.getThread(process.pid);
                if (!process.name && uiThread && uiThread.name) {
                    if (/^ndroid\./.test(uiThread.name)) {
                        uiThread.name = 'a' + uiThread.name;
                    }
                    process.name = uiThread.name;
                    uiThread.name = 'UI Thread';
                }
                process.sortIndex = 0;
                for (const tid in process.threads) {
                    process.sortIndex -= process.threads[tid].sliceGroup.slices.length;
                }
            }, this);
            this.model.getAllThreads().forEach(function (thread) {
                if (thread.tid === thread.parent.pid) {
                    thread.sortIndex = -3;
                }
                if (thread.name === 'RenderThread') {
                    thread.sortIndex = -2;
                }
                if (/^hwuiTask/.test(thread.name)) {
                    thread.sortIndex = -1;
                }
            });
        }, pushFramesAndJudgeJank_() {
            let badFramesObserved = 0;
            let framesObserved = 0;
            const surfaceFlinger = this.helper.surfaceFlinger;
            this.helper.apps.forEach(function (app) {
                app.process.frames = app.getFrames();
                app.process.frames.forEach(function (frame) {
                    if (frame.totalDuration > EXPECTED_FRAME_TIME_MS * 2) {
                        badFramesObserved += 2;
                        frame.perfClass = FRAME_PERF_CLASS.TERRIBLE;
                    } else if (frame.totalDuration > EXPECTED_FRAME_TIME_MS || frameMissedDeadline(frame)) {
                        badFramesObserved++;
                        frame.perfClass = FRAME_PERF_CLASS.BAD;
                    } else {
                        frame.perfClass = FRAME_PERF_CLASS.GOOD;
                    }
                });
                framesObserved += app.process.frames.length;
            });
            if (framesObserved) {
                const portionBad = badFramesObserved / framesObserved;
                if (portionBad > 0.3) {
                    this.model.faviconHue = 'red';
                } else if (portionBad > 0.05) {
                    this.model.faviconHue = 'yellow';
                } else {
                    this.model.faviconHue = 'green';
                }
            }
        }, pushEventInfo_() {
            const appAnnotator = new AppAnnotator();
            this.helper.apps.forEach(function (app) {
                if (app.uiThread) {
                    appAnnotator.applyEventInfos(app.uiThread.sliceGroup);
                }
                if (app.renderThread) {
                    appAnnotator.applyEventInfos(app.renderThread.sliceGroup);
                }
            });
        }, runAnnotate() {
            if (!this.helper) return;
            this.renameAndSort_();
            this.pushFramesAndJudgeJank_();
            this.pushEventInfo_();
            this.helper.iterateImportantSlices(function (slice) {
                slice.important = true;
            });
        }, runAudit() {
            if (!this.helper) return;
            const alerts = this.model.alerts;
            this.helper.apps.forEach(function (app) {
                app.getFrames().forEach(function (frame) {
                    alerts.push.apply(alerts, AndroidAuditor.getSaveLayerAlerts_(frame));
                    if (frame.perfClass === FRAME_PERF_CLASS.NEUTRAL || frame.perfClass === FRAME_PERF_CLASS.GOOD) {
                        return;
                    }
                    let alert = AndroidAuditor.getPathAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getUploadAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getListViewAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getMeasureLayoutAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getViewDrawAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getBlockingGcAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getLockContentionAlert_(frame);
                    if (alert) alerts.push(alert);
                    alert = AndroidAuditor.getSchedulingAlert_(frame);
                    if (alert) alerts.push(alert);
                });
            }, this);
            this.addRenderingInteractionRecords();
            this.addInputInteractionRecords();
        }, addRenderingInteractionRecords() {
            const events = [];
            this.helper.apps.forEach(function (app) {
                events.push.apply(events, app.getAnimationAsyncSlices());
                events.push.apply(events, app.getFrames());
            });
            const mergerFunction = function (events) {
                const ir = new tr.model.um.ResponseExpectation(this.model, 'Rendering', events[0].min, events[events.length - 1].max - events[0].min);
                this.model.userModel.expectations.push(ir);
            }.bind(this);
            tr.b.math.mergeRanges(tr.b.math.convertEventsToRanges(events), 30, mergerFunction);
        }, addInputInteractionRecords() {
            const inputSamples = [];
            this.helper.apps.forEach(function (app) {
                inputSamples.push.apply(inputSamples, app.getInputSamples());
            });
            const mergerFunction = function (events) {
                const ir = new tr.model.um.ResponseExpectation(this.model, 'Input', events[0].min, events[events.length - 1].max - events[0].min);
                this.model.userModel.expectations.push(ir);
            }.bind(this);
            const inputRanges = inputSamples.map(function (sample) {
                return tr.b.math.Range.fromExplicitRange(sample.timestamp, sample.timestamp);
            });
            tr.b.math.mergeRanges(inputRanges, 30, mergerFunction);
        }
    };
    Auditor.register(AndroidAuditor);

    function AppAnnotator() {
        this.titleInfoLookup = new Map();
        this.titleParentLookup = new Map();
        this.build_();
    }

    AppAnnotator.prototype = {
        build_() {
            const registerEventInfo = function (dict) {
                this.titleInfoLookup.set(dict.title, new EventInfo(dict.title, dict.description, dict.docLinks));
                if (dict.parents) {
                    this.titleParentLookup.set(dict.title, dict.parents);
                }
            }.bind(this);
            registerEventInfo({
                title: 'inflate',
                description: 'Constructing a View hierarchy from pre-processed XML via LayoutInflater#layout. This includes constructing all of the View objects in the hierarchy, and applying styled attributes.'
            });
            registerEventInfo({
                title: 'obtainView',
                description: 'Adapter#getView() called to bind content to a recycled View that is being presented.'
            });
            registerEventInfo({
                title: 'setupListItem',
                description: 'Attached a newly-bound, recycled View to its parent ListView.'
            });
            registerEventInfo({
                title: 'setupGridItem',
                description: 'Attached a newly-bound, recycled View to its parent GridView.'
            });
            const choreographerLinks = new DocLinkBuilder().addDacRef('Choreographer', 'android/view/Choreographer.html').build();
            registerEventInfo({
                title: 'Choreographer#doFrame',
                docLinks: choreographerLinks,
                description: 'Choreographer executes frame callbacks for inputs, animations, and rendering traversals. When this work is done, a frame will be presented to the user.'
            });
            registerEventInfo({
                title: 'input',
                parents: ['Choreographer#doFrame'],
                docLinks: choreographerLinks,
                description: 'Input callbacks are processed. This generally encompasses dispatching input to Views, as well as any work the Views do to process this input/gesture.'
            });
            registerEventInfo({
                title: 'animation',
                parents: ['Choreographer#doFrame'],
                docLinks: choreographerLinks,
                description: 'Animation callbacks are processed. This is generally minimal work, as animations determine progress for the frame, and push new state to animated objects (such as setting View properties).'
            });
            registerEventInfo({
                title: 'traversals',
                parents: ['Choreographer#doFrame'],
                docLinks: choreographerLinks,
                description: 'Primary draw traversals. This is the primary traversal of the View hierarchy, including layout and draw passes.'
            });
            const traversalParents = ['Choreographer#doFrame', 'performTraversals'];
            const layoutLinks = new DocLinkBuilder().addDacRef('View#Layout', 'android/view/View.html#Layout').build();
            registerEventInfo({
                title: 'performTraversals',
                description: 'A drawing traversal of the View hierarchy, comprised of all layout and drawing needed to produce the frame.'
            });
            registerEventInfo({
                title: 'measure',
                parents: traversalParents,
                docLinks: layoutLinks,
                description: 'First of two phases in view hierarchy layout. Views are asked to size themselves according to constraints supplied by their parent. Some ViewGroups may measure a child more than once to help satisfy their own constraints. Nesting ViewGroups that measure children more than once can lead to excessive and repeated work.'
            });
            registerEventInfo({
                title: 'layout',
                parents: traversalParents,
                docLinks: layoutLinks,
                description: 'Second of two phases in view hierarchy layout, repositioning content and child Views into their new locations.'
            });
            const drawString = 'Draw pass over the View hierarchy. Every invalidated View will have its drawing commands recorded. On Android versions prior to Lollipop, this would also include the issuing of draw commands to the GPU. Starting with Lollipop, it only includes the recording of commands, and syncing that information to the RenderThread.';
            registerEventInfo({title: 'draw', parents: traversalParents, description: drawString});
            const recordString = 'Every invalidated View\'s drawing commands are recorded. Each will have View#draw() called, and is passed a Canvas that will record and store its drawing commands until it is next invalidated/rerecorded.';
            registerEventInfo({title: 'getDisplayList', parents: ['draw'], description: recordString});
            registerEventInfo({title: 'Record View#draw()', parents: ['draw'], description: recordString});
            registerEventInfo({
                title: 'drawDisplayList',
                parents: ['draw'],
                description: 'Execution of recorded draw commands to generate a frame. This represents the actual formation and issuing of drawing commands to the GPU. On Android L and higher devices, this work is done on a dedicated RenderThread, instead of on the UI Thread.'
            });
            registerEventInfo({
                title: 'DrawFrame',
                description: 'RenderThread portion of the standard UI/RenderThread split frame. This represents the actual formation and issuing of drawing commands to the GPU.'
            });
            registerEventInfo({
                title: 'doFrame',
                description: 'RenderThread animation frame. Represents drawing work done by the RenderThread on a frame where the UI thread did not produce new drawing content.'
            });
            registerEventInfo({
                title: 'syncFrameState',
                description: 'Sync stage between the UI thread and the RenderThread, where the UI thread hands off a frame (including information about modified Views). Time in this method primarily consists of uploading modified Bitmaps to the GPU. After this sync is completed, the UI thread is unblocked, and the RenderThread starts to render the frame.'
            });
            registerEventInfo({
                title: 'flush drawing commands',
                description: 'Issuing the now complete drawing commands to the GPU.'
            });
            registerEventInfo({title: 'eglSwapBuffers', description: 'Complete GPU rendering of the frame.'});
            registerEventInfo({
                title: 'RV Scroll',
                description: 'RecyclerView is calculating a scroll. If there are too many of these in Systrace, some Views inside RecyclerView might be causing it. Try to avoid using EditText, focusable views or handle them with care.'
            });
            registerEventInfo({
                title: 'RV OnLayout',
                description: 'OnLayout has been called by the View system. If this shows up too many times in Systrace, make sure the children of RecyclerView do not update themselves directly. This will cause a full re-layout but when it happens via the Adapter notifyItemChanged, RecyclerView can avoid full layout calculation.'
            });
            registerEventInfo({
                title: 'RV FullInvalidate',
                description: 'NotifyDataSetChanged or equal has been called. If this is taking a long time, try sending granular notify adapter changes instead of just calling notifyDataSetChanged or setAdapter / swapAdapter. Adding stable ids to your adapter might help.'
            });
            registerEventInfo({
                title: 'RV PartialInvalidate',
                description: 'RecyclerView is rebinding a View. If this is taking a lot of time, consider optimizing your layout or make sure you are not doing extra operations in onBindViewHolder call.'
            });
            registerEventInfo({
                title: 'RV OnBindView',
                description: 'RecyclerView is rebinding a View. If this is taking a lot of time, consider optimizing your layout or make sure you are not doing extra operations in onBindViewHolder call.'
            });
            registerEventInfo({
                title: 'RV CreateView',
                description: 'RecyclerView is creating a new View. If too many of these are present: 1) There might be a problem in Recycling (e.g. custom Animations that set transient state and prevent recycling or ItemAnimator not implementing the contract properly. See Adapter#onFailedToRecycleView(ViewHolder). 2) There may be too many item view types. Try merging them. 3) There might be too many itemChange animations and not enough space in RecyclerPool. Try increasing your pool size and item cache size.'
            });
            registerEventInfo({
                title: 'eglSwapBuffers',
                description: 'The CPU has finished producing drawing commands, and is flushing drawing work to the GPU, and posting that buffer to the consumer (which is often SurfaceFlinger window composition). Once this is completed, the GPU can produce the frame content without any involvement from the CPU.'
            });
        }, applyEventInfosRecursive_(parentNames, slice) {
            const checkExpectedParentNames = function (expectedParentNames) {
                if (!expectedParentNames) return true;
                return expectedParentNames.some(function (name) {
                    return parentNames.has(name);
                });
            };
            if (this.titleInfoLookup.has(slice.title)) {
                if (checkExpectedParentNames(this.titleParentLookup.get(slice.title))) {
                    slice.info = this.titleInfoLookup.get(slice.title);
                }
            }
            if (slice.subSlices.length > 0) {
                if (!parentNames.has(slice.title)) {
                    parentNames.set(slice.title, 0);
                }
                parentNames.set(slice.title, parentNames.get(slice.title) + 1);
                slice.subSlices.forEach(function (subSlice) {
                    this.applyEventInfosRecursive_(parentNames, subSlice);
                }, this);
                parentNames.set(slice.title, parentNames.get(slice.title) - 1);
                if (parentNames.get(slice.title) === 0) {
                    delete parentNames[slice.title];
                }
            }
        }, applyEventInfos(sliceGroup) {
            sliceGroup.topLevelSlices.forEach(function (slice) {
                this.applyEventInfosRecursive_(new Map(), slice);
            }, this);
        }
    };
    return {AndroidAuditor,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ObjectSnapshot(objectInstance, ts, args) {
        tr.model.Event.call(this);
        this.objectInstance = objectInstance;
        this.ts = ts;
        this.args = args;
    }

    ObjectSnapshot.prototype = {
        __proto__: tr.model.Event.prototype, preInitialize() {
        }, initialize() {
        }, referencedAt(item, object, field) {
        }, addBoundsToRange(range) {
            range.addValue(this.ts);
        }, get userFriendlyName() {
            return 'Snapshot of ' + this.objectInstance.userFriendlyName + ' @ ' +
                tr.b.Unit.byName.timeStampInMs.format(this.ts);
        }
    };
    tr.model.EventRegistry.register(ObjectSnapshot, {name: 'objectSnapshot', pluralName: 'objectSnapshots'});
    return {ObjectSnapshot,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ObjectSnapshot = tr.model.ObjectSnapshot;

    function ObjectInstance(parent, scopedId, category, name, creationTs, opt_baseTypeName) {
        tr.model.Event.call(this);
        this.parent = parent;
        this.scopedId = scopedId;
        this.category = category;
        this.baseTypeName = opt_baseTypeName ? opt_baseTypeName : name;
        this.name = name;
        this.creationTs = creationTs;
        this.creationTsWasExplicit = false;
        this.deletionTs = Number.MAX_VALUE;
        this.deletionTsWasExplicit = false;
        this.colorId = 0;
        this.bounds = new tr.b.math.Range();
        this.snapshots = [];
        this.hasImplicitSnapshots = false;
    }

    ObjectInstance.prototype = {
        __proto__: tr.model.Event.prototype, get typeName() {
            return this.name;
        }, addBoundsToRange(range) {
            range.addRange(this.bounds);
        }, addSnapshot(ts, args, opt_name, opt_baseTypeName) {
            if (ts < this.creationTs) {
                throw new Error('Snapshots must be >= instance.creationTs');
            }
            if (ts >= this.deletionTs) {
                throw new Error('Snapshots cannot be added after ' + 'an objects deletion timestamp.');
            }
            let lastSnapshot;
            if (this.snapshots.length > 0) {
                lastSnapshot = this.snapshots[this.snapshots.length - 1];
                if (lastSnapshot.ts === ts) {
                    throw new Error('Snapshots already exists at this time!');
                }
                if (ts < lastSnapshot.ts) {
                    throw new Error('Snapshots must be added in increasing timestamp order');
                }
            }
            if (opt_name && (this.name !== opt_name)) {
                if (!opt_baseTypeName) {
                    throw new Error('Must provide base type name for name update');
                }
                if (this.baseTypeName !== opt_baseTypeName) {
                    throw new Error('Cannot update type name: base types dont match');
                }
                this.name = opt_name;
            }
            const snapshotConstructor = tr.model.ObjectSnapshot.subTypes.getConstructor(this.category, this.name);
            const snapshot = new snapshotConstructor(this, ts, args);
            this.snapshots.push(snapshot);
            return snapshot;
        }, wasDeleted(ts) {
            let lastSnapshot;
            if (this.snapshots.length > 0) {
                lastSnapshot = this.snapshots[this.snapshots.length - 1];
                if (lastSnapshot.ts > ts) {
                    throw new Error('Instance cannot be deleted at ts=' +
                        ts + '. A snapshot exists that is older.');
                }
            }
            this.deletionTs = ts;
            this.deletionTsWasExplicit = true;
        }, preInitialize() {
            for (let i = 0; i < this.snapshots.length; i++) {
                this.snapshots[i].preInitialize();
            }
        }, initialize() {
            for (let i = 0; i < this.snapshots.length; i++) {
                this.snapshots[i].initialize();
            }
        }, isAliveAt(ts) {
            if (ts < this.creationTs && this.creationTsWasExplicit) {
                return false;
            }
            if (ts > this.deletionTs) {
                return false;
            }
            return true;
        }, getSnapshotAt(ts) {
            if (ts < this.creationTs) {
                if (this.creationTsWasExplicit) {
                    throw new Error('ts must be within lifetime of this instance');
                }
                return this.snapshots[0];
            }
            if (ts > this.deletionTs) {
                throw new Error('ts must be within lifetime of this instance');
            }
            const snapshots = this.snapshots;
            const i = tr.b.findIndexInSortedIntervals(snapshots, function (snapshot) {
                return snapshot.ts;
            }, function (snapshot, i) {
                if (i === snapshots.length - 1) {
                    return snapshots[i].objectInstance.deletionTs;
                }
                return snapshots[i + 1].ts - snapshots[i].ts;
            }, ts);
            if (i < 0) {
                return this.snapshots[0];
            }
            if (i >= this.snapshots.length) {
                return this.snapshots[this.snapshots.length - 1];
            }
            return this.snapshots[i];
        }, updateBounds() {
            this.bounds.reset();
            this.bounds.addValue(this.creationTs);
            if (this.deletionTs !== Number.MAX_VALUE) {
                this.bounds.addValue(this.deletionTs);
            } else if (this.snapshots.length > 0) {
                this.bounds.addValue(this.snapshots[this.snapshots.length - 1].ts);
            }
        }, shiftTimestampsForward(amount) {
            this.creationTs += amount;
            if (this.deletionTs !== Number.MAX_VALUE) {
                this.deletionTs += amount;
            }
            this.snapshots.forEach(function (snapshot) {
                snapshot.ts += amount;
            });
        }, get userFriendlyName() {
            return this.typeName + ' object ' + this.scopedId;
        }
    };
    tr.model.EventRegistry.register(ObjectInstance, {name: 'objectInstance', pluralName: 'objectInstances'});
    return {ObjectInstance,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const ObjectSnapshot = tr.model.ObjectSnapshot;
    const ObjectInstance = tr.model.ObjectInstance;

    function BlameContextSnapshot() {
        ObjectSnapshot.apply(this, arguments);
    }

    BlameContextSnapshot.prototype = {
        __proto__: ObjectSnapshot.prototype, get parentContext() {
            if (this.args.parent instanceof BlameContextSnapshot) {
                return this.args.parent;
            }
            return undefined;
        }, get userFriendlyName() {
            return 'BlameContext';
        }
    };

    function BlameContextInstance() {
        ObjectInstance.apply(this, arguments);
    }

    BlameContextInstance.prototype = {
        __proto__: ObjectInstance.prototype, get blameContextType() {
            throw new Error('Not implemented');
        }
    };
    return {BlameContextSnapshot, BlameContextInstance,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
    const BlameContextInstance = tr.e.chrome.BlameContextInstance;

    function FrameTreeNodeSnapshot() {
        BlameContextSnapshot.apply(this, arguments);
    }

    FrameTreeNodeSnapshot.prototype = {
        __proto__: BlameContextSnapshot.prototype, get renderFrame() {
            if (this.args.renderFrame instanceof tr.e.chrome.RenderFrameSnapshot) {
                return this.args.renderFrame;
            }
            return undefined;
        }, get url() {
            return this.args.url;
        }, get userFriendlyName() {
            return 'FrameTreeNode';
        }
    };
    tr.model.ObjectSnapshot.subTypes.register(FrameTreeNodeSnapshot, {typeName: 'FrameTreeNode'});

    function FrameTreeNodeInstance() {
        BlameContextInstance.apply(this, arguments);
    }

    FrameTreeNodeInstance.prototype = {
        __proto__: BlameContextInstance.prototype, get blameContextType() {
            return 'Frame';
        }
    };
    tr.model.ObjectInstance.subTypes.register(FrameTreeNodeInstance, {typeName: 'FrameTreeNode'});
    return {FrameTreeNodeSnapshot, FrameTreeNodeInstance,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
    const BlameContextInstance = tr.e.chrome.BlameContextInstance;

    function RenderFrameSnapshot() {
        BlameContextSnapshot.apply(this, arguments);
    }

    RenderFrameSnapshot.prototype = {
        __proto__: BlameContextSnapshot.prototype, referencedAt(item, object, field) {
            if (item instanceof tr.e.chrome.FrameTreeNodeSnapshot && object === item.args && field === 'renderFrame') {
                this.args.frameTreeNode = item;
            }
        }, get frameTreeNode() {
            if (this.args.frameTreeNode instanceof
                tr.e.chrome.FrameTreeNodeSnapshot) {
                return this.args.frameTreeNode;
            }
            return undefined;
        }, get url() {
            if (this.frameTreeNode) {
                return this.frameTreeNode.url;
            }
            return undefined;
        }, get userFriendlyName() {
            return 'RenderFrame';
        }
    };
    tr.model.ObjectSnapshot.subTypes.register(RenderFrameSnapshot, {typeName: 'RenderFrame'});

    function RenderFrameInstance() {
        BlameContextInstance.apply(this, arguments);
    }

    RenderFrameInstance.prototype = {
        __proto__: BlameContextInstance.prototype, get blameContextType() {
            return 'Frame';
        }
    };
    tr.model.ObjectInstance.subTypes.register(RenderFrameInstance, {typeName: 'RenderFrame'});
    return {RenderFrameSnapshot, RenderFrameInstance,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
    const BlameContextInstance = tr.e.chrome.BlameContextInstance;

    function TopLevelSnapshot() {
        BlameContextSnapshot.apply(this, arguments);
    }

    TopLevelSnapshot.prototype = {
        __proto__: BlameContextSnapshot.prototype, get userFriendlyName() {
            return 'TopLevel';
        }
    };
    tr.model.ObjectSnapshot.subTypes.register(TopLevelSnapshot, {typeName: 'TopLevel'});

    function TopLevelInstance() {
        BlameContextInstance.apply(this, arguments);
    }

    TopLevelInstance.prototype = {
        __proto__: BlameContextInstance.prototype, get blameContextType() {
            return 'TopLevel';
        }
    };
    tr.model.ObjectInstance.subTypes.register(TopLevelInstance, {typeName: 'TopLevel'});
    return {TopLevelSnapshot, TopLevelInstance,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function AsyncSlice(category, title, colorId, start, args, duration, opt_isTopLevel, opt_cpuStart, opt_cpuDuration, opt_argsStripped) {
        tr.model.TimedEvent.call(this, start);
        this.category = category || '';
        this.originalTitle = title;
        this.title = title;
        this.colorId = colorId;
        this.args = args;
        this.startStackFrame = undefined;
        this.endStackFrame = undefined;
        this.didNotFinish = false;
        this.important = false;
        this.subSlices = [];
        this.parentContainer_ = undefined;
        this.id = undefined;
        this.startThread = undefined;
        this.endThread = undefined;
        this.cpuStart = undefined;
        this.cpuDuration = undefined;
        this.argsStripped = false;
        this.startStackFrame = undefined;
        this.endStackFrame = undefined;
        this.duration = duration;
        this.isTopLevel = (opt_isTopLevel === true);
        if (opt_cpuStart !== undefined) {
            this.cpuStart = opt_cpuStart;
        }
        if (opt_cpuDuration !== undefined) {
            this.cpuDuration = opt_cpuDuration;
        }
        if (opt_argsStripped !== undefined) {
            this.argsStripped = opt_argsStripped;
        }
    }

    AsyncSlice.prototype = {
        __proto__: tr.model.TimedEvent.prototype, get analysisTypeName() {
            return this.title;
        }, get parentContainer() {
            return this.parentContainer_;
        }, set parentContainer(parentContainer) {
            this.parentContainer_ = parentContainer;
            for (let i = 0; i < this.subSlices.length; i++) {
                const subSlice = this.subSlices[i];
                if (subSlice.parentContainer === undefined) {
                    subSlice.parentContainer = parentContainer;
                }
            }
        }, get viewSubGroupTitle() {
            return this.title;
        }, get viewSubGroupGroupingKey() {
            return undefined;
        }, get userFriendlyName() {
            return 'Async slice ' + this.title + ' at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }, get stableId() {
            const parentAsyncSliceGroup = this.parentContainer.asyncSliceGroup;
            return parentAsyncSliceGroup.stableId + '.' +
                parentAsyncSliceGroup.slices.indexOf(this);
        }, * findTopmostSlicesRelativeToThisSlice(eventPredicate, opt_this) {
            if (eventPredicate(this)) {
                yield this;
                return;
            }
            for (const s of this.subSlices) {
                yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
            }
        }, findDescendentSlice(targetTitle) {
            if (!this.subSlices) return undefined;
            for (let i = 0; i < this.subSlices.length; i++) {
                if (this.subSlices[i].title === targetTitle) {
                    return this.subSlices[i];
                }
                const slice = this.subSlices[i].findDescendentSlice(targetTitle);
                if (slice) return slice;
            }
            return undefined;
        }, * enumerateAllDescendents() {
            for (const slice of this.subSlices) {
                yield slice;
            }
            for (const slice of this.subSlices) {
                if (slice.enumerateAllDescendents !== undefined) {
                    yield* slice.enumerateAllDescendents();
                }
            }
        }, compareTo(that) {
            return this.title.localeCompare(that.title);
        }
    };
    tr.model.EventRegistry.register(AsyncSlice, {name: 'asyncSlice', pluralName: 'asyncSlices'});
    return {AsyncSlice,};
});
'use strict';
tr.exportTo('tr.e.blink', function () {
    class BlinkSchedulerAsyncSlice extends tr.model.AsyncSlice {
        get viewSubGroupGroupingKey() {
            if (this.title.startsWith('FrameScheduler.')) {
                return 'Frame' + this.id;
            }
            if (this.title.startsWith('Scheduler.')) {
                return 'Renderer Scheduler';
            }
            return undefined;
        }

        get viewSubGroupTitle() {
            if (this.title.startsWith('FrameScheduler.')) {
                return this.title.substring(15);
            }
            if (this.title.startsWith('Scheduler.')) {
                return this.title.substring(10);
            }
            return this.title;
        }
    }

    tr.model.AsyncSlice.subTypes.register(BlinkSchedulerAsyncSlice, {categoryParts: ['renderer.scheduler', 'disabled-by-default-renderer.scheduler', 'disabled-by-default-renderer.scheduler.debug',]});
    return {BlinkSchedulerAsyncSlice,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const MAIN_FRAMETIME_TYPE = 'main_frametime_type';
    const IMPL_FRAMETIME_TYPE = 'impl_frametime_type';
    const MAIN_RENDERING_STATS = 'BenchmarkInstrumentation::MainThreadRenderingStats';
    const IMPL_RENDERING_STATS = 'BenchmarkInstrumentation::ImplThreadRenderingStats';

    function getSlicesIntersectingRange(rangeOfInterest, slices) {
        const slicesInFilterRange = [];
        for (let i = 0; i < slices.length; i++) {
            const slice = slices[i];
            if (rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end)) {
                slicesInFilterRange.push(slice);
            }
        }
        return slicesInFilterRange;
    }

    function ChromeProcessHelper(modelHelper, process) {
        this.modelHelper = modelHelper;
        this.process = process;
        this.telemetryInternalRanges_ = undefined;
    }

    ChromeProcessHelper.prototype = {
        get pid() {
            return this.process.pid;
        }, isTelemetryInternalEvent(slice) {
            if (this.telemetryInternalRanges_ === undefined) {
                this.findTelemetryInternalRanges_();
            }
            for (const range of this.telemetryInternalRanges_) {
                if (range.containsExplicitRangeInclusive(slice.start, slice.end)) {
                    return true;
                }
            }
            return false;
        }, findTelemetryInternalRanges_() {
            this.telemetryInternalRanges_ = [];
            let start = 0;
            for (const thread of Object.values(this.process.threads)) {
                for (const slice of thread.asyncSliceGroup.getDescendantEvents()) {
                    if (/^telemetry\.internal\..*\.start$/.test(slice.title)) {
                        start = slice.start;
                    } else if (/^telemetry\.internal\..*\.end$/.test(slice.title) && start !== undefined) {
                        this.telemetryInternalRanges_.push(tr.b.math.Range.fromExplicitRange(start, slice.end));
                        start = undefined;
                    }
                }
            }
        }, getFrameEventsInRange(frametimeType, range) {
            const titleToGet = (frametimeType === MAIN_FRAMETIME_TYPE ? MAIN_RENDERING_STATS : IMPL_RENDERING_STATS);
            const frameEvents = [];
            for (const event of this.process.getDescendantEvents()) {
                if (event.title === titleToGet) {
                    if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
                        frameEvents.push(event);
                    }
                }
            }
            frameEvents.sort(function (a, b) {
                return a.start - b.start;
            });
            return frameEvents;
        }
    };

    function getFrametimeDataFromEvents(frameEvents) {
        const frametimeData = [];
        for (let i = 1; i < frameEvents.length; i++) {
            const diff = frameEvents[i].start - frameEvents[i - 1].start;
            frametimeData.push({'x': frameEvents[i].start, 'frametime': diff});
        }
        return frametimeData;
    }

    return {
        ChromeProcessHelper,
        MAIN_FRAMETIME_TYPE,
        IMPL_FRAMETIME_TYPE,
        MAIN_RENDERING_STATS,
        IMPL_RENDERING_STATS,
        getSlicesIntersectingRange,
        getFrametimeDataFromEvents,
    };
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    function ChromeBrowserHelper(modelHelper, process) {
        tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
        this.mainThread_ = process.findAtMostOneThreadNamed('CrBrowserMain');
        if (!process.name) {
            process.name = ChromeBrowserHelper.PROCESS_NAME;
        }
    }

    ChromeBrowserHelper.PROCESS_NAME = 'Browser';
    ChromeBrowserHelper.isBrowserProcess = function (process) {
        return !!process.findAtMostOneThreadNamed('CrBrowserMain');
    };
    ChromeBrowserHelper.prototype = {
        __proto__: tr.model.helpers.ChromeProcessHelper.prototype, get browserName() {
            const hasInProcessRendererThread = this.process.findAllThreadsNamed('Chrome_InProcRendererThread').length > 0;
            return hasInProcessRendererThread ? 'webview' : 'chrome';
        }, get mainThread() {
            return this.mainThread_;
        }, get rendererHelpers() {
            return this.modelHelper.rendererHelpers;
        }, getLoadingEventsInRange(rangeOfInterest) {
            return this.getAllAsyncSlicesMatching(function (slice) {
                return slice.title.indexOf('WebContentsImpl Loading') === 0 && rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end);
            });
        }, getCommitProvisionalLoadEventsInRange(rangeOfInterest) {
            return this.getAllAsyncSlicesMatching(function (slice) {
                return slice.title === 'RenderFrameImpl::didCommitProvisionalLoad' && rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end);
            });
        }, get hasLatencyEvents() {
            let hasLatency = false;
            for (const thread of this.modelHelper.model.getAllThreads()) {
                for (const event of thread.getDescendantEvents()) {
                    if (!event.isTopLevel) continue;
                    if (!(event instanceof tr.e.cc.InputLatencyAsyncSlice)) {
                        continue;
                    }
                    hasLatency = true;
                }
            }
            return hasLatency;
        }, getLatencyEventsInRange(rangeOfInterest) {
            return this.getAllAsyncSlicesMatching(function (slice) {
                return (slice.title.indexOf('InputLatency') === 0) && rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end);
            });
        }, getAllAsyncSlicesMatching(pred, opt_this) {
            const events = [];
            this.iterAllThreads(function (thread) {
                for (const slice of thread.getDescendantEvents()) {
                    if (pred.call(opt_this, slice)) {
                        events.push(slice);
                    }
                }
            });
            return events;
        }, iterAllThreads(func, opt_this) {
            for (const thread of Object.values(this.process.threads)) {
                func.call(opt_this, thread);
            }
            for (const rendererHelper of Object.values(this.rendererHelpers)) {
                const rendererProcess = rendererHelper.process;
                for (const thread of Object.values(rendererProcess.threads)) {
                    func.call(opt_this, thread);
                }
            }
        }
    };
    return {ChromeBrowserHelper,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    function ChromeGpuHelper(modelHelper, process) {
        tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
        if (!process.name) {
            process.name = ChromeGpuHelper.PROCESS_NAME;
        }
    }

    ChromeGpuHelper.PROCESS_NAME = 'GPU Process';
    ChromeGpuHelper.isGpuProcess = function (process) {
        if (process.findAtMostOneThreadNamed('CrBrowserMain') || process.findAtMostOneThreadNamed('CrRendererMain')) {
            return false;
        }
        return process.findAllThreadsNamed('CrGpuMain').length > 0;
    };
    ChromeGpuHelper.prototype = {__proto__: tr.model.helpers.ChromeProcessHelper.prototype};
    return {ChromeGpuHelper,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const NET_CATEGORIES = new Set(['net', 'netlog', 'disabled-by-default-netlog', 'disabled-by-default-network']);

    class ChromeThreadHelper {
        constructor(thread) {
            this.thread = thread;
        }

        getNetworkEvents() {
            const networkEvents = [];
            for (const slice of this.thread.asyncSliceGroup.slices) {
                const categories = tr.b.getCategoryParts(slice.category);
                const isNetEvent = category => NET_CATEGORIES.has(category);
                if (categories.filter(isNetEvent).length === 0) continue;
                networkEvents.push(slice);
            }
            return networkEvents;
        }
    }

    return {ChromeThreadHelper,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const ChromeThreadHelper = tr.model.helpers.ChromeThreadHelper;

    function ChromeRendererHelper(modelHelper, process) {
        tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
        this.mainThread_ = process.findAtMostOneThreadNamed('CrRendererMain') || process.findAtMostOneThreadNamed('Chrome_InProcRendererThread');
        this.compositorThread_ = process.findAtMostOneThreadNamed('Compositor');
        this.rasterWorkerThreads_ = process.findAllThreadsMatching(function (t) {
            if (t.name === undefined) return false;
            if (t.name.startsWith('CompositorTileWorker')) return true;
            if (t.name.startsWith('CompositorRasterWorker')) return true;
            return false;
        });
        this.dedicatedWorkerThreads_ = process.findAllThreadsMatching(function (t) {
            return t.name && t.name.startsWith('DedicatedWorker');
        });
        this.foregroundWorkerThreads_ = process.findAllThreadsMatching(function (t) {
            return t.name && t.name.startsWith('ThreadPoolForegroundWorker');
        });
        if (!process.name) {
            process.name = ChromeRendererHelper.PROCESS_NAME;
        }
    }

    ChromeRendererHelper.PROCESS_NAME = 'Renderer';
    ChromeRendererHelper.isRenderProcess = function (process) {
        if (process.findAtMostOneThreadNamed('CrRendererMain')) return true;
        if (process.findAtMostOneThreadNamed('Compositor')) return true;
        return false;
    };
    ChromeRendererHelper.isTracingProcess = function (process) {
        return process.labels !== undefined && process.labels.length === 1 && process.labels[0] === 'chrome://tracing';
    };
    ChromeRendererHelper.prototype = {
        __proto__: tr.model.helpers.ChromeProcessHelper.prototype, get mainThread() {
            return this.mainThread_;
        }, get compositorThread() {
            return this.compositorThread_;
        }, get rasterWorkerThreads() {
            return this.rasterWorkerThreads_;
        }, get dedicatedWorkerThreads() {
            return this.dedicatedWorkerThreads_;
        }, get foregroundWorkerThreads() {
            return this.foregroundWorkerThreads_;
        }, get isChromeTracingUI() {
            return ChromeRendererHelper.isTracingProcess(this.process);
        },
    };
    return {ChromeRendererHelper,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    class Segment extends tr.model.TimedEvent {
        constructor(start, duration) {
            super(start);
            this.duration = duration;
            this.expectations_ = [];
        }

        get expectations() {
            return this.expectations_;
        }

        clone() {
            const clone = new Segment(this.start, this.duration);
            clone.expectations.push(...this.expectations);
            return clone;
        }

        addSegment(other) {
            this.duration += other.duration;
            this.expectations.push(...other.expectations);
        }
    }

    return {Segment,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    const GESTURE_EVENT = 'SyntheticGestureController::running';
    const IR_REG_EXP = /Interaction\.([^/]+)(\/[^/]*)?$/;
    const ChromeRendererHelper = tr.model.helpers.ChromeRendererHelper;

    class TelemetryHelper {
        constructor(modelHelper) {
            this.modelHelper = modelHelper;
            this.renderersWithIR_ = undefined;
            this.irSegments_ = undefined;
            this.uiSegments_ = undefined;
            this.animationSegments_ = undefined;
        }

        get renderersWithIR() {
            this.findIRs_();
            return this.renderersWithIR_;
        }

        get irSegments() {
            this.findIRs_();
            return this.irSegments_;
        }

        get uiSegments() {
            this.findIRs_();
            return this.uiSegments_;
        }

        get animationSegments() {
            if (this.animationSegments_ === undefined) {
                const model = this.modelHelper.model;
                this.animationSegments_ = model.userModel.segments.filter(segment => segment.expectations.find(ue => ue instanceof tr.model.um.AnimationExpectation));
                this.animationSegments_.sort((x, y) => x.start - y.start);
            }
            return this.animationSegments_;
        }

        findIRs_() {
            if (this.irSegments_ !== undefined) return;
            this.renderersWithIR_ = [];
            const gestureEvents = [];
            const interactionRecords = [];
            const processes = Object.values(this.modelHelper.rendererHelpers).concat(this.modelHelper.browserHelpers).map(processHelper => processHelper.process);
            for (const process of processes) {
                let foundIR = false;
                for (const thread of Object.values(process.threads)) {
                    for (const slice of thread.asyncSliceGroup.slices) {
                        if (slice.title === GESTURE_EVENT) {
                            gestureEvents.push(slice);
                        } else if (IR_REG_EXP.test(slice.title)) {
                            interactionRecords.push(slice);
                            foundIR = true;
                        }
                    }
                }
                if (foundIR && ChromeRendererHelper.isRenderProcess(process) && !ChromeRendererHelper.isTracingProcess(process)) {
                    this.renderersWithIR_.push(new ChromeRendererHelper(this.modelHelper, process));
                }
            }
            this.irSegments_ = [];
            this.uiSegments_ = [];
            for (const ir of interactionRecords) {
                const parts = IR_REG_EXP.exec(ir.title);
                let gestureEventFound = false;
                if (parts[1].startsWith('Gesture_')) {
                    for (const gestureEvent of gestureEvents) {
                        if (ir.boundsRange.intersectsRangeInclusive(gestureEvent.boundsRange)) {
                            this.irSegments_.push(new tr.model.um.Segment(gestureEvent.start, gestureEvent.duration));
                            gestureEventFound = true;
                            break;
                        }
                    }
                } else if (parts[1].startsWith('ui_')) {
                    this.uiSegments_.push(new tr.model.um.Segment(ir.start, ir.duration));
                }
                if (!gestureEventFound) {
                    this.irSegments_.push(new tr.model.um.Segment(ir.start, ir.duration));
                }
            }
            this.irSegments_.sort((x, y) => x.start - y.start);
            this.uiSegments_.sort((x, y) => x.start - y.start);
        }
    }

    return {TelemetryHelper,};
});
'use strict';
tr.exportTo('tr.model.helpers', function () {
    function findChromeBrowserProcesses(model) {
        return model.getAllProcesses(tr.model.helpers.ChromeBrowserHelper.isBrowserProcess);
    }

    function findChromeRenderProcesses(model) {
        return model.getAllProcesses(tr.model.helpers.ChromeRendererHelper.isRenderProcess);
    }

    function findChromeGpuProcess(model) {
        const gpuProcesses = model.getAllProcesses(tr.model.helpers.ChromeGpuHelper.isGpuProcess);
        if (gpuProcesses.length !== 1) return undefined;
        return gpuProcesses[0];
    }

    function findTelemetrySurfaceFlingerProcess(model) {
        const surfaceFlingerProcesses = model.getAllProcesses(process => (process.name === 'SurfaceFlinger'));
        if (surfaceFlingerProcesses.length !== 1) return undefined;
        return surfaceFlingerProcesses[0];
    }

    function ChromeModelHelper(model) {
        this.model_ = model;
        const browserProcesses = findChromeBrowserProcesses(model);
        this.browserHelpers_ = browserProcesses.map(p => new tr.model.helpers.ChromeBrowserHelper(this, p));
        const gpuProcess = findChromeGpuProcess(model);
        if (gpuProcess) {
            this.gpuHelper_ = new tr.model.helpers.ChromeGpuHelper(this, gpuProcess);
        } else {
            this.gpuHelper_ = undefined;
        }
        const rendererProcesses_ = findChromeRenderProcesses(model);
        this.rendererHelpers_ = {};
        rendererProcesses_.forEach(function (renderProcess) {
            const rendererHelper = new tr.model.helpers.ChromeRendererHelper(this, renderProcess);
            this.rendererHelpers_[rendererHelper.pid] = rendererHelper;
        }, this);
        this.surfaceFlingerProcess_ = findTelemetrySurfaceFlingerProcess(model);
        this.chromeBounds_ = undefined;
        this.telemetryHelper_ = new tr.model.helpers.TelemetryHelper(this);
    }

    ChromeModelHelper.guid = tr.b.GUID.allocateSimple();
    ChromeModelHelper.supportsModel = function (model) {
        if (findChromeBrowserProcesses(model).length) return true;
        if (findChromeRenderProcesses(model).length) return true;
        return false;
    };
    ChromeModelHelper.prototype = {
        get pid() {
            throw new Error('woah');
        }, get process() {
            throw new Error('woah');
        }, get model() {
            return this.model_;
        }, get browserProcess() {
            if (this.browserHelper === undefined) return undefined;
            return this.browserHelper.process;
        }, get browserHelper() {
            return this.browserHelpers_[0];
        }, get browserHelpers() {
            return this.browserHelpers_;
        }, get gpuHelper() {
            return this.gpuHelper_;
        }, get rendererHelpers() {
            return this.rendererHelpers_;
        }, get surfaceFlingerProcess() {
            return this.surfaceFlingerProcess_;
        }, get chromeBounds() {
            if (!this.chromeBounds_) {
                this.chromeBounds_ = new tr.b.math.Range();
                for (const browserHelper of Object.values(this.browserHelpers)) {
                    this.chromeBounds_.addRange(browserHelper.process.bounds);
                }
                for (const rendererHelper of Object.values(this.rendererHelpers)) {
                    this.chromeBounds_.addRange(rendererHelper.process.bounds);
                }
                if (this.gpuHelper) {
                    this.chromeBounds_.addRange(this.gpuHelper.process.bounds);
                }
            }
            if (this.chromeBounds_.isEmpty) {
                return undefined;
            }
            return this.chromeBounds_;
        }, get telemetryHelper() {
            return this.telemetryHelper_;
        }
    };
    return {ChromeModelHelper,};
});
'use strict';
tr.exportTo('tr.e.cc', function () {
    const AsyncSlice = tr.model.AsyncSlice;
    const EventSet = tr.model.EventSet;
    const UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';
    const ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
    const BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
    const END_COMP_NAME = 'INPUT_EVENT_GPU_SWAP_BUFFER_COMPONENT';
    const LEGACY_END_COMP_NAME = 'INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';
    const MAIN_RENDERER_THREAD_NAME = 'CrRendererMain';
    const COMPOSITOR_THREAD_NAME = 'Compositor';
    const POSTTASK_FLOW_EVENT = 'disabled-by-default-toplevel.flow';
    const IPC_FLOW_EVENT = 'disabled-by-default-ipc.flow';
    const INPUT_EVENT_TYPE_NAMES = {
        CHAR: 'Char',
        CLICK: 'GestureClick',
        CONTEXT_MENU: 'ContextMenu',
        FLING_CANCEL: 'GestureFlingCancel',
        FLING_START: 'GestureFlingStart',
        KEY_DOWN: 'KeyDown',
        KEY_DOWN_RAW: 'RawKeyDown',
        KEY_UP: 'KeyUp',
        LATENCY_SCROLL_UPDATE: 'ScrollUpdate',
        MOUSE_DOWN: 'MouseDown',
        MOUSE_ENTER: 'MouseEnter',
        MOUSE_LEAVE: 'MouseLeave',
        MOUSE_MOVE: 'MouseMove',
        MOUSE_UP: 'MouseUp',
        MOUSE_WHEEL: 'MouseWheel',
        PINCH_BEGIN: 'GesturePinchBegin',
        PINCH_END: 'GesturePinchEnd',
        PINCH_UPDATE: 'GesturePinchUpdate',
        SCROLL_BEGIN: 'GestureScrollBegin',
        SCROLL_END: 'GestureScrollEnd',
        SCROLL_UPDATE: 'GestureScrollUpdate',
        SCROLL_UPDATE_RENDERER: 'ScrollUpdate',
        SHOW_PRESS: 'GestureShowPress',
        TAP: 'GestureTap',
        TAP_CANCEL: 'GestureTapCancel',
        TAP_DOWN: 'GestureTapDown',
        TOUCH_CANCEL: 'TouchCancel',
        TOUCH_END: 'TouchEnd',
        TOUCH_MOVE: 'TouchMove',
        TOUCH_START: 'TouchStart',
        UNKNOWN: 'UNKNOWN'
    };

    function InputLatencyAsyncSlice() {
        AsyncSlice.apply(this, arguments);
        this.associatedEvents_ = new EventSet();
        this.typeName_ = undefined;
        if (!this.isLegacyEvent) {
            this.determineModernTypeName_();
        }
    }

    InputLatencyAsyncSlice.prototype = {
        __proto__: AsyncSlice.prototype, get isLegacyEvent() {
            return this.title === 'InputLatency';
        }, get typeName() {
            if (!this.typeName_) {
                this.determineLegacyTypeName_();
            }
            return this.typeName_;
        }, checkTypeName_() {
            if (!this.typeName_) {
                throw new Error('Unable to determine typeName');
            }
            let found = false;
            for (const typeName in INPUT_EVENT_TYPE_NAMES) {
                if (this.typeName === INPUT_EVENT_TYPE_NAMES[typeName]) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                this.typeName_ = INPUT_EVENT_TYPE_NAMES.UNKNOWN;
            }
        }, determineModernTypeName_() {
            const lastColonIndex = this.title.lastIndexOf(':');
            if (lastColonIndex < 0) return;
            const characterAfterLastColonIndex = lastColonIndex + 1;
            this.typeName_ = this.title.slice(characterAfterLastColonIndex);
            this.checkTypeName_();
        }, determineLegacyTypeName_() {
            for (const subSlice of this.enumerateAllDescendents()) {
                const subSliceIsAInputLatencyAsyncSlice = (subSlice instanceof InputLatencyAsyncSlice);
                if (!subSliceIsAInputLatencyAsyncSlice) continue;
                if (!subSlice.typeName) continue;
                if (this.typeName_ && subSlice.typeName_) {
                    const subSliceHasDifferentTypeName = (this.typeName_ !== subSlice.typeName_);
                    if (subSliceHasDifferentTypeName) {
                        throw new Error('InputLatencyAsyncSlice.determineLegacyTypeName_() ' + ' found multiple typeNames');
                    }
                }
                this.typeName_ = subSlice.typeName_;
            }
            if (!this.typeName_) {
                throw new Error('InputLatencyAsyncSlice.determineLegacyTypeName_() failed');
            }
            this.checkTypeName_();
        }, getRendererHelper(sourceSlices) {
            const traceModel = this.startThread.parent.model;
            const modelHelper = traceModel.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
            if (!modelHelper) return undefined;
            let mainThread = undefined;
            let compositorThread = undefined;
            for (const i in sourceSlices) {
                if (sourceSlices[i].parentContainer.name === MAIN_RENDERER_THREAD_NAME) {
                    mainThread = sourceSlices[i].parentContainer;
                } else if (sourceSlices[i].parentContainer.name === COMPOSITOR_THREAD_NAME) {
                    compositorThread = sourceSlices[i].parentContainer;
                }
                if (mainThread && compositorThread) break;
            }
            const rendererHelpers = modelHelper.rendererHelpers;
            const pids = Object.keys(rendererHelpers);
            for (let i = 0; i < pids.length; i++) {
                const pid = pids[i];
                const rendererHelper = rendererHelpers[pid];
                if (rendererHelper.mainThread === mainThread || rendererHelper.compositorThread === compositorThread) {
                    return rendererHelper;
                }
            }
            return undefined;
        }, addEntireSliceHierarchy(slice) {
            this.associatedEvents_.push(slice);
            slice.iterateAllSubsequentSlices(function (subsequentSlice) {
                this.associatedEvents_.push(subsequentSlice);
            }, this);
        }, addDirectlyAssociatedEvents(flowEvents) {
            const slices = [];
            flowEvents.forEach(function (flowEvent) {
                this.associatedEvents_.push(flowEvent);
                const newSource = flowEvent.startSlice.mostTopLevelSlice;
                if (slices.indexOf(newSource) === -1) {
                    slices.push(newSource);
                }
            }, this);
            const lastFlowEvent = flowEvents[flowEvents.length - 1];
            const lastSource = lastFlowEvent.endSlice.mostTopLevelSlice;
            if (slices.indexOf(lastSource) === -1) {
                slices.push(lastSource);
            }
            return slices;
        }, addScrollUpdateEvents(rendererHelper) {
            if (!rendererHelper || !rendererHelper.compositorThread) {
                return;
            }
            const compositorThread = rendererHelper.compositorThread;
            const gestureScrollUpdateStart = this.start;
            const gestureScrollUpdateEnd = this.end;
            const allCompositorAsyncSlices = compositorThread.asyncSliceGroup.slices;
            for (const i in allCompositorAsyncSlices) {
                const slice = allCompositorAsyncSlices[i];
                if (slice.title !== 'Latency::ScrollUpdate') continue;
                const parentId = slice.args.data.INPUT_EVENT_LATENCY_FORWARD_SCROLL_UPDATE_TO_MAIN_COMPONENT.sequence_number;
                if (parentId === undefined) {
                    if (slice.start < gestureScrollUpdateStart || slice.start >= gestureScrollUpdateEnd) {
                        continue;
                    }
                } else {
                    if (parseInt(parentId) !== parseInt(this.id)) {
                        continue;
                    }
                }
                slice.associatedEvents.forEach(function (event) {
                    this.associatedEvents_.push(event);
                }, this);
                break;
            }
        }, belongToOtherInputs(slice, flowEvents) {
            let fromOtherInputs = false;
            slice.iterateEntireHierarchy(function (subsequentSlice) {
                if (fromOtherInputs) return;
                subsequentSlice.inFlowEvents.forEach(function (inflow) {
                    if (fromOtherInputs) return;
                    if (inflow.category.indexOf('input') > -1) {
                        if (flowEvents.indexOf(inflow) === -1) {
                            fromOtherInputs = true;
                        }
                    }
                }, this);
            }, this);
            return fromOtherInputs;
        }, triggerOtherInputs(event, flowEvents) {
            if (event.outFlowEvents === undefined || event.outFlowEvents.length === 0) {
                return false;
            }
            const flow = event.outFlowEvents[0];
            if (flow.category !== POSTTASK_FLOW_EVENT || !flow.endSlice) {
                return false;
            }
            const endSlice = flow.endSlice;
            if (this.belongToOtherInputs(endSlice.mostTopLevelSlice, flowEvents)) {
                return true;
            }
            return false;
        }, followSubsequentSlices(event, queue, visited, flowEvents) {
            let stopFollowing = false;
            let inputAck = false;
            event.iterateAllSubsequentSlices(function (slice) {
                if (stopFollowing) return;
                if (slice.title === 'TaskQueueManager::RunTask') return;
                if (slice.title === 'ThreadProxy::ScheduledActionSendBeginMainFrame') {
                    return;
                }
                if (slice.title === 'Scheduler::ScheduleBeginImplFrameDeadline') {
                    if (this.triggerOtherInputs(slice, flowEvents)) return;
                }
                if (slice.title === 'CompositorImpl::PostComposite') {
                    if (this.triggerOtherInputs(slice, flowEvents)) return;
                }
                if (slice.title === 'InputRouterImpl::ProcessInputEventAck') {
                    inputAck = true;
                }
                if (inputAck && slice.title === 'InputRouterImpl::FilterAndSendWebInputEvent') {
                    stopFollowing = true;
                }
                this.followCurrentSlice(slice, queue, visited);
            }, this);
        }, followCurrentSlice(event, queue, visited) {
            event.outFlowEvents.forEach(function (outflow) {
                if ((outflow.category === POSTTASK_FLOW_EVENT || outflow.category === IPC_FLOW_EVENT) && outflow.endSlice) {
                    this.associatedEvents_.push(outflow);
                    const nextEvent = outflow.endSlice.mostTopLevelSlice;
                    if (!visited.contains(nextEvent)) {
                        visited.push(nextEvent);
                        queue.push(nextEvent);
                    }
                }
            }, this);
        }, backtraceFromDraw(beginImplFrame, visited) {
            const pendingEventQueue = [];
            pendingEventQueue.push(beginImplFrame.mostTopLevelSlice);
            while (pendingEventQueue.length !== 0) {
                const event = pendingEventQueue.pop();
                this.addEntireSliceHierarchy(event);
                event.inFlowEvents.forEach(function (inflow) {
                    if (inflow.category === POSTTASK_FLOW_EVENT && inflow.startSlice) {
                        const nextEvent = inflow.startSlice.mostTopLevelSlice;
                        if (!visited.contains(nextEvent)) {
                            visited.push(nextEvent);
                            pendingEventQueue.push(nextEvent);
                        }
                    }
                }, this);
            }
        }, sortRasterizerSlices(rasterWorkerThreads, sortedRasterizerSlices) {
            rasterWorkerThreads.forEach(function (rasterizer) {
                Array.prototype.push.apply(sortedRasterizerSlices, rasterizer.sliceGroup.slices);
            }, this);
            sortedRasterizerSlices.sort(function (a, b) {
                if (a.start !== b.start) {
                    return a.start - b.start;
                }
                return a.guid - b.guid;
            });
        }, addRasterizationEvents(prepareTiles, rendererHelper, visited, flowEvents, sortedRasterizerSlices) {
            if (!prepareTiles.args.prepare_tiles_id) return;
            if (!rendererHelper || !rendererHelper.rasterWorkerThreads) {
                return;
            }
            const rasterWorkerThreads = rendererHelper.rasterWorkerThreads;
            const prepareTileId = prepareTiles.args.prepare_tiles_id;
            const pendingEventQueue = [];
            if (sortedRasterizerSlices.length === 0) {
                this.sortRasterizerSlices(rasterWorkerThreads, sortedRasterizerSlices);
            }
            let numFinishedTasks = 0;
            const RASTER_TASK_TITLE = 'RasterizerTaskImpl::RunOnWorkerThread';
            const IMAGEDECODE_TASK_TITLE = 'ImageDecodeTaskImpl::RunOnWorkerThread';
            const FINISHED_TASK_TITLE = 'TaskSetFinishedTaskImpl::RunOnWorkerThread';
            for (let i = 0; i < sortedRasterizerSlices.length; i++) {
                const task = sortedRasterizerSlices[i];
                if (task.title === RASTER_TASK_TITLE || task.title === IMAGEDECODE_TASK_TITLE) {
                    if (task.args.source_prepare_tiles_id === prepareTileId) {
                        this.addEntireSliceHierarchy(task.mostTopLevelSlice);
                    }
                } else if (task.title === FINISHED_TASK_TITLE) {
                    if (task.start > prepareTiles.start) {
                        pendingEventQueue.push(task.mostTopLevelSlice);
                        if (++numFinishedTasks === 3) break;
                    }
                }
            }
            while (pendingEventQueue.length !== 0) {
                const event = pendingEventQueue.pop();
                this.addEntireSliceHierarchy(event);
                this.followSubsequentSlices(event, pendingEventQueue, visited, flowEvents);
            }
        }, addOtherCausallyRelatedEvents(rendererHelper, sourceSlices, flowEvents, sortedRasterizerSlices) {
            const pendingEventQueue = [];
            const visitedEvents = new EventSet();
            let beginImplFrame = undefined;
            let prepareTiles = undefined;
            sortedRasterizerSlices = [];
            sourceSlices.forEach(function (sourceSlice) {
                if (!visitedEvents.contains(sourceSlice)) {
                    visitedEvents.push(sourceSlice);
                    pendingEventQueue.push(sourceSlice);
                }
            }, this);
            while (pendingEventQueue.length !== 0) {
                const event = pendingEventQueue.pop();
                this.addEntireSliceHierarchy(event);
                this.followCurrentSlice(event, pendingEventQueue, visitedEvents);
                this.followSubsequentSlices(event, pendingEventQueue, visitedEvents, flowEvents);
                const COMPOSITOR_PREPARE_TILES = 'TileManager::PrepareTiles';
                prepareTiles = event.findDescendentSlice(COMPOSITOR_PREPARE_TILES);
                if (prepareTiles) {
                    this.addRasterizationEvents(prepareTiles, rendererHelper, visitedEvents, flowEvents, sortedRasterizerSlices);
                }
                const COMPOSITOR_ON_BIFD = 'Scheduler::OnBeginImplFrameDeadline';
                beginImplFrame = event.findDescendentSlice(COMPOSITOR_ON_BIFD);
                if (beginImplFrame) {
                    this.backtraceFromDraw(beginImplFrame, visitedEvents);
                }
            }
            const INPUT_GSU = 'InputLatency::GestureScrollUpdate';
            if (this.title === INPUT_GSU) {
                this.addScrollUpdateEvents(rendererHelper);
            }
        }, get associatedEvents() {
            if (this.associatedEvents_.length !== 0) {
                return this.associatedEvents_;
            }
            const modelIndices = this.startThread.parent.model.modelIndices;
            const flowEvents = modelIndices.getFlowEventsWithId(this.id);
            if (flowEvents.length === 0) {
                return this.associatedEvents_;
            }
            const sourceSlices = this.addDirectlyAssociatedEvents(flowEvents);
            const rendererHelper = this.getRendererHelper(sourceSlices);
            this.addOtherCausallyRelatedEvents(rendererHelper, sourceSlices, flowEvents);
            return this.associatedEvents_;
        }, get inputLatency() {
            if (!('data' in this.args)) return undefined;
            const data = this.args.data;
            const endTimeComp = data[END_COMP_NAME] || data[LEGACY_END_COMP_NAME];
            if (endTimeComp === undefined) return undefined;
            let latency = 0;
            const endTime = endTimeComp.time;
            if (ORIGINAL_COMP_NAME in data) {
                latency = endTime - data[ORIGINAL_COMP_NAME].time;
            } else if (UI_COMP_NAME in data) {
                latency = endTime - data[UI_COMP_NAME].time;
            } else if (BEGIN_COMP_NAME in data) {
                latency = endTime - data[BEGIN_COMP_NAME].time;
            } else {
                throw new Error('No valid begin latency component');
            }
            return latency;
        }
    };
    const eventTypeNames = ['Char', 'ContextMenu', 'GestureClick', 'GestureFlingCancel', 'GestureFlingStart', 'GestureScrollBegin', 'GestureScrollEnd', 'GestureScrollUpdate', 'GestureShowPress', 'GestureTap', 'GestureTapCancel', 'GestureTapDown', 'GesturePinchBegin', 'GesturePinchEnd', 'GesturePinchUpdate', 'KeyDown', 'KeyUp', 'MouseDown', 'MouseEnter', 'MouseLeave', 'MouseMove', 'MouseUp', 'MouseWheel', 'RawKeyDown', 'ScrollUpdate', 'TouchCancel', 'TouchEnd', 'TouchMove', 'TouchStart'];
    const allTypeNames = ['InputLatency'];
    eventTypeNames.forEach(function (eventTypeName) {
        allTypeNames.push('InputLatency:' + eventTypeName);
        allTypeNames.push('InputLatency::' + eventTypeName);
    });
    AsyncSlice.subTypes.register(InputLatencyAsyncSlice, {typeNames: allTypeNames, categoryParts: ['latencyInfo']});
    return {InputLatencyAsyncSlice, INPUT_EVENT_TYPE_NAMES,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const SAME_AS_PARENT = 'same-as-parent';
    const TITLES_FOR_USER_FRIENDLY_CATEGORY = {
        composite: ['CompositingInputsUpdater::update', 'ThreadProxy::SetNeedsUpdateLayers', 'LayerTreeHost::DoUpdateLayers', 'LayerTreeHost::UpdateLayers::BuildPropertyTrees', 'LocalFrameView::pushPaintArtifactToCompositor', 'LocalFrameView::updateCompositedSelectionIfNeeded', 'LocalFrameView::RunCompositingLifecyclePhase', 'UpdateLayerTree',],
        gc: ['minorGC', 'majorGC', 'MajorGC', 'MinorGC', 'V8.GCScavenger', 'V8.GCIncrementalMarking', 'V8.GCIdleNotification', 'V8.GCContext', 'V8.GCCompactor', 'V8GCController::traceDOMWrappers',],
        iframe_creation: ['WebLocalFrameImpl::createChildframe',],
        imageDecode: ['Decode Image', 'ImageFrameGenerator::decode', 'ImageFrameGenerator::decodeAndScale', 'ImageFrameGenerator::decodeToYUV', 'ImageResourceContent::updateImage',],
        input: ['HitTest', 'ScrollableArea::scrollPositionChanged', 'EventHandler::handleMouseMoveEvent',],
        layout: ['IntersectionObserverController::computeTrackedIntersectionObservations', 'LocalFrameView::invalidateTree', 'LocalFrameView::layout', 'LocalFrameView::performLayout', 'LocalFrameView::performPostLayoutTasks', 'LocalFrameView::performPreLayoutTasks', 'LocalFrameView::RunStyleAndLayoutCompositingPhases', 'Layout', 'PaintLayer::updateLayerPositionsAfterLayout', 'ResourceLoadPriorityOptimizer::updateAllImageResourcePriorities', 'WebViewImpl::updateAllLifecyclePhases', 'WebViewImpl::beginFrame',],
        parseHTML: ['BackgroundHTMLParser::pumpTokenizer', 'BackgroundHTMLParser::sendTokensToMainThread', 'HTMLDocumentParser::didReceiveParsedChunkFromBackgroundParser', 'HTMLDocumentParser::documentElementAvailable', 'HTMLDocumentParser::notifyPendingTokenizedChunks', 'HTMLDocumentParser::processParsedChunkFromBackgroundParser', 'HTMLDocumentParser::processTokenizedChunkFromBackgroundParser', 'ParseHTML',],
        raster: ['DisplayListRasterSource::PerformSolidColorAnalysis', 'Picture::Raster', 'RasterBufferImpl::Playback', 'RasterTask', 'RasterizerTaskImpl::RunOnWorkerThread', 'SkCanvas::drawImageRect()', 'SkCanvas::drawPicture()', 'SkCanvas::drawTextBlob()', 'TileTaskWorkerPool::PlaybackToMemory',],
        record: ['Canvas2DLayerBridge::flushRecordingOnly', 'CompositingInputsUpdater::update', 'CompositingRequirementsUpdater::updateRecursive', 'ContentLayerDelegate::paintContents', 'DisplayItemList::Finalize', 'LocalFrameView::RunPaintLifecyclePhase', 'LocalFrameView::RunPrePaintLifecyclePhase', 'Paint', 'PaintController::commitNewDisplayItems', 'PaintLayerCompositor::updateIfNeededRecursive', 'Picture::Record', 'PictureLayer::Update',],
        style: ['CSSParserImpl::parseStyleSheet.parse', 'CSSParserImpl::parseStyleSheet.tokenize', 'Document::rebuildLayoutTree', 'Document::recalcStyle', 'Document::updateActiveStyle', 'Document::updateStyle', 'Document::updateStyleInvalidationIfNeeded', 'LocalFrameView::updateStyleAndLayoutIfNeededRecursive', 'ParseAuthorStyleSheet', 'RuleSet::addRulesFromSheet', 'StyleElement::processStyleSheet', 'StyleEngine::createResolver', 'StyleEngine::updateActiveStyleSheets', 'StyleSheetContents::parseAuthorStyleSheet', 'UpdateLayoutTree',],
        script_parse_and_compile: ['V8.CompileFullCode', 'V8.NewContext', 'V8.Parse', 'V8.ParseLazy', 'V8.RecompileSynchronous', 'V8.ScriptCompiler', 'v8.compile', 'v8.parseOnBackground',],
        script_execute: ['EvaluateScript', 'FunctionCall', 'HTMLParserScriptRunner ExecuteScript', 'V8.Execute', 'V8.RunMicrotasks', 'V8.Task', 'WindowProxy::initialize', 'v8.callFunction', 'v8.run',],
        resource_loading: ['RenderFrameImpl::didFinishDocumentLoad', 'RenderFrameImpl::didFinishLoad', 'Resource::appendData', 'ResourceDispatcher::OnReceivedData', 'ResourceDispatcher::OnReceivedResponse', 'ResourceDispatcher::OnRequestComplete', 'ResourceFetcher::requestResource', 'WebURLLoaderImpl::Context::Cancel', 'WebURLLoaderImpl::Context::OnCompletedRequest', 'WebURLLoaderImpl::Context::OnReceivedData', 'WebURLLoaderImpl::Context::OnReceivedRedirect', 'WebURLLoaderImpl::Context::OnReceivedResponse', 'WebURLLoaderImpl::Context::Start', 'WebURLLoaderImpl::loadAsynchronously', 'WebURLLoaderImpl::loadSynchronously', 'content::mojom::URLLoaderClient',],
        renderer_misc: ['DecodeFont', 'ThreadState::completeSweep',],
        v8_runtime: [],
        [SAME_AS_PARENT]: ['SyncChannel::Send',]
    };
    const COLOR_FOR_USER_FRIENDLY_CATEGORY = new tr.b.SinebowColorGenerator();
    const USER_FRIENDLY_CATEGORY_FOR_TITLE = new Map();
    for (const category in TITLES_FOR_USER_FRIENDLY_CATEGORY) {
        TITLES_FOR_USER_FRIENDLY_CATEGORY[category].forEach(function (title) {
            USER_FRIENDLY_CATEGORY_FOR_TITLE.set(title, category);
        });
    }
    const USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY = {
        netlog: 'net',
        overhead: 'overhead',
        startup: 'startup',
        gpu: 'gpu',
    };

    function ChromeUserFriendlyCategoryDriver() {
    }

    ChromeUserFriendlyCategoryDriver.fromEvent = function (event) {
        let userFriendlyCategory = USER_FRIENDLY_CATEGORY_FOR_TITLE.get(event.title);
        if (userFriendlyCategory) {
            if (userFriendlyCategory === SAME_AS_PARENT) {
                if (event.parentSlice) {
                    return ChromeUserFriendlyCategoryDriver.fromEvent(event.parentSlice);
                }
            } else {
                return userFriendlyCategory;
            }
        }
        const eventCategoryParts = tr.b.getCategoryParts(event.category);
        for (let i = 0; i < eventCategoryParts.length; ++i) {
            const eventCategory = eventCategoryParts[i];
            userFriendlyCategory = USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY[eventCategory];
            if (userFriendlyCategory) {
                return userFriendlyCategory;
            }
        }
        return 'other';
    };
    ChromeUserFriendlyCategoryDriver.getColor = function (ufc) {
        return COLOR_FOR_USER_FRIENDLY_CATEGORY.colorForKey(ufc);
    };
    ChromeUserFriendlyCategoryDriver.ALL_TITLES = ['other'];
    for (const category in TITLES_FOR_USER_FRIENDLY_CATEGORY) {
        if (category === SAME_AS_PARENT) continue;
        ChromeUserFriendlyCategoryDriver.ALL_TITLES.push(category);
    }
    for (const category of Object.values(USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY)) {
        ChromeUserFriendlyCategoryDriver.ALL_TITLES.push(category);
    }
    ChromeUserFriendlyCategoryDriver.ALL_TITLES.sort();
    for (const category of ChromeUserFriendlyCategoryDriver.ALL_TITLES) {
        ChromeUserFriendlyCategoryDriver.getColor(category);
    }
    return {ChromeUserFriendlyCategoryDriver,};
});
'use strict';
tr.exportTo('tr.model', function () {
    return {
        BROWSER_PROCESS_PID_REF: -1,
        OBJECT_DEFAULT_SCOPE: 'ptr',
        LOCAL_ID_PHASES: new Set(['N', 'D', 'O', '(', ')'])
    };
});
'use strict';
tr.exportTo('tr.e.audits', function () {
    const Auditor = tr.c.Auditor;
    const Alert = tr.model.Alert;
    const EventInfo = tr.model.EventInfo;

    function ChromeAuditor(model) {
        Auditor.call(this, model);
        const modelHelper = this.model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
        if (modelHelper && modelHelper.browserHelper) {
            this.modelHelper = modelHelper;
        } else {
            this.modelHelper = undefined;
        }
    }

    function getMissedFrameAlerts(rendererHelpers) {
        const alerts = [];
        for (const rendererHelper of rendererHelpers) {
            if (!rendererHelper.compositorThread) continue;
            const thread = rendererHelper.compositorThread;
            const asyncSlices = Object.values(thread.asyncSliceGroup.slices);
            for (const slice of asyncSlices) {
                if (slice.title !== 'PipelineReporter' || !slice.args.termination_status || slice.args.termination_status !== 'missed_frame') continue;
                const alertSlices = [slice].concat(slice.subSlices);
                alerts.push(new Alert(new EventInfo('Missed Frame', 'Frame was not submitted before deadline.'), slice.start, alertSlices));
            }
        }
        return alerts;
    }

    ChromeAuditor.prototype = {
        __proto__: Auditor.prototype, runAnnotate() {
            if (!this.modelHelper) return;
            for (const pid in this.modelHelper.rendererHelpers) {
                const rendererHelper = this.modelHelper.rendererHelpers[pid];
                if (rendererHelper.isChromeTracingUI) {
                    rendererHelper.process.important = false;
                }
            }
        }, installUserFriendlyCategoryDriverIfNeeded() {
            this.model.addUserFriendlyCategoryDriver(tr.e.chrome.ChromeUserFriendlyCategoryDriver);
        }, runAudit() {
            if (!this.modelHelper) return;
            this.model.replacePIDRefsInPatchups(tr.model.BROWSER_PROCESS_PID_REF, this.modelHelper.browserProcess.pid);
            this.model.applyObjectRefPatchups();
            const alerts = getMissedFrameAlerts(Object.values(this.modelHelper.rendererHelpers));
            this.model.alerts = this.model.alerts.concat(alerts);
        }
    };
    Auditor.register(ChromeAuditor);
    return {ChromeAuditor,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const KNOWN_PROPERTIES = {
        absX: 1,
        absY: 1,
        address: 1,
        anonymous: 1,
        childNeeds: 1,
        children: 1,
        classNames: 1,
        col: 1,
        colSpan: 1,
        float: 1,
        height: 1,
        htmlId: 1,
        name: 1,
        posChildNeeds: 1,
        positioned: 1,
        positionedMovement: 1,
        relX: 1,
        relY: 1,
        relativePositioned: 1,
        row: 1,
        rowSpan: 1,
        selfNeeds: 1,
        stickyPositioned: 1,
        tag: 1,
        width: 1
    };

    function LayoutObject(snapshot, args) {
        this.snapshot_ = snapshot;
        this.id_ = args.address;
        this.name_ = args.name;
        this.childLayoutObjects_ = [];
        this.otherProperties_ = {};
        this.tag_ = args.tag;
        this.relativeRect_ = tr.b.math.Rect.fromXYWH(args.relX, args.relY, args.width, args.height);
        this.absoluteRect_ = tr.b.math.Rect.fromXYWH(args.absX, args.absY, args.width, args.height);
        this.isFloat_ = args.float;
        this.isStickyPositioned_ = args.stickyPositioned;
        this.isPositioned_ = args.positioned;
        this.isRelativePositioned_ = args.relativePositioned;
        this.isAnonymous_ = args.anonymous;
        this.htmlId_ = args.htmlId;
        this.classNames_ = args.classNames;
        this.needsLayoutReasons_ = [];
        if (args.selfNeeds) {
            this.needsLayoutReasons_.push('self');
        }
        if (args.childNeeds) {
            this.needsLayoutReasons_.push('child');
        }
        if (args.posChildNeeds) {
            this.needsLayoutReasons_.push('positionedChild');
        }
        if (args.positionedMovement) {
            this.needsLayoutReasons_.push('positionedMovement');
        }
        this.tableRow_ = args.row;
        this.tableCol_ = args.col;
        this.tableRowSpan_ = args.rowSpan;
        this.tableColSpan_ = args.colSpan;
        if (args.children) {
            args.children.forEach(function (child) {
                this.childLayoutObjects_.push(new LayoutObject(snapshot, child));
            }.bind(this));
        }
        for (const property in args) {
            if (!KNOWN_PROPERTIES[property]) {
                this.otherProperties_[property] = args[property];
            }
        }
    }

    LayoutObject.prototype = {
        get snapshot() {
            return this.snapshot_;
        }, get id() {
            return this.id_;
        }, get name() {
            return this.name_;
        }, get tag() {
            return this.tag_;
        }, get relativeRect() {
            return this.relativeRect_;
        }, get absoluteRect() {
            return this.absoluteRect_;
        }, get isPositioned() {
            return this.isPositioned_;
        }, get isFloat() {
            return this.isFloat_;
        }, get isStickyPositioned() {
            return this.isStickyPositioned_;
        }, get isRelativePositioned() {
            return this.isRelativePositioned_;
        }, get isAnonymous() {
            return this.isAnonymous_;
        }, get tableRow() {
            return this.tableRow_;
        }, get tableCol() {
            return this.tableCol_;
        }, get tableRowSpan() {
            return this.tableRowSpan_;
        }, get tableColSpan() {
            return this.tableColSpan_;
        }, get htmlId() {
            return this.htmlId_;
        }, get classNames() {
            return this.classNames_;
        }, get needsLayoutReasons() {
            return this.needsLayoutReasons_;
        }, get hasChildLayoutObjects() {
            return this.childLayoutObjects_.length > 0;
        }, get childLayoutObjects() {
            return this.childLayoutObjects_;
        }, traverseTree(cb, opt_this) {
            cb.call(opt_this, this);
            if (!this.hasChildLayoutObjects) return;
            this.childLayoutObjects.forEach(function (child) {
                child.traverseTree(cb, opt_this);
            });
        }, get otherPropertyNames() {
            const names = [];
            for (const name in this.otherProperties_) {
                names.push(name);
            }
            return names;
        }, getProperty(name) {
            return this.otherProperties_[name];
        }, get previousSnapshotLayoutObject() {
            if (!this.snapshot.previousSnapshot) return undefined;
            return this.snapshot.previousSnapshot.getLayoutObjectById(this.id);
        }, get nextSnapshotLayoutObject() {
            if (!this.snapshot.nextSnapshot) return undefined;
            return this.snapshot.nextSnapshot.getLayoutObjectById(this.id);
        }
    };
    return {LayoutObject,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const ObjectSnapshot = tr.model.ObjectSnapshot;
    const ObjectInstance = tr.model.ObjectInstance;

    function LayoutTreeInstance() {
        ObjectInstance.apply(this, arguments);
    }

    LayoutTreeInstance.prototype = {__proto__: ObjectInstance.prototype,};
    ObjectInstance.subTypes.register(LayoutTreeInstance, {typeName: 'LayoutTree'});

    function LayoutTreeSnapshot() {
        ObjectSnapshot.apply(this, arguments);
        this.rootLayoutObject = new tr.e.chrome.LayoutObject(this, this.args);
    }

    LayoutTreeSnapshot.prototype = {__proto__: ObjectSnapshot.prototype,};
    ObjectSnapshot.subTypes.register(LayoutTreeSnapshot, {typeName: 'LayoutTree'});
    return {LayoutTreeInstance, LayoutTreeSnapshot,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function EventContainer() {
        this.guid_ = tr.b.GUID.allocateSimple();
        this.important = true;
        this.bounds_ = new tr.b.math.Range();
    }

    EventContainer.prototype = {
        get guid() {
            return this.guid_;
        }, get stableId() {
            throw new Error('Not implemented');
        }, get bounds() {
            return this.bounds_;
        }, updateBounds() {
            throw new Error('Not implemented');
        }, shiftTimestampsForward(amount) {
            throw new Error('Not implemented');
        }, * childEvents() {
        }, * getDescendantEvents() {
            yield* this.childEvents();
            for (const container of this.childEventContainers()) {
                yield* container.getDescendantEvents();
            }
        }, * childEventContainers() {
        }, * getDescendantEventContainers() {
            yield this;
            for (const container of this.childEventContainers()) {
                yield* container.getDescendantEventContainers();
            }
        }, * getDescendantEventsInSortedRanges(ranges, opt_containerPredicate) {
            if (opt_containerPredicate === undefined || opt_containerPredicate(this)) {
                for (const event of this.childEvents()) {
                    const i = tr.b.findFirstTrueIndexInSortedArray(ranges, range => event.start <= range.max);
                    if (i < ranges.length && event.end >= ranges[i].min) yield event;
                }
            }
            for (const container of this.childEventContainers()) {
                yield* container.getDescendantEventsInSortedRanges(ranges, opt_containerPredicate);
            }
        }, * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
        }, * findTopmostSlices(eventPredicate) {
            for (const ec of this.getDescendantEventContainers()) {
                yield* ec.findTopmostSlicesInThisContainer(eventPredicate);
            }
        }, * findTopmostSlicesNamed(name) {
            yield* this.findTopmostSlices(e => e.title === name);
        }
    };
    return {EventContainer,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Event = tr.model.Event;
    const EventRegistry = tr.model.EventRegistry;

    class ResourceUsageSample extends Event {
        constructor(series, start, usage) {
            super();
            this.series_ = series;
            this.start_ = start;
            this.usage_ = usage;
        }

        get series() {
            return this.series_;
        }

        get start() {
            return this.start_;
        }

        set start(value) {
            this.start_ = value;
        }

        get usage() {
            return this.usage_;
        }

        set usage(value) {
            this.usage_ = value;
        }

        addBoundsToRange(range) {
            range.addValue(this.start);
        }
    }

    EventRegistry.register(ResourceUsageSample, {name: 'resourceUsageSample', pluralName: 'resourceUsageSamples'});
    return {ResourceUsageSample,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ResourceUsageSample = tr.model.ResourceUsageSample;

    class ResourceUsageSeries extends tr.model.EventContainer {
        constructor(device) {
            super();
            this.device_ = device;
            this.samples_ = [];
        }

        get device() {
            return this.device_;
        }

        get samples() {
            return this.samples_;
        }

        get stableId() {
            return this.device_.stableId + '.ResourceUsageSeries';
        }

        addUsageSample(ts, val) {
            const sample = new ResourceUsageSample(this, ts, val);
            this.samples_.push(sample);
            return sample;
        }

        computeResourceTimeConsumedInMs(start, end) {
            const measurementRange = tr.b.math.Range.fromExplicitRange(start, end);
            let resourceTimeInMs = 0;
            let startIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, start) - 1;
            const endIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, end);
            if (startIndex < 0) startIndex = 0;
            for (let i = startIndex; i < endIndex; i++) {
                const sample = this.samples[i];
                const nextSample = this.samples[i + 1];
                const sampleRange = new tr.b.math.Range();
                sampleRange.addValue(sample.start);
                sampleRange.addValue(nextSample ? nextSample.start : sample.start);
                const intersectionRangeInMs = measurementRange.findIntersection(sampleRange);
                resourceTimeInMs += intersectionRangeInMs.duration * sample.usage;
            }
            return resourceTimeInMs;
        }

        getSamplesWithinRange(start, end) {
            const startIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, start);
            const endIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, end);
            return this.samples.slice(startIndex, endIndex);
        }

        shiftTimestampsForward(amount) {
            for (let i = 0; i < this.samples_.length; ++i) {
                this.samples_[i].start += amount;
            }
        }

        updateBounds() {
            this.bounds.reset();
            if (this.samples_.length === 0) return;
            this.bounds.addValue(this.samples_[0].start);
            this.bounds.addValue(this.samples_[this.samples_.length - 1].start);
        }

        * childEvents() {
            yield* this.samples_;
        }
    }

    return {ResourceUsageSeries,};
});
'use strict';
tr.exportTo('tr.e.audits', function () {
    class CpuUsageAuditor extends tr.c.Auditor {
        constructor(model) {
            super();
            this.model_ = model;
        }

        runAnnotate() {
            this.model_.device.cpuUsageSeries = this.computeCpuUsageSeries_(this.model_.bounds.min, this.model_.bounds.max, this.computeCpuUsage_());
        }

        computeBinSize_(start, end) {
            const MIN_BIN_SIZE_MS = 1.0;
            const MAX_NUM_BINS = 100000;
            const interval = end - start;
            let binSize = MIN_BIN_SIZE_MS;
            while (binSize * MAX_NUM_BINS < interval) binSize *= 2;
            return binSize;
        }

        computeCpuUsageSeries_(start, end, usageRecords) {
            const series = new tr.model.ResourceUsageSeries();
            if (start === undefined || usageRecords.length === 0) return series;
            const binSize = this.computeBinSize_(start, end);
            const numBins = Math.ceil((end - start) / binSize);
            const arr = new Array(numBins).fill(0);
            for (const record of usageRecords) {
                const firstIndex = Math.ceil((record.start - start) / binSize);
                const lastIndex = Math.floor((record.end - start) / binSize);
                for (let i = firstIndex; i <= lastIndex; i++) arr[i] += record.usage;
            }
            for (let i = 0; i < numBins; i++) {
                series.addUsageSample(start + (i * binSize), arr[i]);
            }
            return series;
        }

        computeCpuUsage_() {
            const model = this.model_;
            const result = [];
            for (const pid in model.processes) {
                for (const e of model.processes[pid].getDescendantEvents()) {
                    if (!(e instanceof tr.model.ThreadSlice) || e.duration === 0 || e.cpuDuration === undefined) {
                        continue;
                    }
                    if (e.selfTime === 0 || e.selfTime === undefined || e.cpuSelfTime === undefined) {
                        continue;
                    }
                    const usage = tr.b.math.clamp(e.cpuSelfTime / e.selfTime, 0, 1);
                    let lastTime = e.start;
                    for (const subslice of e.subSlices) {
                        result.push({usage, start: lastTime, end: subslice.start});
                        lastTime = subslice.end;
                    }
                    result.push({usage, start: lastTime, end: e.end});
                }
            }
            return result;
        }
    }

    tr.c.Auditor.register(CpuUsageAuditor);
    return {CpuUsageAuditor};
});
'use strict';
tr.exportTo('tr.b', function () {
    function Base64() {
    }

    function b64ToUint6(nChr) {
        if (nChr > 64 && nChr < 91) return nChr - 65;
        if (nChr > 96 && nChr < 123) return nChr - 71;
        if (nChr > 47 && nChr < 58) return nChr + 4;
        if (nChr === 43) return 62;
        if (nChr === 47) return 63;
        return 0;
    }

    Base64.getDecodedBufferLength = function (input) {
        let pad = 0;
        if (input.substr(-2) === '==') {
            pad = 2;
        } else if (input.substr(-1) === '=') {
            pad = 1;
        }
        return ((input.length * 3 + 1) >> 2) - pad;
    };
    Base64.EncodeArrayBufferToString = function (input) {
        let binary = '';
        const bytes = new Uint8Array(input);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    };
    Base64.DecodeToTypedArray = function (input, output) {
        const nInLen = input.length;
        const nOutLen = Base64.getDecodedBufferLength(input);
        let nMod3 = 0;
        let nMod4 = 0;
        let nUint24 = 0;
        let nOutIdx = 0;
        if (nOutLen > output.byteLength) {
            throw new Error('Output buffer too small to decode.');
        }
        for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
            nMod4 = nInIdx & 3;
            nUint24 |= b64ToUint6(input.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
            if (nMod4 === 3 || nInLen - nInIdx === 1) {
                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                    output.setUint8(nOutIdx, nUint24 >>> (16 >>> nMod3 & 24) & 255);
                }
                nUint24 = 0;
            }
        }
        return nOutLen;
    };
    Base64.btoa = function (input) {
        return btoa(input);
    };
    Base64.atob = function (input) {
        return atob(input);
    };
    return {Base64,};
});
'use strict';
tr.exportTo('tr.e.importer.etw', function () {
    function Parser(importer) {
        this.importer = importer;
        this.model = importer.model;
    }

    Parser.prototype = {__proto__: Object.prototype};
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    options.mandatoryBaseClass = Parser;
    tr.b.decorateExtensionRegistry(Parser, options);
    return {Parser,};
});
'use strict';
tr.exportTo('tr.e.importer.etw', function () {
    const Parser = tr.e.importer.etw.Parser;
    const guid = '68FDD900-4A3E-11D1-84F4-0000F80464E3';
    const kEventTraceHeaderOpcode = 0;

    function EventTraceParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler(guid, kEventTraceHeaderOpcode, EventTraceParser.prototype.decodeHeader.bind(this));
    }

    EventTraceParser.prototype = {
        __proto__: Parser.prototype, decodeFields(header, decoder) {
            if (header.version !== 2) {
                throw new Error('Incompatible EventTrace event version.');
            }
            const bufferSize = decoder.decodeUInt32();
            const version = decoder.decodeUInt32();
            const providerVersion = decoder.decodeUInt32();
            const numberOfProcessors = decoder.decodeUInt32();
            const endTime = decoder.decodeUInt64ToString();
            const timerResolution = decoder.decodeUInt32();
            const maxFileSize = decoder.decodeUInt32();
            const logFileMode = decoder.decodeUInt32();
            const buffersWritten = decoder.decodeUInt32();
            const startBuffers = decoder.decodeUInt32();
            const pointerSize = decoder.decodeUInt32();
            const eventsLost = decoder.decodeUInt32();
            const cpuSpeed = decoder.decodeUInt32();
            const loggerName = decoder.decodeUInteger(header.is64);
            const logFileName = decoder.decodeUInteger(header.is64);
            const timeZoneInformation = decoder.decodeTimeZoneInformation();
            const padding = decoder.decodeUInt32();
            const bootTime = decoder.decodeUInt64ToString();
            const perfFreq = decoder.decodeUInt64ToString();
            const startTime = decoder.decodeUInt64ToString();
            const reservedFlags = decoder.decodeUInt32();
            const buffersLost = decoder.decodeUInt32();
            const sessionNameString = decoder.decodeW16String();
            const logFileNameString = decoder.decodeW16String();
            return {
                bufferSize,
                version,
                providerVersion,
                numberOfProcessors,
                endTime,
                timerResolution,
                maxFileSize,
                logFileMode,
                buffersWritten,
                startBuffers,
                pointerSize,
                eventsLost,
                cpuSpeed,
                loggerName,
                logFileName,
                timeZoneInformation,
                bootTime,
                perfFreq,
                startTime,
                reservedFlags,
                buffersLost,
                sessionNameString,
                logFileNameString
            };
        }, decodeHeader(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            return true;
        }
    };
    Parser.register(EventTraceParser);
    return {EventTraceParser,};
});
'use strict';
tr.exportTo('tr.e.importer.etw', function () {
    const Parser = tr.e.importer.etw.Parser;
    const guid = '3D6FA8D0-FE05-11D0-9DDA-00C04FD7BA7C';
    const kProcessStartOpcode = 1;
    const kProcessEndOpcode = 2;
    const kProcessDCStartOpcode = 3;
    const kProcessDCEndOpcode = 4;
    const kProcessDefunctOpcode = 39;

    function ProcessParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler(guid, kProcessStartOpcode, ProcessParser.prototype.decodeStart.bind(this));
        importer.registerEventHandler(guid, kProcessEndOpcode, ProcessParser.prototype.decodeEnd.bind(this));
        importer.registerEventHandler(guid, kProcessDCStartOpcode, ProcessParser.prototype.decodeDCStart.bind(this));
        importer.registerEventHandler(guid, kProcessDCEndOpcode, ProcessParser.prototype.decodeDCEnd.bind(this));
        importer.registerEventHandler(guid, kProcessDefunctOpcode, ProcessParser.prototype.decodeDefunct.bind(this));
    }

    ProcessParser.prototype = {
        __proto__: Parser.prototype, decodeFields(header, decoder) {
            if (header.version > 5) {
                throw new Error('Incompatible Process event version.');
            }
            let pageDirectoryBase;
            if (header.version === 1) {
                pageDirectoryBase = decoder.decodeUInteger(header.is64);
            }
            let uniqueProcessKey;
            if (header.version >= 2) {
                uniqueProcessKey = decoder.decodeUInteger(header.is64);
            }
            const processId = decoder.decodeUInt32();
            const parentId = decoder.decodeUInt32();
            let sessionId;
            let exitStatus;
            if (header.version >= 1) {
                sessionId = decoder.decodeUInt32();
                exitStatus = decoder.decodeInt32();
            }
            let directoryTableBase;
            if (header.version >= 3) {
                directoryTableBase = decoder.decodeUInteger(header.is64);
            }
            let flags;
            if (header.version >= 4) {
                flags = decoder.decodeUInt32();
            }
            const userSID = decoder.decodeSID(header.is64);
            let imageFileName;
            if (header.version >= 1) {
                imageFileName = decoder.decodeString();
            }
            let commandLine;
            if (header.version >= 2) {
                commandLine = decoder.decodeW16String();
            }
            let packageFullName;
            let applicationId;
            if (header.version >= 4) {
                packageFullName = decoder.decodeW16String();
                applicationId = decoder.decodeW16String();
            }
            let exitTime;
            if (header.version === 5 && header.opcode === kProcessDefunctOpcode) {
                exitTime = decoder.decodeUInt64ToString();
            }
            return {
                pageDirectoryBase,
                uniqueProcessKey,
                processId,
                parentId,
                sessionId,
                exitStatus,
                directoryTableBase,
                flags,
                userSID,
                imageFileName,
                commandLine,
                packageFullName,
                applicationId,
                exitTime
            };
        }, decodeStart(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            const process = this.model.getOrCreateProcess(fields.processId);
            if (process.hasOwnProperty('has_ended')) {
                throw new Error('Process clash detected.');
            }
            process.name = fields.imageFileName;
            return true;
        }, decodeEnd(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            const process = this.model.getOrCreateProcess(fields.processId);
            process.has_ended = true;
            return true;
        }, decodeDCStart(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            const process = this.model.getOrCreateProcess(fields.processId);
            if (process.hasOwnProperty('has_ended')) {
                throw new Error('Process clash detected.');
            }
            process.name = fields.imageFileName;
            return true;
        }, decodeDCEnd(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            const process = this.model.getOrCreateProcess(fields.processId);
            process.has_ended = true;
            return true;
        }, decodeDefunct(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            return true;
        }
    };
    Parser.register(ProcessParser);
    return {ProcessParser,};
});
'use strict';
tr.exportTo('tr.e.importer.etw', function () {
    const Parser = tr.e.importer.etw.Parser;
    const guid = '3D6FA8D1-FE05-11D0-9DDA-00C04FD7BA7C';
    const kThreadStartOpcode = 1;
    const kThreadEndOpcode = 2;
    const kThreadDCStartOpcode = 3;
    const kThreadDCEndOpcode = 4;
    const kThreadCSwitchOpcode = 36;

    function ThreadParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler(guid, kThreadStartOpcode, ThreadParser.prototype.decodeStart.bind(this));
        importer.registerEventHandler(guid, kThreadEndOpcode, ThreadParser.prototype.decodeEnd.bind(this));
        importer.registerEventHandler(guid, kThreadDCStartOpcode, ThreadParser.prototype.decodeDCStart.bind(this));
        importer.registerEventHandler(guid, kThreadDCEndOpcode, ThreadParser.prototype.decodeDCEnd.bind(this));
        importer.registerEventHandler(guid, kThreadCSwitchOpcode, ThreadParser.prototype.decodeCSwitch.bind(this));
    }

    ThreadParser.prototype = {
        __proto__: Parser.prototype, decodeFields(header, decoder) {
            if (header.version > 3) {
                throw new Error('Incompatible Thread event version ' +
                    header.version + '.');
            }
            const processId = decoder.decodeUInt32();
            const threadId = decoder.decodeUInt32();
            let stackBase;
            let stackLimit;
            let userStackBase;
            let userStackLimit;
            let affinity;
            let startAddr;
            let win32StartAddr;
            let tebBase;
            let subProcessTag;
            let basePriority;
            let pagePriority;
            let ioPriority;
            let threadFlags;
            let waitMode;
            if (header.version === 1) {
                if (header.opcode === kThreadStartOpcode || header.opcode === kThreadDCStartOpcode) {
                    stackBase = decoder.decodeUInteger(header.is64);
                    stackLimit = decoder.decodeUInteger(header.is64);
                    userStackBase = decoder.decodeUInteger(header.is64);
                    userStackLimit = decoder.decodeUInteger(header.is64);
                    startAddr = decoder.decodeUInteger(header.is64);
                    win32StartAddr = decoder.decodeUInteger(header.is64);
                    waitMode = decoder.decodeInt8();
                    decoder.skip(3);
                }
            } else {
                stackBase = decoder.decodeUInteger(header.is64);
                stackLimit = decoder.decodeUInteger(header.is64);
                userStackBase = decoder.decodeUInteger(header.is64);
                userStackLimit = decoder.decodeUInteger(header.is64);
                if (header.version === 2) {
                    startAddr = decoder.decodeUInteger(header.is64);
                } else {
                    affinity = decoder.decodeUInteger(header.is64);
                }
                win32StartAddr = decoder.decodeUInteger(header.is64);
                tebBase = decoder.decodeUInteger(header.is64);
                subProcessTag = decoder.decodeUInt32();
                if (header.version === 3) {
                    basePriority = decoder.decodeUInt8();
                    pagePriority = decoder.decodeUInt8();
                    ioPriority = decoder.decodeUInt8();
                    threadFlags = decoder.decodeUInt8();
                }
            }
            return {
                processId,
                threadId,
                stackBase,
                stackLimit,
                userStackBase,
                userStackLimit,
                affinity,
                startAddr,
                win32StartAddr,
                tebBase,
                subProcessTag,
                waitMode,
                basePriority,
                pagePriority,
                ioPriority,
                threadFlags
            };
        }, decodeCSwitchFields(header, decoder) {
            if (header.version < 2 || header.version > 4) {
                throw new Error('Incompatible cswitch event version ' +
                    header.version + '.');
            }
            const newThreadId = decoder.decodeUInt32();
            const oldThreadId = decoder.decodeUInt32();
            const newThreadPriority = decoder.decodeInt8();
            const oldThreadPriority = decoder.decodeInt8();
            const previousCState = decoder.decodeUInt8();
            const spareByte = decoder.decodeInt8();
            const oldThreadWaitReason = decoder.decodeInt8();
            const oldThreadWaitMode = decoder.decodeInt8();
            const oldThreadState = decoder.decodeInt8();
            const oldThreadWaitIdealProcessor = decoder.decodeInt8();
            const newThreadWaitTime = decoder.decodeUInt32();
            const reserved = decoder.decodeUInt32();
            return {
                newThreadId,
                oldThreadId,
                newThreadPriority,
                oldThreadPriority,
                previousCState,
                spareByte,
                oldThreadWaitReason,
                oldThreadWaitMode,
                oldThreadState,
                oldThreadWaitIdealProcessor,
                newThreadWaitTime,
                reserved
            };
        }, decodeStart(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            this.importer.createThreadIfNeeded(fields.processId, fields.threadId);
            return true;
        }, decodeEnd(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            this.importer.removeThreadIfPresent(fields.threadId);
            return true;
        }, decodeDCStart(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            this.importer.createThreadIfNeeded(fields.processId, fields.threadId);
            return true;
        }, decodeDCEnd(header, decoder) {
            const fields = this.decodeFields(header, decoder);
            this.importer.removeThreadIfPresent(fields.threadId);
            return true;
        }, decodeCSwitch(header, decoder) {
            const fields = this.decodeCSwitchFields(header, decoder);
            const cpu = this.importer.getOrCreateCpu(header.cpu);
            const newThread = this.importer.getThreadFromWindowsTid(fields.newThreadId);
            let newThreadName;
            if (newThread && newThread.userFriendlyName) {
                newThreadName = newThread.userFriendlyName;
            } else {
                const newProcessId = this.importer.getPidFromWindowsTid(fields.newThreadId);
                const newProcess = this.model.getProcess(newProcessId);
                let newProcessName;
                if (newProcess) {
                    newProcessName = newProcess.name;
                } else {
                    newProcessName = 'Unknown process';
                }
                newThreadName = newProcessName + ' (tid ' + fields.newThreadId + ')';
            }
            cpu.switchActiveThread(header.timestamp, {}, fields.newThreadId, newThreadName, fields);
            return true;
        }
    };
    Parser.register(ThreadParser);
    return {ThreadParser,};
});
'use strict';
tr.exportTo('tr.b', function () {
    function max(a, b) {
        if (a === undefined) return b;
        if (b === undefined) return a;
        return Math.max(a, b);
    }

    function IntervalTree(beginPositionCb, endPositionCb) {
        this.beginPositionCb_ = beginPositionCb;
        this.endPositionCb_ = endPositionCb;
        this.root_ = undefined;
        this.size_ = 0;
    }

    IntervalTree.prototype = {
        insert(datum) {
            const startPosition = this.beginPositionCb_(datum);
            const endPosition = this.endPositionCb_(datum);
            const node = new IntervalTreeNode(datum, startPosition, endPosition);
            this.size_++;
            this.root_ = this.insertNode_(this.root_, node);
            this.root_.colour = Colour.BLACK;
            return datum;
        }, insertNode_(root, node) {
            if (root === undefined) return node;
            if (root.leftNode && root.leftNode.isRed && root.rightNode && root.rightNode.isRed) {
                this.flipNodeColour_(root);
            }
            if (node.key < root.key) {
                root.leftNode = this.insertNode_(root.leftNode, node);
            } else if (node.key === root.key) {
                root.merge(node);
            } else {
                root.rightNode = this.insertNode_(root.rightNode, node);
            }
            if (root.rightNode && root.rightNode.isRed && (root.leftNode === undefined || !root.leftNode.isRed)) {
                root = this.rotateLeft_(root);
            }
            if (root.leftNode && root.leftNode.isRed && root.leftNode.leftNode && root.leftNode.leftNode.isRed) {
                root = this.rotateRight_(root);
            }
            return root;
        }, rotateRight_(node) {
            const sibling = node.leftNode;
            node.leftNode = sibling.rightNode;
            sibling.rightNode = node;
            sibling.colour = node.colour;
            node.colour = Colour.RED;
            return sibling;
        }, rotateLeft_(node) {
            const sibling = node.rightNode;
            node.rightNode = sibling.leftNode;
            sibling.leftNode = node;
            sibling.colour = node.colour;
            node.colour = Colour.RED;
            return sibling;
        }, flipNodeColour_(node) {
            node.colour = this.flipColour_(node.colour);
            node.leftNode.colour = this.flipColour_(node.leftNode.colour);
            node.rightNode.colour = this.flipColour_(node.rightNode.colour);
        }, flipColour_(colour) {
            return colour === Colour.RED ? Colour.BLACK : Colour.RED;
        }, updateHighValues() {
            this.updateHighValues_(this.root_);
        }, updateHighValues_(node) {
            if (node === undefined) return undefined;
            node.maxHighLeft = this.updateHighValues_(node.leftNode);
            node.maxHighRight = this.updateHighValues_(node.rightNode);
            return max(max(node.maxHighLeft, node.highValue), node.maxHighRight);
        }, validateFindArguments_(queryLow, queryHigh) {
            if (queryLow === undefined || queryHigh === undefined) {
                throw new Error('queryLow and queryHigh must be defined');
            }
            if ((typeof queryLow !== 'number') || (typeof queryHigh !== 'number')) {
                throw new Error('queryLow and queryHigh must be numbers');
            }
        }, findIntersection(queryLow, queryHigh) {
            this.validateFindArguments_(queryLow, queryHigh);
            if (this.root_ === undefined) return [];
            const ret = [];
            this.root_.appendIntersectionsInto_(ret, queryLow, queryHigh);
            return ret;
        }, get size() {
            return this.size_;
        }, get root() {
            return this.root_;
        }, dump_() {
            if (this.root_ === undefined) return [];
            return this.root_.dump();
        }
    };
    const Colour = {RED: 'red', BLACK: 'black'};

    function IntervalTreeNode(datum, lowValue, highValue) {
        this.lowValue_ = lowValue;
        this.data_ = [{datum, high: highValue, low: lowValue}];
        this.colour_ = Colour.RED;
        this.parentNode_ = undefined;
        this.leftNode_ = undefined;
        this.rightNode_ = undefined;
        this.maxHighLeft_ = undefined;
        this.maxHighRight_ = undefined;
    }

    IntervalTreeNode.prototype = {
        appendIntersectionsInto_(ret, queryLow, queryHigh) {
            if (this.lowValue_ >= queryHigh) {
                if (!this.leftNode_) return;
                return this.leftNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
            }
            if (this.maxHighLeft_ > queryLow) {
                this.leftNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
            }
            if (this.highValue > queryLow) {
                for (let i = (this.data.length - 1); i >= 0; --i) {
                    if (this.data[i].high < queryLow) break;
                    ret.push(this.data[i].datum);
                }
            }
            if (this.rightNode_) {
                this.rightNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
            }
        }, get colour() {
            return this.colour_;
        }, set colour(colour) {
            this.colour_ = colour;
        }, get key() {
            return this.lowValue_;
        }, get lowValue() {
            return this.lowValue_;
        }, get highValue() {
            return this.data_[this.data_.length - 1].high;
        }, set leftNode(left) {
            this.leftNode_ = left;
        }, get leftNode() {
            return this.leftNode_;
        }, get hasLeftNode() {
            return this.leftNode_ !== undefined;
        }, set rightNode(right) {
            this.rightNode_ = right;
        }, get rightNode() {
            return this.rightNode_;
        }, get hasRightNode() {
            return this.rightNode_ !== undefined;
        }, set parentNode(parent) {
            this.parentNode_ = parent;
        }, get parentNode() {
            return this.parentNode_;
        }, get isRootNode() {
            return this.parentNode_ === undefined;
        }, set maxHighLeft(high) {
            this.maxHighLeft_ = high;
        }, get maxHighLeft() {
            return this.maxHighLeft_;
        }, set maxHighRight(high) {
            this.maxHighRight_ = high;
        }, get maxHighRight() {
            return this.maxHighRight_;
        }, get data() {
            return this.data_;
        }, get isRed() {
            return this.colour_ === Colour.RED;
        }, merge(node) {
            for (let i = 0; i < node.data.length; i++) {
                this.data_.push(node.data[i]);
            }
            this.data_.sort(function (a, b) {
                return a.high - b.high;
            });
        }, dump() {
            const ret = {};
            if (this.leftNode_) {
                ret.left = this.leftNode_.dump();
            }
            ret.data = this.data_.map(function (d) {
                return [d.low, d.high];
            });
            if (this.rightNode_) {
                ret.right = this.rightNode_.dump();
            }
            return ret;
        }
    };
    return {IntervalTree,};
});
'use strict';
tr.exportTo('tr.b.math', function () {
    const tmpVec2s = [];
    for (let i = 0; i < 8; i++) {
        tmpVec2s[i] = vec2.create();
    }
    const tmpVec2a = vec4.create();
    const tmpVec4a = vec4.create();
    const tmpVec4b = vec4.create();
    const tmpMat4 = mat4.create();
    const tmpMat4b = mat4.create();
    const p00 = vec2.createXY(0, 0);
    const p10 = vec2.createXY(1, 0);
    const p01 = vec2.createXY(0, 1);
    const p11 = vec2.createXY(1, 1);
    const lerpingVecA = vec2.create();
    const lerpingVecB = vec2.create();

    function lerpVec2(out, a, b, amt) {
        vec2.scale(lerpingVecA, a, amt);
        vec2.scale(lerpingVecB, b, 1 - amt);
        vec2.add(out, lerpingVecA, lerpingVecB);
        vec2.normalize(out, out);
        return out;
    }

    function Quad() {
        this.p1 = vec2.create();
        this.p2 = vec2.create();
        this.p3 = vec2.create();
        this.p4 = vec2.create();
    }

    Quad.fromXYWH = function (x, y, w, h) {
        const q = new Quad();
        vec2.set(q.p1, x, y);
        vec2.set(q.p2, x + w, y);
        vec2.set(q.p3, x + w, y + h);
        vec2.set(q.p4, x, y + h);
        return q;
    };
    Quad.fromRect = function (r) {
        return new Quad.fromXYWH(r.x, r.y, r.width, r.height);
    };
    Quad.from4Vecs = function (p1, p2, p3, p4) {
        const q = new Quad();
        vec2.set(q.p1, p1[0], p1[1]);
        vec2.set(q.p2, p2[0], p2[1]);
        vec2.set(q.p3, p3[0], p3[1]);
        vec2.set(q.p4, p4[0], p4[1]);
        return q;
    };
    Quad.from8Array = function (arr) {
        if (arr.length !== 8) {
            throw new Error('Array must be 8 long');
        }
        const q = new Quad();
        q.p1[0] = arr[0];
        q.p1[1] = arr[1];
        q.p2[0] = arr[2];
        q.p2[1] = arr[3];
        q.p3[0] = arr[4];
        q.p3[1] = arr[5];
        q.p4[0] = arr[6];
        q.p4[1] = arr[7];
        return q;
    };
    Quad.prototype = {
        pointInside(point) {
            return pointInImplicitQuad(point, this.p1, this.p2, this.p3, this.p4);
        }, boundingRect() {
            const x0 = Math.min(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
            const y0 = Math.min(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);
            const x1 = Math.max(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
            const y1 = Math.max(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);
            return new tr.b.math.Rect.fromXYWH(x0, y0, x1 - x0, y1 - y0);
        }, clone() {
            const q = new Quad();
            vec2.copy(q.p1, this.p1);
            vec2.copy(q.p2, this.p2);
            vec2.copy(q.p3, this.p3);
            vec2.copy(q.p4, this.p4);
            return q;
        }, scale(s) {
            const q = new Quad();
            this.scaleFast(q, s);
            return q;
        }, scaleFast(dstQuad, s) {
            vec2.copy(dstQuad.p1, this.p1, s);
            vec2.copy(dstQuad.p2, this.p2, s);
            vec2.copy(dstQuad.p3, this.p3, s);
            vec2.copy(dstQuad.p3, this.p3, s);
        }, isRectangle() {
            const bounds = this.boundingRect();
            return (bounds.x === this.p1[0] && bounds.y === this.p1[1] && bounds.width === this.p2[0] - this.p1[0] && bounds.y === this.p2[1] && bounds.width === this.p3[0] - this.p1[0] && bounds.height === this.p3[1] - this.p2[1] && bounds.x === this.p4[0] && bounds.height === this.p4[1] - this.p2[1]);
        }, projectUnitRect(rect) {
            const q = new Quad();
            this.projectUnitRectFast(q, rect);
            return q;
        }, projectUnitRectFast(dstQuad, rect) {
            const v12 = tmpVec2s[0];
            const v14 = tmpVec2s[1];
            const v23 = tmpVec2s[2];
            const v43 = tmpVec2s[3];
            vec2.sub(v12, this.p2, this.p1);
            const l12 = vec2.length(v12);
            vec2.scale(v12, v12, 1 / l12);
            vec2.sub(v14, this.p4, this.p1);
            const l14 = vec2.length(v14);
            vec2.scale(v14, v14, 1 / l14);
            vec2.sub(v23, this.p3, this.p2);
            const l23 = vec2.length(v23);
            vec2.scale(v23, v23, 1 / l23);
            vec2.sub(v43, this.p3, this.p4);
            const l43 = vec2.length(v43);
            vec2.scale(v43, v43, 1 / l43);
            const b12 = tmpVec2s[0];
            const b14 = tmpVec2s[1];
            const b23 = tmpVec2s[2];
            const b43 = tmpVec2s[3];
            lerpVec2(b12, v12, v43, rect.y);
            lerpVec2(b43, v12, v43, 1 - rect.bottom);
            lerpVec2(b14, v14, v23, rect.x);
            lerpVec2(b23, v14, v23, 1 - rect.right);
            vec2.addTwoScaledUnitVectors(tmpVec2a, b12, l12 * rect.x, b14, l14 * rect.y);
            vec2.add(dstQuad.p1, this.p1, tmpVec2a);
            vec2.addTwoScaledUnitVectors(tmpVec2a, b12, l12 * -(1.0 - rect.right), b23, l23 * rect.y);
            vec2.add(dstQuad.p2, this.p2, tmpVec2a);
            vec2.addTwoScaledUnitVectors(tmpVec2a, b43, l43 * -(1.0 - rect.right), b23, l23 * -(1.0 - rect.bottom));
            vec2.add(dstQuad.p3, this.p3, tmpVec2a);
            vec2.addTwoScaledUnitVectors(tmpVec2a, b43, l43 * rect.left, b14, l14 * -(1.0 - rect.bottom));
            vec2.add(dstQuad.p4, this.p4, tmpVec2a);
        }, toString() {
            return 'Quad(' +
                vec2.toString(this.p1) + ', ' +
                vec2.toString(this.p2) + ', ' +
                vec2.toString(this.p3) + ', ' +
                vec2.toString(this.p4) + ')';
        }
    };

    function sign(p1, p2, p3) {
        return (p1[0] - p3[0]) * (p2[1] - p3[1]) -
            (p2[0] - p3[0]) * (p1[1] - p3[1]);
    }

    function pointInTriangle2(pt, p1, p2, p3) {
        const b1 = sign(pt, p1, p2) < 0.0;
        const b2 = sign(pt, p2, p3) < 0.0;
        const b3 = sign(pt, p3, p1) < 0.0;
        return ((b1 === b2) && (b2 === b3));
    }

    function pointInImplicitQuad(point, p1, p2, p3, p4) {
        return pointInTriangle2(point, p1, p2, p3) || pointInTriangle2(point, p1, p3, p4);
    }

    return {pointInTriangle2, pointInImplicitQuad, Quad,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const ESTIMATED_IDLE_PERIOD_LENGTH_MILLISECONDS = 10;
    const REQUEST_IDLE_CALLBACK_TIMEOUT_MILLISECONDS = 100;
    const recordRAFStacks = false;
    let pendingPreAFs = [];
    let pendingRAFs = [];
    const pendingIdleCallbacks = [];
    let currentRAFDispatchList = undefined;
    let rafScheduled = false;
    let idleWorkScheduled = false;

    function scheduleRAF() {
        if (rafScheduled) return;
        rafScheduled = true;
        if (tr.isHeadless) {
            Promise.resolve().then(function () {
                processRequests(false, 0);
            }, function (e) {
                throw e;
            });
        } else {
            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(processRequests.bind(this, false));
            } else {
                const delta = Date.now() - window.performance.now();
                window.webkitRequestAnimationFrame(function (domTimeStamp) {
                    processRequests(false, domTimeStamp - delta);
                });
            }
        }
    }

    function nativeRequestIdleCallbackSupported() {
        return !tr.isHeadless && window.requestIdleCallback;
    }

    function scheduleIdleWork() {
        if (idleWorkScheduled) return;
        if (!nativeRequestIdleCallbackSupported()) {
            scheduleRAF();
            return;
        }
        idleWorkScheduled = true;
        window.requestIdleCallback(function (deadline, didTimeout) {
            processIdleWork(false, deadline);
        }, {timeout: REQUEST_IDLE_CALLBACK_TIMEOUT_MILLISECONDS});
    }

    function onAnimationFrameError(e, opt_stack) {
        console.log(e.stack);
        if (tr.isHeadless) throw e;
        if (opt_stack) console.log(opt_stack);
        if (e.message) {
            console.error(e.message, e.stack);
        } else {
            console.error(e);
        }
    }

    function runTask(task, frameBeginTime) {
        try {
            task.callback.call(task.context, frameBeginTime);
        } catch (e) {
            tr.b.onAnimationFrameError(e, task.stack);
        }
    }

    function processRequests(forceAllTasksToRun, frameBeginTime) {
        rafScheduled = false;
        const currentPreAFs = pendingPreAFs;
        currentRAFDispatchList = pendingRAFs;
        pendingPreAFs = [];
        pendingRAFs = [];
        const hasRAFTasks = currentPreAFs.length || currentRAFDispatchList.length;
        for (let i = 0; i < currentPreAFs.length; i++) {
            runTask(currentPreAFs[i], frameBeginTime);
        }
        while (currentRAFDispatchList.length > 0) {
            runTask(currentRAFDispatchList.shift(), frameBeginTime);
        }
        currentRAFDispatchList = undefined;
        if ((!hasRAFTasks && !nativeRequestIdleCallbackSupported()) || forceAllTasksToRun) {
            const rafCompletionDeadline = frameBeginTime + ESTIMATED_IDLE_PERIOD_LENGTH_MILLISECONDS;
            processIdleWork(forceAllTasksToRun, {
                timeRemaining() {
                    return rafCompletionDeadline - window.performance.now();
                }
            });
        }
        if (pendingIdleCallbacks.length > 0) scheduleIdleWork();
    }

    function processIdleWork(forceAllTasksToRun, deadline) {
        idleWorkScheduled = false;
        while (pendingIdleCallbacks.length > 0) {
            runTask(pendingIdleCallbacks.shift());
            if (!forceAllTasksToRun && (tr.isHeadless || deadline.timeRemaining() <= 0)) {
                break;
            }
        }
        if (pendingIdleCallbacks.length > 0) scheduleIdleWork();
    }

    function getStack_() {
        if (!recordRAFStacks) return '';
        const stackLines = tr.b.stackTrace();
        stackLines.shift();
        return stackLines.join('\n');
    }

    function requestPreAnimationFrame(callback, opt_this) {
        pendingPreAFs.push({callback, context: opt_this || global, stack: getStack_()});
        scheduleRAF();
    }

    function requestAnimationFrameInThisFrameIfPossible(callback, opt_this) {
        if (!currentRAFDispatchList) {
            requestAnimationFrame(callback, opt_this);
            return;
        }
        currentRAFDispatchList.push({callback, context: opt_this || global, stack: getStack_()});
        return;
    }

    function requestAnimationFrame(callback, opt_this) {
        pendingRAFs.push({callback, context: opt_this || global, stack: getStack_()});
        scheduleRAF();
    }

    function animationFrame() {
        return new Promise(resolve => requestAnimationFrame(resolve));
    }

    function requestIdleCallback(callback, opt_this) {
        pendingIdleCallbacks.push({callback, context: opt_this || global, stack: getStack_()});
        scheduleIdleWork();
    }

    function forcePendingRAFTasksToRun(frameBeginTime) {
        if (!rafScheduled) return;
        processRequests(false, frameBeginTime);
    }

    function forceAllPendingTasksToRunForTest() {
        if (!rafScheduled && !idleWorkScheduled) return;
        processRequests(true, 0);
    }

    function timeout(ms) {
        return new Promise(resolve => window.setTimeout(resolve, ms));
    }

    function idle() {
        return new Promise(resolve => requestIdleCallback(resolve));
    }

    return {
        animationFrame,
        forceAllPendingTasksToRunForTest,
        forcePendingRAFTasksToRun,
        idle,
        onAnimationFrameError,
        requestAnimationFrame,
        requestAnimationFrameInThisFrameIfPossible,
        requestIdleCallback,
        requestPreAnimationFrame,
        timeout,
    };
});
'use strict';
tr.exportTo('tr.b', function () {
    class Mark {
        constructor(groupName, functionName, opt_timestamp) {
            if (tr.isHeadless) return;
            this.groupName_ = groupName;
            this.functionName_ = functionName;
            const guid = tr.b.GUID.allocateSimple();
            this.measureName_ = `${groupName} ${functionName}`;
            if (opt_timestamp) {
                this.startMark_ = {startTime: opt_timestamp};
            } else {
                this.startMarkName_ = `${this.measureName} ${guid} start`;
            }
            this.endMark_ = undefined;
            this.endMarkName_ = `${this.measureName} ${guid} end`;
            window.performance.mark(this.startMarkName_);
        }

        get groupName() {
            return this.groupName_;
        }

        get functionName() {
            return this.functionName_;
        }

        get measureName() {
            return this.measureName_;
        }

        get startMark() {
            return this.startMark_ || tr.b.getOnlyElement(window.performance.getEntriesByName(this.startMarkName_));
        }

        get endMark() {
            return this.endMark_ || tr.b.getOnlyElement(window.performance.getEntriesByName(this.endMarkName_));
        }

        get durationMs() {
            return this.endMark.startTime - this.startMark.startTime;
        }

        end(opt_timestamp) {
            if (tr.isHeadless) return;
            if (opt_timestamp) {
                this.endMark_ = {startTime: opt_timestamp};
            } else {
                window.performance.mark(this.endMarkName_);
            }
            if (!this.startMark_ && !this.endMark_) {
                window.performance.measure(this.measureName_, this.startMarkName_, this.endMarkName_);
            } else if (Timing.logVoidMarks && !(window.ga instanceof Function)) {
                console.log('void mark', this.groupName, this.functionName, this.durationMs);
            }
            if (!(window.ga instanceof Function)) return;
            ga('send', {
                hitType: 'event',
                eventCategory: this.groupName,
                eventAction: this.functionName,
                eventValue: this.durationMs,
            });
        }
    }

    class Timing {
        static mark(groupName, functionName, opt_timestamp) {
            return new Mark(groupName, functionName, opt_timestamp);
        }

        static instant(groupName, functionName, opt_value) {
            const valueString = opt_value === undefined ? '' : ' ' + opt_value;
            if (console && console.timeStamp) {
                console.timeStamp(`${groupName} ${functionName}${valueString}`);
            }
            if (window && window.ga instanceof Function) {
                ga('send', {
                    hitType: 'event',
                    eventCategory: groupName,
                    eventAction: functionName,
                    eventValue: opt_value,
                });
            }
        }

        static getCurrentTimeMs() {
            try {
                return performance.now();
            } catch (error) {
            }
            return 0;
        }
    }

    Timing.logVoidMarks = false;
    return {Timing,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const Timing = tr.b.Timing;

    function Task(runCb, thisArg) {
        if (runCb !== undefined && thisArg === undefined && runCb.prototype !== undefined) {
            throw new Error('Almost certainly you meant to pass a bound callback ' + 'or thisArg.');
        }
        this.runCb_ = runCb;
        this.thisArg_ = thisArg;
        this.afterTask_ = undefined;
        this.subTasks_ = [];
        this.updatesUi_ = false;
    }

    Task.prototype = {
        get name() {
            return this.runCb_.name;
        }, set updatesUi(value) {
            this.updatesUi_ = value;
        }, subTask(cb, thisArg) {
            if (cb instanceof Task) {
                this.subTasks_.push(cb);
            } else {
                this.subTasks_.push(new Task(cb, thisArg));
            }
            return this.subTasks_[this.subTasks_.length - 1];
        }, run() {
            if (this.runCb_ !== undefined) this.runCb_.call(this.thisArg_, this);
            const subTasks = this.subTasks_;
            this.subTasks_ = undefined;
            if (!subTasks.length) return this.afterTask_;
            for (let i = 1; i < subTasks.length; i++) {
                subTasks[i - 1].afterTask_ = subTasks[i];
            }
            subTasks[subTasks.length - 1].afterTask_ = this.afterTask_;
            return subTasks[0];
        }, after(cb, thisArg) {
            if (this.afterTask_) {
                throw new Error('Has an after task already');
            }
            if (cb instanceof Task) {
                this.afterTask_ = cb;
            } else {
                this.afterTask_ = new Task(cb, thisArg);
            }
            return this.afterTask_;
        }, enqueue(cb, thisArg) {
            if (!this.afterTask_) return this.after(cb, thisArg);
            return this.afterTask_.enqueue(cb, thisArg);
        }
    };
    Task.RunSynchronously = function (task) {
        let curTask = task;
        while (curTask) {
            curTask = curTask.run();
        }
    };
    Task.RunWhenIdle = function (task) {
        return new Promise(function (resolve, reject) {
            let curTask = task;

            function runAnother() {
                try {
                    curTask = curTask.run();
                } catch (e) {
                    reject(e);
                    return;
                }
                if (curTask) {
                    if (curTask.updatesUi_) {
                        tr.b.requestAnimationFrameInThisFrameIfPossible(runAnother);
                    } else {
                        tr.b.requestIdleCallback(runAnother);
                    }
                    return;
                }
                resolve();
            }

            tr.b.requestIdleCallback(runAnother);
        });
    };
    return {Task,};
});
'use strict';
tr.exportTo('tr.c', function () {
    function makeCaseInsensitiveRegex(pattern) {
        pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return new RegExp(pattern, 'i');
    }

    function Filter() {
    }

    Filter.prototype = {
        __proto__: Object.prototype, matchCounter(counter) {
            return true;
        }, matchCpu(cpu) {
            return true;
        }, matchProcess(process) {
            return true;
        }, matchSlice(slice) {
            return true;
        }, matchThread(thread) {
            return true;
        }
    };

    function TitleOrCategoryFilter(text) {
        Filter.call(this);
        this.regex_ = makeCaseInsensitiveRegex(text);
        if (!text.length) {
            throw new Error('Filter text is empty.');
        }
    }

    TitleOrCategoryFilter.prototype = {
        __proto__: Filter.prototype, matchSlice(slice) {
            if (slice.title === undefined && slice.category === undefined) {
                return false;
            }
            return this.regex_.test(slice.title) || (!!slice.category && this.regex_.test(slice.category));
        }
    };

    function ExactTitleFilter(text) {
        Filter.call(this);
        this.text_ = text;
        if (!text.length) {
            throw new Error('Filter text is empty.');
        }
    }

    ExactTitleFilter.prototype = {
        __proto__: Filter.prototype, matchSlice(slice) {
            return slice.title === this.text_;
        }
    };

    function FullTextFilter(text) {
        Filter.call(this);
        this.regex_ = makeCaseInsensitiveRegex(text);
        this.titleOrCategoryFilter_ = new TitleOrCategoryFilter(text);
    }

    FullTextFilter.prototype = {
        __proto__: Filter.prototype, matchObject_(obj) {
            for (const key in obj) {
                if (!obj.hasOwnProperty(key)) continue;
                if (this.regex_.test(key)) return true;
                if (this.regex_.test(obj[key])) return true;
            }
            return false;
        }, matchSlice(slice) {
            if (this.titleOrCategoryFilter_.matchSlice(slice)) return true;
            return this.matchObject_(slice.args);
        }
    };
    return {Filter, TitleOrCategoryFilter, ExactTitleFilter, FullTextFilter,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ClockDomainId = {
        BATTOR: 'BATTOR',
        UNKNOWN_CHROME_LEGACY: 'UNKNOWN_CHROME_LEGACY',
        LINUX_CLOCK_MONOTONIC: 'LINUX_CLOCK_MONOTONIC',
        LINUX_FTRACE_GLOBAL: 'LINUX_FTRACE_GLOBAL',
        MAC_MACH_ABSOLUTE_TIME: 'MAC_MACH_ABSOLUTE_TIME',
        WIN_ROLLOVER_PROTECTED_TIME_GET_TIME: 'WIN_ROLLOVER_PROTECTED_TIME_GET_TIME',
        WIN_QPC: 'WIN_QPC',
        SYSTRACE: 'SYSTRACE',
        TELEMETRY: 'TELEMETRY'
    };
    const POSSIBLE_CHROME_CLOCK_DOMAINS = new Set([ClockDomainId.UNKNOWN_CHROME_LEGACY, ClockDomainId.LINUX_CLOCK_MONOTONIC, ClockDomainId.MAC_MACH_ABSOLUTE_TIME, ClockDomainId.WIN_ROLLOVER_PROTECTED_TIME_GET_TIME, ClockDomainId.WIN_QPC]);
    const BATTOR_FAST_SYNC_THRESHOLD_MS = 3;

    function ClockSyncManager() {
        this.domainsSeen_ = new Set();
        this.markersBySyncId_ = new Map();
        this.transformerMapByDomainId_ = {};
    }

    ClockSyncManager.prototype = {
        addClockSyncMarker(domainId, syncId, startTs, opt_endTs) {
            this.onDomainSeen_(domainId);
            if (Object.values(ClockDomainId).indexOf(domainId) < 0) {
                throw new Error('"' + domainId + '" is not in the list of known ' + 'clock domain IDs.');
            }
            if (this.modelDomainId_) {
                throw new Error('Cannot add new clock sync markers after getting ' + 'a model time transformer.');
            }
            const marker = new ClockSyncMarker(domainId, startTs, opt_endTs);
            if (!this.markersBySyncId_.has(syncId)) {
                this.markersBySyncId_.set(syncId, [marker]);
                return;
            }
            const markers = this.markersBySyncId_.get(syncId);
            if (markers.length === 2) {
                throw new Error('Clock sync with ID "' + syncId + '" is already ' + 'complete - cannot add a third clock sync marker to it.');
            }
            if (markers[0].domainId === domainId) {
                throw new Error('A clock domain cannot sync with itself.');
            }
            markers.push(marker);
            this.onSyncCompleted_(markers[0], marker);
        }, get completeSyncIds() {
            const completeSyncIds = [];
            for (const [syncId, markers] of this.markersBySyncId) {
                if (markers.length === 2) completeSyncIds.push(syncId);
            }
            return completeSyncIds;
        }, get markersBySyncId() {
            return this.markersBySyncId_;
        }, get domainsSeen() {
            return this.domainsSeen_;
        }, getModelTimeTransformer(domainId) {
            this.onDomainSeen_(domainId);
            if (!this.modelDomainId_) {
                this.selectModelDomainId_();
            }
            return this.getTimeTransformerRaw_(domainId, this.modelDomainId_).fn;
        }, getTimeTransformerError(fromDomainId, toDomainId) {
            this.onDomainSeen_(fromDomainId);
            this.onDomainSeen_(toDomainId);
            return this.getTimeTransformerRaw_(fromDomainId, toDomainId).error;
        }, getTimeTransformerRaw_(fromDomainId, toDomainId) {
            const transformer = this.getTransformerBetween_(fromDomainId, toDomainId);
            if (!transformer) {
                throw new Error('No clock sync markers exist pairing clock domain "' +
                    fromDomainId + '" ' + 'with target clock domain "' +
                    toDomainId + '".');
            }
            return transformer;
        }, getTransformerBetween_(fromDomainId, toDomainId) {
            const visitedDomainIds = new Set();
            const queue = [{domainId: fromDomainId, transformer: Transformer.IDENTITY}];
            while (queue.length > 0) {
                queue.sort((domain1, domain2) => domain1.transformer.error - domain2.transformer.error);
                const current = queue.shift();
                if (current.domainId === toDomainId) {
                    return current.transformer;
                }
                if (visitedDomainIds.has(current.domainId)) {
                    continue;
                }
                visitedDomainIds.add(current.domainId);
                const outgoingTransformers = this.transformerMapByDomainId_[current.domainId];
                if (!outgoingTransformers) continue;
                for (const outgoingDomainId in outgoingTransformers) {
                    const toNextDomainTransformer = outgoingTransformers[outgoingDomainId];
                    const toCurrentDomainTransformer = current.transformer;
                    queue.push({
                        domainId: outgoingDomainId,
                        transformer: Transformer.compose(toNextDomainTransformer, toCurrentDomainTransformer)
                    });
                }
            }
            return undefined;
        }, selectModelDomainId_() {
            this.ensureAllDomainsAreConnected_();
            for (const chromeDomainId of POSSIBLE_CHROME_CLOCK_DOMAINS) {
                if (this.domainsSeen_.has(chromeDomainId)) {
                    this.modelDomainId_ = chromeDomainId;
                    return;
                }
            }
            const domainsSeenArray = Array.from(this.domainsSeen_);
            domainsSeenArray.sort();
            this.modelDomainId_ = domainsSeenArray[0];
        }, ensureAllDomainsAreConnected_() {
            let firstDomainId = undefined;
            for (const domainId of this.domainsSeen_) {
                if (!firstDomainId) {
                    firstDomainId = domainId;
                    continue;
                }
                if (!this.getTransformerBetween_(firstDomainId, domainId)) {
                    throw new Error('Unable to select a master clock domain because no ' + 'path can be found from "' + firstDomainId + '" to "' + domainId + '".');
                }
            }
            return true;
        }, onDomainSeen_(domainId) {
            if (domainId === ClockDomainId.UNKNOWN_CHROME_LEGACY && !this.domainsSeen_.has(ClockDomainId.UNKNOWN_CHROME_LEGACY)) {
                for (const chromeDomainId of POSSIBLE_CHROME_CLOCK_DOMAINS) {
                    if (chromeDomainId === ClockDomainId.UNKNOWN_CHROME_LEGACY) {
                        continue;
                    }
                    this.collapseDomains_(ClockDomainId.UNKNOWN_CHROME_LEGACY, chromeDomainId);
                }
            }
            this.domainsSeen_.add(domainId);
        }, onSyncCompleted_(marker1, marker2) {
            const forwardTransformer = Transformer.fromMarkers(marker1, marker2);
            const backwardTransformer = Transformer.fromMarkers(marker2, marker1);
            const existingTransformer = this.getOrCreateTransformerMap_(marker1.domainId)[marker2.domainId];
            if (!existingTransformer || forwardTransformer.error < existingTransformer.error) {
                this.getOrCreateTransformerMap_(marker1.domainId)[marker2.domainId] = forwardTransformer;
                this.getOrCreateTransformerMap_(marker2.domainId)[marker1.domainId] = backwardTransformer;
            }
        }, collapseDomains_(domain1Id, domain2Id) {
            this.getOrCreateTransformerMap_(domain1Id)[domain2Id] = this.getOrCreateTransformerMap_(domain2Id)[domain1Id] = Transformer.IDENTITY;
        }, getOrCreateTransformerMap_(domainId) {
            if (!this.transformerMapByDomainId_[domainId]) {
                this.transformerMapByDomainId_[domainId] = {};
            }
            return this.transformerMapByDomainId_[domainId];
        }, computeDotGraph() {
            let dotString = 'graph {\n';
            const domainsSeen = [...this.domainsSeen_].sort();
            for (const domainId of domainsSeen) {
                dotString += `  ${domainId}[shape=box]\n`;
            }
            const markersBySyncIdEntries = [...this.markersBySyncId_.entries()].sort(([syncId1, markers1], [syncId2, markers2]) => syncId1.localeCompare(syncId2));
            for (const [syncId, markers] of markersBySyncIdEntries) {
                const sortedMarkers = markers.sort((a, b) => a.domainId.localeCompare(b.domainId));
                for (const m of markers) {
                    dotString += `  "${syncId}" -- ${m.domainId} `;
                    dotString += `[label="[${m.startTs}, ${m.endTs}]"]\n`;
                }
            }
            dotString += '}';
            return dotString;
        }
    };

    function ClockSyncMarker(domainId, startTs, opt_endTs) {
        this.domainId = domainId;
        this.startTs = startTs;
        this.endTs = opt_endTs === undefined ? startTs : opt_endTs;
    }

    ClockSyncMarker.prototype = {
        get duration() {
            return this.endTs - this.startTs;
        }, get ts() {
            return this.startTs + this.duration / 2;
        }
    };

    function Transformer(fn, error) {
        this.fn = fn;
        this.error = error;
    }

    Transformer.IDENTITY = new Transformer((x => x), 0);
    Transformer.compose = function (aToB, bToC) {
        return new Transformer((ts) => bToC.fn(aToB.fn(ts)), aToB.error + bToC.error);
    };
    Transformer.fromMarkers = function (fromMarker, toMarker) {
        let fromTs = fromMarker.ts;
        let toTs = toMarker.ts;
        if (fromMarker.domainId === ClockDomainId.BATTOR && toMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
            toTs = toMarker.startTs;
        } else if (toMarker.domainId === ClockDomainId.BATTOR && fromMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
            fromTs = fromMarker.startTs;
        }
        const tsShift = toTs - fromTs;
        return new Transformer((ts) => ts + tsShift, fromMarker.duration + toMarker.duration);
    };
    return {ClockDomainId, ClockSyncManager,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function CounterSample(series, timestamp, value) {
        tr.model.Event.call(this);
        this.series_ = series;
        this.timestamp_ = timestamp;
        this.value_ = value;
    }

    CounterSample.groupByTimestamp = function (samples) {
        const samplesByTimestamp = tr.b.groupIntoMap(samples, s => s.timestamp);
        const timestamps = Array.from(samplesByTimestamp.keys());
        timestamps.sort();
        const groups = [];
        for (const ts of timestamps) {
            const group = samplesByTimestamp.get(ts);
            group.sort((x, y) => x.series.seriesIndex - y.series.seriesIndex);
            groups.push(group);
        }
        return groups;
    };
    CounterSample.prototype = {
        __proto__: tr.model.Event.prototype, get series() {
            return this.series_;
        }, get timestamp() {
            return this.timestamp_;
        }, get value() {
            return this.value_;
        }, set timestamp(timestamp) {
            this.timestamp_ = timestamp;
        }, addBoundsToRange(range) {
            range.addValue(this.timestamp);
        }, getSampleIndex() {
            return tr.b.findLowIndexInSortedArray(this.series.timestamps, function (x) {
                return x;
            }, this.timestamp_);
        }, get userFriendlyName() {
            return 'Counter sample from ' + this.series_.title + ' at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.timestamp);
        }
    };
    tr.model.EventRegistry.register(CounterSample, {name: 'counterSample', pluralName: 'counterSamples'});
    return {CounterSample,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const CounterSample = tr.model.CounterSample;

    function CounterSeries(name, color) {
        tr.model.EventContainer.call(this);
        this.name_ = name;
        this.color_ = color;
        this.timestamps_ = [];
        this.samples_ = [];
        this.counter = undefined;
        this.seriesIndex = undefined;
    }

    CounterSeries.prototype = {
        __proto__: tr.model.EventContainer.prototype, get length() {
            return this.timestamps_.length;
        }, get name() {
            return this.name_;
        }, get color() {
            return this.color_;
        }, get samples() {
            return this.samples_;
        }, get timestamps() {
            return this.timestamps_;
        }, getSample(idx) {
            return this.samples_[idx];
        }, getTimestamp(idx) {
            return this.timestamps_[idx];
        }, addCounterSample(ts, val) {
            const sample = new CounterSample(this, ts, val);
            this.addSample(sample);
            return sample;
        }, addSample(sample) {
            this.timestamps_.push(sample.timestamp);
            this.samples_.push(sample);
        }, getStatistics(sampleIndices) {
            let sum = 0;
            let min = Number.MAX_VALUE;
            let max = -Number.MAX_VALUE;
            for (let i = 0; i < sampleIndices.length; ++i) {
                const sample = this.getSample(sampleIndices[i]).value;
                sum += sample;
                min = Math.min(sample, min);
                max = Math.max(sample, max);
            }
            return {
                min,
                max,
                avg: (sum / sampleIndices.length),
                start: this.getSample(sampleIndices[0]).value,
                end: this.getSample(sampleIndices.length - 1).value
            };
        }, shiftTimestampsForward(amount) {
            for (let i = 0; i < this.timestamps_.length; ++i) {
                this.timestamps_[i] += amount;
                this.samples_[i].timestamp = this.timestamps_[i];
            }
        }, * childEvents() {
            yield* this.samples_;
        }, * childEventContainers() {
        }
    };
    return {CounterSeries,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function Counter(parent, id, category, name) {
        tr.model.EventContainer.call(this);
        this.parent_ = parent;
        this.id_ = id;
        this.category_ = category || '';
        this.name_ = name;
        this.series_ = [];
        this.totals = [];
    }

    Counter.prototype = {
        __proto__: tr.model.EventContainer.prototype, get parent() {
            return this.parent_;
        }, get id() {
            return this.id_;
        }, get category() {
            return this.category_;
        }, get name() {
            return this.name_;
        }, * childEvents() {
        }, * childEventContainers() {
            yield* this.series;
        }, set timestamps(arg) {
            throw new Error('Bad counter API. No cookie.');
        }, set seriesNames(arg) {
            throw new Error('Bad counter API. No cookie.');
        }, set seriesColors(arg) {
            throw new Error('Bad counter API. No cookie.');
        }, set samples(arg) {
            throw new Error('Bad counter API. No cookie.');
        }, addSeries(series) {
            series.counter = this;
            series.seriesIndex = this.series_.length;
            this.series_.push(series);
            return series;
        }, getSeries(idx) {
            return this.series_[idx];
        }, get series() {
            return this.series_;
        }, get numSeries() {
            return this.series_.length;
        }, get numSamples() {
            if (this.series_.length === 0) return 0;
            return this.series_[0].length;
        }, get timestamps() {
            if (this.series_.length === 0) return [];
            return this.series_[0].timestamps;
        }, getSampleStatistics(sampleIndices) {
            sampleIndices.sort();
            const ret = [];
            this.series_.forEach(function (series) {
                ret.push(series.getStatistics(sampleIndices));
            });
            return ret;
        }, shiftTimestampsForward(amount) {
            for (let i = 0; i < this.series_.length; ++i) {
                this.series_[i].shiftTimestampsForward(amount);
            }
        }, updateBounds() {
            this.totals = [];
            this.maxTotal = 0;
            this.bounds.reset();
            if (this.series_.length === 0) return;
            const firstSeries = this.series_[0];
            const lastSeries = this.series_[this.series_.length - 1];
            this.bounds.addValue(firstSeries.getTimestamp(0));
            this.bounds.addValue(lastSeries.getTimestamp(lastSeries.length - 1));
            const numSeries = this.numSeries;
            this.maxTotal = -Infinity;
            for (let i = 0; i < firstSeries.length; ++i) {
                let total = 0;
                this.series_.forEach(function (series) {
                    total += series.getSample(i).value;
                    this.totals.push(total);
                }.bind(this));
                this.maxTotal = Math.max(total, this.maxTotal);
            }
        }
    };
    Counter.compare = function (x, y) {
        let tmp = x.parent.compareTo(y.parent);
        if (tmp !== 0) return tmp;
        tmp = x.name.localeCompare(y.name);
        if (tmp === 0) return x.tid - y.tid;
        return tmp;
    };
    return {Counter,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Slice = tr.model.Slice;

    function CpuSlice(cat, title, colorId, start, args, opt_duration) {
        Slice.apply(this, arguments);
        this.threadThatWasRunning = undefined;
        this.cpu = undefined;
    }

    CpuSlice.prototype = {
        __proto__: Slice.prototype, get analysisTypeName() {
            return 'tr.ui.analysis.CpuSlice';
        }, getAssociatedTimeslice() {
            if (!this.threadThatWasRunning) {
                return undefined;
            }
            const timeSlices = this.threadThatWasRunning.timeSlices;
            for (let i = 0; i < timeSlices.length; i++) {
                const timeSlice = timeSlices[i];
                if (timeSlice.start !== this.start) {
                    continue;
                }
                if (timeSlice.duration !== this.duration) {
                    continue;
                }
                return timeSlice;
            }
            return undefined;
        }
    };
    tr.model.EventRegistry.register(CpuSlice, {name: 'cpuSlice', pluralName: 'cpuSlices'});
    return {CpuSlice,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function TimeToObjectInstanceMap(createObjectInstanceFunction, parent, scopedId) {
        this.createObjectInstanceFunction_ = createObjectInstanceFunction;
        this.parent = parent;
        this.scopedId = scopedId;
        this.instances = [];
    }

    TimeToObjectInstanceMap.prototype = {
        idWasCreated(category, name, ts) {
            if (this.instances.length === 0) {
                this.instances.push(this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts));
                this.instances[0].creationTsWasExplicit = true;
                return this.instances[0];
            }
            let lastInstance = this.instances[this.instances.length - 1];
            if (ts < lastInstance.deletionTs) {
                throw new Error('Mutation of the TimeToObjectInstanceMap must be ' + 'done in ascending timestamp order.');
            }
            lastInstance = this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts);
            lastInstance.creationTsWasExplicit = true;
            this.instances.push(lastInstance);
            return lastInstance;
        }, addSnapshot(category, name, ts, args, opt_baseTypeName) {
            if (this.instances.length === 0) {
                this.instances.push(this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts, opt_baseTypeName));
            }
            const i = tr.b.findIndexInSortedIntervals(this.instances, function (inst) {
                return inst.creationTs;
            }, function (inst) {
                return inst.deletionTs - inst.creationTs;
            }, ts);
            let instance;
            if (i < 0) {
                instance = this.instances[0];
                if (ts > instance.deletionTs || instance.creationTsWasExplicit) {
                    throw new Error('At the provided timestamp, no instance was still alive');
                }
                if (instance.snapshots.length !== 0) {
                    throw new Error('Cannot shift creationTs forward, ' + 'snapshots have been added. First snap was at ts=' +
                        instance.snapshots[0].ts + ' and creationTs was ' +
                        instance.creationTs);
                }
                instance.creationTs = ts;
            } else if (i >= this.instances.length) {
                instance = this.instances[this.instances.length - 1];
                if (ts >= instance.deletionTs) {
                    instance = this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts, opt_baseTypeName);
                    this.instances.push(instance);
                } else {
                    let lastValidIndex;
                    for (let i = this.instances.length - 1; i >= 0; i--) {
                        const tmp = this.instances[i];
                        if (ts >= tmp.deletionTs) break;
                        if (tmp.creationTsWasExplicit === false && tmp.snapshots.length === 0) {
                            lastValidIndex = i;
                        }
                    }
                    if (lastValidIndex === undefined) {
                        throw new Error('Cannot add snapshot. No instance was alive that was mutable.');
                    }
                    instance = this.instances[lastValidIndex];
                    instance.creationTs = ts;
                }
            } else {
                instance = this.instances[i];
            }
            return instance.addSnapshot(ts, args, name, opt_baseTypeName);
        }, get lastInstance() {
            if (this.instances.length === 0) return undefined;
            return this.instances[this.instances.length - 1];
        }, idWasDeleted(category, name, ts) {
            if (this.instances.length === 0) {
                this.instances.push(this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts));
            }
            let lastInstance = this.instances[this.instances.length - 1];
            if (ts < lastInstance.creationTs) {
                throw new Error('Cannot delete an id before it was created');
            }
            if (lastInstance.deletionTs === Number.MAX_VALUE) {
                lastInstance.wasDeleted(ts);
                return lastInstance;
            }
            if (ts < lastInstance.deletionTs) {
                throw new Error('id was already deleted earlier.');
            }
            lastInstance = this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts);
            this.instances.push(lastInstance);
            lastInstance.wasDeleted(ts);
            return lastInstance;
        }, getInstanceAt(ts) {
            const i = tr.b.findIndexInSortedIntervals(this.instances, function (inst) {
                return inst.creationTs;
            }, function (inst) {
                return inst.deletionTs - inst.creationTs;
            }, ts);
            if (i < 0) {
                if (this.instances[0].creationTsWasExplicit) {
                    return undefined;
                }
                return this.instances[0];
            } else if (i >= this.instances.length) {
                return undefined;
            }
            return this.instances[i];
        }
    };
    return {TimeToObjectInstanceMap,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ObjectInstance = tr.model.ObjectInstance;
    const ObjectSnapshot = tr.model.ObjectSnapshot;

    function ObjectCollection(parent) {
        tr.model.EventContainer.call(this);
        this.parent = parent;
        this.instanceMapsByScopedId_ = {};
        this.instancesByTypeName_ = {};
        this.createObjectInstance_ = this.createObjectInstance_.bind(this);
    }

    ObjectCollection.prototype = {
        __proto__: tr.model.EventContainer.prototype, * childEvents() {
            for (const instance of this.getAllObjectInstances()) {
                yield instance;
                yield* instance.snapshots;
            }
        }, createObjectInstance_(parent, scopedId, category, name, creationTs, opt_baseTypeName) {
            const constructor = tr.model.ObjectInstance.subTypes.getConstructor(category, name);
            const instance = new constructor(parent, scopedId, category, name, creationTs, opt_baseTypeName);
            const typeName = instance.typeName;
            let instancesOfTypeName = this.instancesByTypeName_[typeName];
            if (!instancesOfTypeName) {
                instancesOfTypeName = [];
                this.instancesByTypeName_[typeName] = instancesOfTypeName;
            }
            instancesOfTypeName.push(instance);
            return instance;
        }, getOrCreateInstanceMap_(scopedId) {
            let dict;
            if (scopedId.scope in this.instanceMapsByScopedId_) {
                dict = this.instanceMapsByScopedId_[scopedId.scope];
            } else {
                dict = {};
                this.instanceMapsByScopedId_[scopedId.scope] = dict;
            }
            let instanceMap = dict[scopedId.id];
            if (instanceMap) return instanceMap;
            instanceMap = new tr.model.TimeToObjectInstanceMap(this.createObjectInstance_, this.parent, scopedId);
            dict[scopedId.id] = instanceMap;
            return instanceMap;
        }, idWasCreated(scopedId, category, name, ts) {
            const instanceMap = this.getOrCreateInstanceMap_(scopedId);
            return instanceMap.idWasCreated(category, name, ts);
        }, addSnapshot(scopedId, category, name, ts, args, opt_baseTypeName) {
            const instanceMap = this.getOrCreateInstanceMap_(scopedId);
            const snapshot = instanceMap.addSnapshot(category, name, ts, args, opt_baseTypeName);
            if (snapshot.objectInstance.category !== category) {
                const msg = 'Added snapshot name=' + name + ' with cat=' + category + ' impossible. It instance was created/snapshotted with cat=' +
                    snapshot.objectInstance.category + ' name=' +
                    snapshot.objectInstance.name;
                throw new Error(msg);
            }
            if (opt_baseTypeName && snapshot.objectInstance.baseTypeName !== opt_baseTypeName) {
                throw new Error('Could not add snapshot with baseTypeName=' +
                    opt_baseTypeName + '. It ' + 'was previously created with name=' +
                    snapshot.objectInstance.baseTypeName);
            }
            if (snapshot.objectInstance.name !== name) {
                throw new Error('Could not add snapshot with name=' + name + '. It ' + 'was previously created with name=' +
                    snapshot.objectInstance.name);
            }
            return snapshot;
        }, idWasDeleted(scopedId, category, name, ts) {
            const instanceMap = this.getOrCreateInstanceMap_(scopedId);
            const deletedInstance = instanceMap.idWasDeleted(category, name, ts);
            if (!deletedInstance) return;
            if (deletedInstance.category !== category) {
                const msg = 'Deleting object ' + deletedInstance.name + ' with a different category ' + 'than when it was created. It previous had cat=' +
                    deletedInstance.category + ' but the delete command ' + 'had cat=' + category;
                throw new Error(msg);
            }
            if (deletedInstance.baseTypeName !== name) {
                throw new Error('Deletion requested for name=' +
                    name + ' could not proceed: ' + 'An existing object with baseTypeName=' +
                    deletedInstance.baseTypeName + ' existed.');
            }
        }, autoDeleteObjects(maxTimestamp) {
            for (const imapById of Object.values(this.instanceMapsByScopedId_)) {
                for (const i2imap of Object.values(imapById)) {
                    const lastInstance = i2imap.lastInstance;
                    if (lastInstance.deletionTs !== Number.MAX_VALUE) continue;
                    i2imap.idWasDeleted(lastInstance.category, lastInstance.name, maxTimestamp);
                    lastInstance.deletionTsWasExplicit = false;
                }
            }
        }, getObjectInstanceAt(scopedId, ts) {
            let instanceMap;
            if (scopedId.scope in this.instanceMapsByScopedId_) {
                instanceMap = this.instanceMapsByScopedId_[scopedId.scope][scopedId.id];
            }
            if (!instanceMap) return undefined;
            return instanceMap.getInstanceAt(ts);
        }, getSnapshotAt(scopedId, ts) {
            const instance = this.getObjectInstanceAt(scopedId, ts);
            if (!instance) return undefined;
            return instance.getSnapshotAt(ts);
        }, iterObjectInstances(iter, opt_this) {
            opt_this = opt_this || this;
            for (const imapById of Object.values(this.instanceMapsByScopedId_)) {
                for (const i2imap of Object.values(imapById)) {
                    i2imap.instances.forEach(iter, opt_this);
                }
            }
        }, getAllObjectInstances() {
            const instances = [];
            this.iterObjectInstances(function (i) {
                instances.push(i);
            });
            return instances;
        }, getAllInstancesNamed(name) {
            return this.instancesByTypeName_[name];
        }, getAllInstancesByTypeName() {
            return this.instancesByTypeName_;
        }, preInitializeAllObjects() {
            this.iterObjectInstances(function (instance) {
                instance.preInitialize();
            });
        }, initializeAllObjects() {
            this.iterObjectInstances(function (instance) {
                instance.initialize();
            });
        }, initializeInstances() {
            this.iterObjectInstances(function (instance) {
                instance.initialize();
            });
        }, updateBounds() {
            this.bounds.reset();
            this.iterObjectInstances(function (instance) {
                instance.updateBounds();
                this.bounds.addRange(instance.bounds);
            }, this);
        }, shiftTimestampsForward(amount) {
            this.iterObjectInstances(function (instance) {
                instance.shiftTimestampsForward(amount);
            });
        }, addCategoriesToDict(categoriesDict) {
            this.iterObjectInstances(function (instance) {
                categoriesDict[instance.category] = true;
            });
        }
    };
    return {ObjectCollection,};
});
'use strict';
tr.exportTo('tr.model', function () {
    class AsyncSliceGroup extends tr.model.EventContainer {
        constructor(parentContainer, opt_name) {
            super();
            this.parentContainer_ = parentContainer;
            this.name_ = opt_name;
            this.slices = [];
            this.viewSubGroups_ = undefined;
            this.nestedLevel_ = 0;
            this.hasNestedSubGroups_ = true;
            this.title_ = undefined;
        }

        get parentContainer() {
            return this.parentContainer_;
        }

        get model() {
            return this.parentContainer_.parent.model;
        }

        get stableId() {
            return this.parentContainer_.stableId + '.AsyncSliceGroup';
        }

        get title() {
            if (this.nested_level_ === 0) {
                return '<root>';
            }
            return this.title_;
        }

        getSettingsKey() {
            if (this.name_ === undefined) {
                return undefined;
            }
            const parentKey = this.parentContainer_.getSettingsKey();
            if (parentKey === undefined) {
                return undefined;
            }
            return parentKey + '.' + this.name_;
        }

        push(slice) {
            if (this.viewSubGroups_ !== undefined) {
                throw new Error('No new slices are allowed when view sub-groups already formed.');
            }
            slice.parentContainer = this.parentContainer;
            this.slices.push(slice);
            return slice;
        }

        get length() {
            return this.slices.length;
        }

        shiftTimestampsForward(amount) {
            for (const slice of this.childEvents()) {
                slice.start += amount;
            }
        }

        updateBounds() {
            this.bounds.reset();
            for (let i = 0; i < this.slices.length; i++) {
                this.bounds.addValue(this.slices[i].start);
                this.bounds.addValue(this.slices[i].end);
            }
        }

        autoCloseOpenSlices() {
            const maxTimestamp = this.parentContainer_.parent.model.bounds.max;
            for (const slice of this.childEvents()) {
                if (slice.didNotFinish) {
                    slice.duration = maxTimestamp - slice.start;
                }
            }
        }

        get viewSubGroups() {
            if (!this.hasNestedSubGroups_ || this.nestedLevel_ === 2) {
                return [];
            }
            if (this.viewSubGroups_ !== undefined) {
                return this.viewSubGroups_;
            }
            const subGroupsByTitle = new Map();
            for (const slice of this.slices) {
                let subGroupTitle = slice.viewSubGroupTitle;
                let hasNestedSubGroups = false;
                if (this.nestedLevel_ === 0 && slice.viewSubGroupGroupingKey !== undefined) {
                    subGroupTitle = slice.viewSubGroupGroupingKey;
                    hasNestedSubGroups = true;
                }
                let subGroup = subGroupsByTitle.get(subGroupTitle);
                if (subGroup === undefined) {
                    let name;
                    if (this.name_ !== undefined) {
                        name = this.name_ + '.' + subGroupTitle;
                    } else {
                        name = subGroupTitle;
                    }
                    subGroup = new AsyncSliceGroup(this.parentContainer_, name);
                    subGroup.title_ = subGroupTitle;
                    subGroup.hasNestedSubGroups_ = hasNestedSubGroups;
                    subGroup.nestedLevel_ = this.nestedLevel_ + 1;
                    subGroupsByTitle.set(subGroupTitle, subGroup);
                }
                subGroup.push(slice);
            }
            this.viewSubGroups_ = Array.from(subGroupsByTitle.values());
            this.viewSubGroups_.sort((a, b) => a.title.localeCompare(b.title));
            return this.viewSubGroups_;
        }

        * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
            for (const slice of this.slices) {
                if (slice.isTopLevel) {
                    yield* slice.findTopmostSlicesRelativeToThisSlice(eventPredicate, opt_this);
                }
            }
        }

        * childEvents() {
            for (const slice of this.slices) {
                yield slice;
                yield* slice.enumerateAllDescendents();
            }
        }

        * childEventContainers() {
        }
    }

    return {AsyncSliceGroup,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Slice = tr.model.Slice;

    function ThreadSlice(cat, title, colorId, start, args, opt_duration, opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId) {
        Slice.call(this, cat, title, colorId, start, args, opt_duration, opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId);
        this.subSlices = [];
    }

    ThreadSlice.prototype = {
        __proto__: Slice.prototype, get overlappingSamples() {
            const samples = new tr.model.EventSet();
            if (!this.parentContainer || !this.parentContainer.samples) {
                return samples;
            }
            this.parentContainer.samples.forEach(function (sample) {
                if (this.start <= sample.start && sample.start <= this.end) {
                    samples.push(sample);
                }
            }, this);
            return samples;
        }
    };
    tr.model.EventRegistry.register(ThreadSlice, {name: 'slice', pluralName: 'slices'});
    return {ThreadSlice,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ColorScheme = tr.b.ColorScheme;
    const ThreadSlice = tr.model.ThreadSlice;

    function getSliceLo(s) {
        return s.start;
    }

    function getSliceHi(s) {
        return s.end;
    }

    function SliceGroup(parentContainer, opt_sliceConstructor, opt_name) {
        tr.model.EventContainer.call(this);
        this.parentContainer_ = parentContainer;
        const sliceConstructor = opt_sliceConstructor || ThreadSlice;
        this.sliceConstructor = sliceConstructor;
        this.sliceConstructorSubTypes = this.sliceConstructor.subTypes;
        if (!this.sliceConstructorSubTypes) {
            throw new Error('opt_sliceConstructor must have a subtype registry.');
        }
        this.openPartialSlices_ = [];
        this.slices = [];
        this.topLevelSlices = [];
        this.haveTopLevelSlicesBeenBuilt = false;
        this.name_ = opt_name;
        if (this.model === undefined) {
            throw new Error('SliceGroup must have model defined.');
        }
    }

    SliceGroup.prototype = {
        __proto__: tr.model.EventContainer.prototype,
        get parentContainer() {
            return this.parentContainer_;
        },
        get model() {
            return this.parentContainer_.model;
        },
        get stableId() {
            return this.parentContainer_.stableId + '.SliceGroup';
        },
        getSettingsKey() {
            if (!this.name_) return undefined;
            const parentKey = this.parentContainer_.getSettingsKey();
            if (!parentKey) return undefined;
            return parentKey + '.' + this.name;
        },
        get length() {
            return this.slices.length;
        },
        pushSlice(slice) {
            this.haveTopLevelSlicesBeenBuilt = false;
            slice.parentContainer = this.parentContainer_;
            this.slices.push(slice);
            return slice;
        },
        pushSlices(slices) {
            this.haveTopLevelSlicesBeenBuilt = false;
            slices.forEach(function (slice) {
                slice.parentContainer = this.parentContainer_;
                this.slices.push(slice);
            }, this);
        },
        beginSlice(category, title, ts, opt_args, opt_tts, opt_argsStripped, opt_colorId, opt_bindId) {
            const colorId = opt_colorId || ColorScheme.getColorIdForGeneralPurposeString(title);
            const sliceConstructorSubTypes = this.sliceConstructorSubTypes;
            const sliceType = sliceConstructorSubTypes.getConstructor(category, title);
            const slice = new sliceType(category, title, colorId, ts, opt_args ? opt_args : {}, null, opt_tts, undefined, opt_argsStripped, opt_bindId);
            this.openPartialSlices_.push(slice);
            slice.didNotFinish = true;
            this.pushSlice(slice);
            return slice;
        },
        isTimestampValidForBeginOrEnd(ts) {
            if (!this.openPartialSlices_.length) return true;
            const top = this.openPartialSlices_[this.openPartialSlices_.length - 1];
            return ts >= top.start;
        },
        get openSliceCount() {
            return this.openPartialSlices_.length;
        },
        get mostRecentlyOpenedPartialSlice() {
            if (!this.openPartialSlices_.length) return undefined;
            return this.openPartialSlices_[this.openPartialSlices_.length - 1];
        },
        endSlice(ts, opt_tts, opt_colorId) {
            if (!this.openSliceCount) {
                throw new Error('endSlice called without an open slice');
            }
            const slice = this.openPartialSlices_[this.openSliceCount - 1];
            this.openPartialSlices_.splice(this.openSliceCount - 1, 1);
            if (ts < slice.start) {
                throw new Error('Slice ' + slice.title + ' end time is before its start.');
            }
            slice.duration = ts - slice.start;
            slice.didNotFinish = false;
            slice.colorId = opt_colorId || slice.colorId;
            if (opt_tts && slice.cpuStart !== undefined) {
                slice.cpuDuration = opt_tts - slice.cpuStart;
            }
            return slice;
        },
        pushCompleteSlice(category, title, ts, duration, tts, cpuDuration, opt_args, opt_argsStripped, opt_colorId, opt_bindId) {
            const colorId = opt_colorId || ColorScheme.getColorIdForGeneralPurposeString(title);
            const sliceConstructorSubTypes = this.sliceConstructorSubTypes;
            const sliceType = sliceConstructorSubTypes.getConstructor(category, title);
            const slice = new sliceType(category, title, colorId, ts, opt_args ? opt_args : {}, duration, tts, cpuDuration, opt_argsStripped, opt_bindId);
            if (duration === undefined) {
                slice.didNotFinish = true;
            }
            this.pushSlice(slice);
            return slice;
        },
        autoCloseOpenSlices() {
            this.updateBounds();
            const maxTimestamp = this.bounds.max;
            for (let sI = 0; sI < this.slices.length; sI++) {
                const slice = this.slices[sI];
                if (slice.didNotFinish) {
                    slice.duration = maxTimestamp - slice.start;
                }
            }
            this.openPartialSlices_ = [];
        },
        shiftTimestampsForward(amount) {
            for (let sI = 0; sI < this.slices.length; sI++) {
                const slice = this.slices[sI];
                slice.start = (slice.start + amount);
            }
        },
        updateBounds() {
            this.bounds.reset();
            for (let i = 0; i < this.slices.length; i++) {
                this.bounds.addValue(this.slices[i].start);
                this.bounds.addValue(this.slices[i].end);
            }
        },
        copySlice(slice) {
            const sliceConstructorSubTypes = this.sliceConstructorSubTypes;
            const sliceType = sliceConstructorSubTypes.getConstructor(slice.category, slice.title);
            const newSlice = new sliceType(slice.category, slice.title, slice.colorId, slice.start, slice.args, slice.duration, slice.cpuStart, slice.cpuDuration);
            newSlice.didNotFinish = slice.didNotFinish;
            return newSlice;
        },
        * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
            if (!this.haveTopLevelSlicesBeenBuilt) {
                throw new Error('Nope');
            }
            for (const s of this.topLevelSlices) {
                yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
            }
        },
        * childEvents() {
            yield* this.slices;
        },
        * childEventContainers() {
        },
        * getDescendantEventsInSortedRanges(ranges, opt_containerPredicate) {
            if (ranges.length === 0 || (opt_containerPredicate !== undefined && !opt_containerPredicate(this))) {
                return;
            }
            let rangeIndex = 0;
            let range = ranges[rangeIndex];
            for (const event of this.childEvents()) {
                while (event.start > range.max) {
                    rangeIndex++;
                    if (rangeIndex >= ranges.length) return;
                    range = ranges[rangeIndex];
                }
                if (event.end >= range.min) yield event;
            }
        },
        getSlicesOfName(title) {
            const slices = [];
            for (let i = 0; i < this.slices.length; i++) {
                if (this.slices[i].title === title) {
                    slices.push(this.slices[i]);
                }
            }
            return slices;
        },
        iterSlicesInTimeRange(callback, start, end) {
            const ret = [];
            tr.b.iterateOverIntersectingIntervals(this.topLevelSlices, function (s) {
                return s.start;
            }, function (s) {
                return s.duration;
            }, start, end, function (topLevelSlice) {
                callback(topLevelSlice);
                for (const slice of topLevelSlice.enumerateAllDescendents()) {
                    callback(slice);
                }
            });
            return ret;
        },
        findFirstSlice() {
            if (!this.haveTopLevelSlicesBeenBuilt) {
                throw new Error('Nope');
            }
            if (0 === this.slices.length) return undefined;
            return this.slices[0];
        },
        findSliceAtTs(ts) {
            if (!this.haveTopLevelSlicesBeenBuilt) throw new Error('Nope');
            let i = tr.b.findIndexInSortedClosedIntervals(this.topLevelSlices, getSliceLo, getSliceHi, ts);
            if (i === -1 || i === this.topLevelSlices.length) {
                return undefined;
            }
            let curSlice = this.topLevelSlices[i];
            while (true) {
                i = tr.b.findIndexInSortedClosedIntervals(curSlice.subSlices, getSliceLo, getSliceHi, ts);
                if (i === -1 || i === curSlice.subSlices.length) {
                    return curSlice;
                }
                curSlice = curSlice.subSlices[i];
            }
        },
        findNextSliceAfter(ts, refGuid) {
            let i = tr.b.findLowIndexInSortedArray(this.slices, getSliceLo, ts);
            if (i === this.slices.length) {
                return undefined;
            }
            for (; i < this.slices.length; i++) {
                const slice = this.slices[i];
                if (slice.start > ts) return slice;
                if (slice.guid <= refGuid) continue;
                return slice;
            }
            return undefined;
        },
        hasCpuDuration_() {
            if (this.slices.some(function (slice) {
                return slice.cpuDuration !== undefined;
            })) return true;
            return false;
        },
        createSubSlices() {
            this.haveTopLevelSlicesBeenBuilt = true;
            this.createSubSlicesImpl_();
            if (!this.hasCpuDuration_() && this.parentContainer.timeSlices) {
                this.addCpuTimeToSubslices_(this.parentContainer.timeSlices);
            }
            this.slices.forEach(function (slice) {
                let selfTime = slice.duration;
                for (let i = 0; i < slice.subSlices.length; i++) {
                    selfTime -= slice.subSlices[i].duration;
                }
                slice.selfTime = selfTime;
                if (slice.cpuDuration === undefined) return;
                let cpuSelfTime = slice.cpuDuration;
                for (let i = 0; i < slice.subSlices.length; i++) {
                    if (slice.subSlices[i].cpuDuration !== undefined) {
                        cpuSelfTime -= slice.subSlices[i].cpuDuration;
                    }
                }
                slice.cpuSelfTime = cpuSelfTime;
            });
        },
        createSubSlicesImpl_() {
            const precisionUnit = this.model.intrinsicTimeUnit;

            function addSliceIfBounds(parent, child) {
                if (parent.bounds(child, precisionUnit)) {
                    child.parentSlice = parent;
                    if (parent.subSlices === undefined) {
                        parent.subSlices = [];
                    }
                    parent.subSlices.push(child);
                    return true;
                }
                return false;
            }

            if (!this.slices.length) return;
            const ops = [];
            for (let i = 0; i < this.slices.length; i++) {
                if (this.slices[i].subSlices) {
                    this.slices[i].subSlices.splice(0, this.slices[i].subSlices.length);
                }
                ops.push(i);
            }
            const originalSlices = this.slices;
            ops.sort(function (ix, iy) {
                const x = originalSlices[ix];
                const y = originalSlices[iy];
                if (x.start !== y.start) {
                    return x.start - y.start;
                }
                return ix - iy;
            });
            const slices = new Array(this.slices.length);
            for (let i = 0; i < ops.length; i++) {
                slices[i] = originalSlices[ops[i]];
            }
            let rootSlice = slices[0];
            this.topLevelSlices = [];
            this.topLevelSlices.push(rootSlice);
            rootSlice.isTopLevel = true;
            for (let i = 1; i < slices.length; i++) {
                const slice = slices[i];
                while (rootSlice !== undefined && (!addSliceIfBounds(rootSlice, slice))) {
                    rootSlice = rootSlice.parentSlice;
                }
                if (rootSlice === undefined) {
                    this.topLevelSlices.push(slice);
                    slice.isTopLevel = true;
                }
                rootSlice = slice;
            }
            this.slices = slices;
        },
        addCpuTimeToSubslices_(timeSlices) {
            const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
            let sliceIdx = 0;
            timeSlices.forEach(function (timeSlice) {
                if (timeSlice.schedulingState === SCHEDULING_STATE.RUNNING) {
                    while (sliceIdx < this.topLevelSlices.length) {
                        if (this.addCpuTimeToSubslice_(this.topLevelSlices[sliceIdx], timeSlice)) {
                            sliceIdx++;
                        } else {
                            break;
                        }
                    }
                }
            }, this);
        },
        addCpuTimeToSubslice_(slice, timeSlice) {
            if (slice.start > timeSlice.end || slice.end < timeSlice.start) {
                return slice.end <= timeSlice.end;
            }
            let duration = timeSlice.duration;
            if (slice.start > timeSlice.start) {
                duration -= slice.start - timeSlice.start;
            }
            if (timeSlice.end > slice.end) {
                duration -= timeSlice.end - slice.end;
            }
            if (slice.cpuDuration) {
                slice.cpuDuration += duration;
            } else {
                slice.cpuDuration = duration;
            }
            for (let i = 0; i < slice.subSlices.length; i++) {
                this.addCpuTimeToSubslice_(slice.subSlices[i], timeSlice);
            }
            return slice.end <= timeSlice.end;
        }
    };
    SliceGroup.merge = function (groupA, groupB) {
        if (groupA.openPartialSlices_.length > 0) {
            throw new Error('groupA has open partial slices');
        }
        if (groupB.openPartialSlices_.length > 0) {
            throw new Error('groupB has open partial slices');
        }
        if (groupA.parentContainer !== groupB.parentContainer) {
            throw new Error('Different parent threads. Cannot merge');
        }
        if (groupA.sliceConstructor !== groupB.sliceConstructor) {
            throw new Error('Different slice constructors. Cannot merge');
        }
        const result = new SliceGroup(groupA.parentContainer, groupA.sliceConstructor, groupA.name_);
        const slicesA = groupA.slices;
        const slicesB = groupB.slices;
        let idxA = 0;
        let idxB = 0;
        const openA = [];
        const openB = [];
        const splitOpenSlices = function (when) {
            for (let i = 0; i < openB.length; i++) {
                const oldSlice = openB[i];
                const oldEnd = oldSlice.end;
                if (when < oldSlice.start || oldEnd < when) {
                    throw new Error('slice should not be split');
                }
                const newSlice = result.copySlice(oldSlice);
                newSlice.start = when;
                newSlice.duration = oldEnd - when;
                if (newSlice.title.indexOf(' (cont.)') === -1) {
                    newSlice.title += ' (cont.)';
                }
                oldSlice.duration = when - oldSlice.start;
                openB[i] = newSlice;
                result.pushSlice(newSlice);
            }
        };
        const closeOpenSlices = function (upTo) {
            while (openA.length > 0 || openB.length > 0) {
                const nextA = openA[openA.length - 1];
                const nextB = openB[openB.length - 1];
                const endA = nextA && nextA.end;
                const endB = nextB && nextB.end;
                if ((endA === undefined || endA > upTo) && (endB === undefined || endB > upTo)) {
                    return;
                }
                if (endB === undefined || endA < endB) {
                    splitOpenSlices(endA);
                    openA.pop();
                } else {
                    openB.pop();
                }
            }
        };
        while (idxA < slicesA.length || idxB < slicesB.length) {
            const sA = slicesA[idxA];
            const sB = slicesB[idxB];
            let nextSlice;
            let isFromB;
            if (sA === undefined || (sB !== undefined && sA.start > sB.start)) {
                nextSlice = result.copySlice(sB);
                isFromB = true;
                idxB++;
            } else {
                nextSlice = result.copySlice(sA);
                isFromB = false;
                idxA++;
            }
            closeOpenSlices(nextSlice.start);
            result.pushSlice(nextSlice);
            if (isFromB) {
                openB.push(nextSlice);
            } else {
                splitOpenSlices(nextSlice.start);
                openA.push(nextSlice);
            }
        }
        closeOpenSlices();
        return result;
    };
    return {SliceGroup,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const AsyncSlice = tr.model.AsyncSlice;
    const AsyncSliceGroup = tr.model.AsyncSliceGroup;
    const SliceGroup = tr.model.SliceGroup;
    const ThreadSlice = tr.model.ThreadSlice;
    const ThreadTimeSlice = tr.model.ThreadTimeSlice;

    function Thread(parent, tid) {
        if (!parent) {
            throw new Error('Parent must be provided.');
        }
        tr.model.EventContainer.call(this);
        this.parent = parent;
        this.sortIndex = 0;
        this.tid = tid;
        this.name = undefined;
        this.samples_ = undefined;
        this.sliceGroup = new SliceGroup(this, ThreadSlice, 'slices');
        this.timeSlices = undefined;
        this.kernelSliceGroup = new SliceGroup(this, ThreadSlice, 'kernel-slices');
        this.asyncSliceGroup = new AsyncSliceGroup(this, 'async-slices');
    }

    Thread.prototype = {
        __proto__: tr.model.EventContainer.prototype, get model() {
            return this.parent.model;
        }, get stableId() {
            return this.parent.stableId + '.' + this.tid;
        }, compareTo(that) {
            return Thread.compare(this, that);
        }, * childEventContainers() {
            if (this.sliceGroup.length) {
                yield this.sliceGroup;
            }
            if (this.kernelSliceGroup.length) {
                yield this.kernelSliceGroup;
            }
            if (this.asyncSliceGroup.length) {
                yield this.asyncSliceGroup;
            }
        }, * childEvents() {
            if (this.timeSlices) {
                yield* this.timeSlices;
            }
        }, iterateAllPersistableObjects(cb) {
            cb(this);
            if (this.sliceGroup.length) {
                cb(this.sliceGroup);
            }
            this.asyncSliceGroup.viewSubGroups.forEach(cb);
        }, shiftTimestampsForward(amount) {
            this.sliceGroup.shiftTimestampsForward(amount);
            if (this.timeSlices) {
                for (let i = 0; i < this.timeSlices.length; i++) {
                    const slice = this.timeSlices[i];
                    slice.start += amount;
                }
            }
            this.kernelSliceGroup.shiftTimestampsForward(amount);
            this.asyncSliceGroup.shiftTimestampsForward(amount);
        }, get isEmpty() {
            if (this.sliceGroup.length) return false;
            if (this.sliceGroup.openSliceCount) return false;
            if (this.timeSlices && this.timeSlices.length) return false;
            if (this.kernelSliceGroup.length) return false;
            if (this.asyncSliceGroup.length) return false;
            if (this.samples_.length) return false;
            return true;
        }, updateBounds() {
            this.bounds.reset();
            this.sliceGroup.updateBounds();
            this.bounds.addRange(this.sliceGroup.bounds);
            this.kernelSliceGroup.updateBounds();
            this.bounds.addRange(this.kernelSliceGroup.bounds);
            this.asyncSliceGroup.updateBounds();
            this.bounds.addRange(this.asyncSliceGroup.bounds);
            if (this.timeSlices && this.timeSlices.length) {
                this.bounds.addValue(this.timeSlices[0].start);
                this.bounds.addValue(this.timeSlices[this.timeSlices.length - 1].end);
            }
            if (this.samples_ && this.samples_.length) {
                this.bounds.addValue(this.samples_[0].start);
                this.bounds.addValue(this.samples_[this.samples_.length - 1].end);
            }
        }, addCategoriesToDict(categoriesDict) {
            for (let i = 0; i < this.sliceGroup.length; i++) {
                categoriesDict[this.sliceGroup.slices[i].category] = true;
            }
            for (let i = 0; i < this.kernelSliceGroup.length; i++) {
                categoriesDict[this.kernelSliceGroup.slices[i].category] = true;
            }
            for (let i = 0; i < this.asyncSliceGroup.length; i++) {
                categoriesDict[this.asyncSliceGroup.slices[i].category] = true;
            }
            if (this.samples_) {
                for (let i = 0; i < this.samples_.length; i++) {
                    categoriesDict[this.samples_[i].category] = true;
                }
            }
        }, autoCloseOpenSlices() {
            this.sliceGroup.autoCloseOpenSlices();
            this.asyncSliceGroup.autoCloseOpenSlices();
            this.kernelSliceGroup.autoCloseOpenSlices();
        }, mergeKernelWithUserland() {
            if (this.kernelSliceGroup.length > 0) {
                const newSlices = SliceGroup.merge(this.sliceGroup, this.kernelSliceGroup);
                this.sliceGroup.slices = newSlices.slices;
                this.kernelSliceGroup = new SliceGroup(this);
                this.updateBounds();
            }
        }, createSubSlices() {
            this.sliceGroup.createSubSlices();
            this.samples_ = this.parent.model.samples.filter(sample => sample.thread === this);
        }, get userFriendlyName() {
            return this.name || this.tid;
        }, get userFriendlyDetails() {
            return 'tid: ' + this.tid +
                (this.name ? ', name: ' + this.name : '');
        }, getSettingsKey() {
            if (!this.name) return undefined;
            const parentKey = this.parent.getSettingsKey();
            if (!parentKey) return undefined;
            return parentKey + '.' + this.name;
        }, getProcess() {
            return this.parent;
        }, indexOfTimeSlice(timeSlice) {
            const i = tr.b.findLowIndexInSortedArray(this.timeSlices, function (slice) {
                return slice.start;
            }, timeSlice.start);
            if (this.timeSlices[i] !== timeSlice) return undefined;
            return i;
        }, sumOverToplevelSlicesInRange(range, func) {
            let sum = 0;
            tr.b.iterateOverIntersectingIntervals(this.sliceGroup.topLevelSlices, slice => slice.start, slice => slice.end, range.min, range.max, slice => {
                let fractionOfSliceInsideRangeOfInterest = 1;
                if (slice.duration > 0) {
                    const intersection = range.findIntersection(slice.range);
                    fractionOfSliceInsideRangeOfInterest = intersection.duration / slice.duration;
                }
                sum += func(slice) * fractionOfSliceInsideRangeOfInterest;
            });
            return sum;
        }, getCpuTimeForRange(range) {
            return this.sumOverToplevelSlicesInRange(range, slice => slice.cpuDuration || 0);
        }, getNumToplevelSlicesForRange(range) {
            return this.sumOverToplevelSlicesInRange(range, slice => 1);
        }, getSchedulingStatsForRange(start, end) {
            const stats = {};
            if (!this.timeSlices) return stats;

            function addStatsForSlice(threadTimeSlice) {
                const overlapStart = Math.max(threadTimeSlice.start, start);
                const overlapEnd = Math.min(threadTimeSlice.end, end);
                const schedulingState = threadTimeSlice.schedulingState;
                if (!(schedulingState in stats)) stats[schedulingState] = 0;
                stats[schedulingState] += overlapEnd - overlapStart;
            }

            tr.b.iterateOverIntersectingIntervals(this.timeSlices, function (x) {
                return x.start;
            }, function (x) {
                return x.end;
            }, start, end, addStatsForSlice);
            return stats;
        }, get samples() {
            return this.samples_;
        }, get type() {
            const re = /^[^0-9|\/]+/;
            const matches = re.exec(this.name);
            if (matches && matches[0]) return matches[0];
            throw new Error('Could not determine thread type for thread name ' +
                this.name);
        }
    };
    Thread.compare = function (x, y) {
        let tmp = x.parent.compareTo(y.parent);
        if (tmp) return tmp;
        tmp = x.sortIndex - y.sortIndex;
        if (tmp) return tmp;
        if (x.name !== undefined) {
            if (y.name !== undefined) {
                tmp = x.name.localeCompare(y.name);
            } else {
                tmp = -1;
            }
        } else if (y.name !== undefined) {
            tmp = 1;
        }
        if (tmp) return tmp;
        return x.tid - y.tid;
    };
    return {Thread,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Thread = tr.model.Thread;
    const Counter = tr.model.Counter;

    function ProcessBase(model) {
        if (!model) {
            throw new Error('Must provide a model');
        }
        tr.model.EventContainer.call(this);
        this.model = model;
        this.threads = {};
        this.counters = {};
        this.objects = new tr.model.ObjectCollection(this);
        this.sortIndex = 0;
    }

    ProcessBase.compare = function (x, y) {
        return x.sortIndex - y.sortIndex;
    };
    ProcessBase.prototype = {
        __proto__: tr.model.EventContainer.prototype, get stableId() {
            throw new Error('Not implemented');
        }, * childEventContainers() {
            yield* Object.values(this.threads);
            yield* Object.values(this.counters);
            yield this.objects;
        }, iterateAllPersistableObjects(cb) {
            cb(this);
            for (const tid in this.threads) {
                this.threads[tid].iterateAllPersistableObjects(cb);
            }
        }, get numThreads() {
            let n = 0;
            for (const p in this.threads) {
                n++;
            }
            return n;
        }, shiftTimestampsForward(amount) {
            for (const child of this.childEventContainers()) {
                child.shiftTimestampsForward(amount);
            }
        }, autoCloseOpenSlices() {
            for (const tid in this.threads) {
                const thread = this.threads[tid];
                thread.autoCloseOpenSlices();
            }
        }, autoDeleteObjects(maxTimestamp) {
            this.objects.autoDeleteObjects(maxTimestamp);
        }, preInitializeObjects() {
            this.objects.preInitializeAllObjects();
        }, initializeObjects() {
            this.objects.initializeAllObjects();
        }, mergeKernelWithUserland() {
            for (const tid in this.threads) {
                const thread = this.threads[tid];
                thread.mergeKernelWithUserland();
            }
        }, updateBounds() {
            this.bounds.reset();
            for (const tid in this.threads) {
                this.threads[tid].updateBounds();
                this.bounds.addRange(this.threads[tid].bounds);
            }
            for (const id in this.counters) {
                this.counters[id].updateBounds();
                this.bounds.addRange(this.counters[id].bounds);
            }
            this.objects.updateBounds();
            this.bounds.addRange(this.objects.bounds);
        }, addCategoriesToDict(categoriesDict) {
            for (const tid in this.threads) {
                this.threads[tid].addCategoriesToDict(categoriesDict);
            }
            for (const id in this.counters) {
                categoriesDict[this.counters[id].category] = true;
            }
            this.objects.addCategoriesToDict(categoriesDict);
        }, findAllThreadsMatching(predicate, opt_this) {
            const threads = [];
            for (const tid in this.threads) {
                const thread = this.threads[tid];
                if (predicate.call(opt_this, thread)) {
                    threads.push(thread);
                }
            }
            return threads;
        }, findAllThreadsNamed(name) {
            const threads = this.findAllThreadsMatching(function (thread) {
                if (!thread.name) return false;
                return thread.name === name;
            });
            return threads;
        }, findAtMostOneThreadNamed(name) {
            const threads = this.findAllThreadsNamed(name);
            if (threads.length === 0) return undefined;
            if (threads.length > 1) {
                throw new Error('Expected no more than one ' + name);
            }
            return threads[0];
        }, pruneEmptyContainers() {
            const threadsToKeep = {};
            for (const tid in this.threads) {
                const thread = this.threads[tid];
                if (!thread.isEmpty) {
                    threadsToKeep[tid] = thread;
                }
            }
            this.threads = threadsToKeep;
        }, getThread(tid) {
            return this.threads[tid];
        }, getOrCreateThread(tid) {
            if (!this.threads[tid]) {
                this.threads[tid] = new Thread(this, tid);
            }
            return this.threads[tid];
        }, getOrCreateCounter(cat, name) {
            const id = cat + '.' + name;
            if (!this.counters[id]) {
                this.counters[id] = new Counter(this, id, cat, name);
            }
            return this.counters[id];
        }, getSettingsKey() {
            throw new Error('Not implemented');
        }, createSubSlices() {
            for (const tid in this.threads) {
                this.threads[tid].createSubSlices();
            }
        }
    };
    return {ProcessBase,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Counter = tr.model.Counter;
    const CpuSlice = tr.model.CpuSlice;

    function Cpu(kernel, number) {
        if (kernel === undefined || number === undefined) {
            throw new Error('Missing arguments');
        }
        this.kernel = kernel;
        this.cpuNumber = number;
        this.slices = [];
        this.counters = {};
        this.bounds_ = new tr.b.math.Range();
        this.samples_ = undefined;
        this.lastActiveTimestamp_ = undefined;
        this.lastActiveThread_ = undefined;
        this.lastActiveName_ = undefined;
        this.lastActiveArgs_ = undefined;
    }

    Cpu.prototype = {
        __proto__: tr.model.EventContainer.prototype, get samples() {
            return this.samples_;
        }, get userFriendlyName() {
            return 'CPU ' + this.cpuNumber;
        }, * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
            for (const s of this.slices) {
                yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate, opt_this);
            }
        }, * childEvents() {
            yield* this.slices;
            if (this.samples_) {
                yield* this.samples_;
            }
        }, * childEventContainers() {
            yield* Object.values(this.counters);
        }, getOrCreateCounter(cat, name) {
            const id = cat + '.' + name;
            if (!this.counters[id]) {
                this.counters[id] = new Counter(this, id, cat, name);
            }
            return this.counters[id];
        }, getCounter(cat, name) {
            const id = cat + '.' + name;
            if (!this.counters[id]) {
                return undefined;
            }
            return this.counters[id];
        }, shiftTimestampsForward(amount) {
            for (let sI = 0; sI < this.slices.length; sI++) {
                this.slices[sI].start = (this.slices[sI].start + amount);
            }
            for (const id in this.counters) {
                this.counters[id].shiftTimestampsForward(amount);
            }
        }, updateBounds() {
            this.bounds_.reset();
            if (this.slices.length) {
                this.bounds_.addValue(this.slices[0].start);
                this.bounds_.addValue(this.slices[this.slices.length - 1].end);
            }
            for (const id in this.counters) {
                this.counters[id].updateBounds();
                this.bounds_.addRange(this.counters[id].bounds);
            }
            if (this.samples_ && this.samples_.length) {
                this.bounds_.addValue(this.samples_[0].start);
                this.bounds_.addValue(this.samples_[this.samples_.length - 1].end);
            }
        }, createSubSlices() {
            this.samples_ = this.kernel.model.samples.filter(function (sample) {
                return sample.cpu === this;
            }, this);
        }, addCategoriesToDict(categoriesDict) {
            for (let i = 0; i < this.slices.length; i++) {
                categoriesDict[this.slices[i].category] = true;
            }
            for (const id in this.counters) {
                categoriesDict[this.counters[id].category] = true;
            }
            for (let i = 0; i < this.samples_.length; i++) {
                categoriesDict[this.samples_[i].category] = true;
            }
        }, indexOf(cpuSlice) {
            const i = tr.b.findLowIndexInSortedArray(this.slices, function (slice) {
                return slice.start;
            }, cpuSlice.start);
            if (this.slices[i] !== cpuSlice) return undefined;
            return i;
        }, closeActiveThread(endTimestamp, args) {
            if (this.lastActiveThread_ === undefined || this.lastActiveThread_ === 0) {
                return;
            }
            if (endTimestamp < this.lastActiveTimestamp_) {
                throw new Error('The end timestamp of a thread running on CPU ' +
                    this.cpuNumber + ' is before its start timestamp.');
            }
            for (const key in args) {
                this.lastActiveArgs_[key] = args[key];
            }
            const duration = endTimestamp - this.lastActiveTimestamp_;
            const slice = new tr.model.CpuSlice('', this.lastActiveName_, ColorScheme.getColorIdForGeneralPurposeString(this.lastActiveName_), this.lastActiveTimestamp_, this.lastActiveArgs_, duration);
            slice.cpu = this;
            this.slices.push(slice);
            this.lastActiveTimestamp_ = undefined;
            this.lastActiveThread_ = undefined;
            this.lastActiveName_ = undefined;
            this.lastActiveArgs_ = undefined;
        }, switchActiveThread(timestamp, oldThreadArgs, newThreadId, newThreadName, newThreadArgs) {
            this.closeActiveThread(timestamp, oldThreadArgs);
            this.lastActiveTimestamp_ = timestamp;
            this.lastActiveThread_ = newThreadId;
            this.lastActiveName_ = newThreadName;
            this.lastActiveArgs_ = newThreadArgs;
        }, getFreqStatsForRange(range) {
            const stats = {};

            function addStatsForFreq(freqSample, index) {
                const freqEnd = (index < freqSample.series_.length - 1) ? freqSample.series_.samples_[index + 1].timestamp : range.max;
                const freqRange = tr.b.math.Range.fromExplicitRange(freqSample.timestamp, freqEnd);
                const intersection = freqRange.findIntersection(range);
                if (!(freqSample.value in stats)) {
                    stats[freqSample.value] = 0;
                }
                stats[freqSample.value] += intersection.duration;
            }

            const freqCounter = this.getCounter('', 'Clock Frequency');
            if (freqCounter !== undefined) {
                const freqSeries = freqCounter.getSeries(0);
                if (!freqSeries) return;
                tr.b.iterateOverIntersectingIntervals(freqSeries.samples_, function (x) {
                    return x.timestamp;
                }, function (x, index) {
                    if (index < freqSeries.length - 1) {
                        return freqSeries.samples_[index + 1].timestamp;
                    }
                    return range.max;
                }, range.min, range.max, addStatsForFreq);
            }
            return stats;
        }
    };
    Cpu.compare = function (x, y) {
        return x.cpuNumber - y.cpuNumber;
    };
    return {Cpu,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Event = tr.model.Event;
    const EventRegistry = tr.model.EventRegistry;

    function PowerSample(series, start, powerInW) {
        Event.call(this);
        this.series_ = series;
        this.start_ = parseFloat(start);
        this.powerInW_ = parseFloat(powerInW);
    }

    PowerSample.prototype = {
        __proto__: Event.prototype, get series() {
            return this.series_;
        }, get start() {
            return this.start_;
        }, set start(value) {
            this.start_ = value;
        }, get powerInW() {
            return this.powerInW_;
        }, set powerInW(value) {
            this.powerInW_ = value;
        }, addBoundsToRange(range) {
            range.addValue(this.start);
        }
    };
    EventRegistry.register(PowerSample, {name: 'powerSample', pluralName: 'powerSamples'});
    return {PowerSample,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const PowerSample = tr.model.PowerSample;

    function PowerSeries(device) {
        tr.model.EventContainer.call(this);
        this.device_ = device;
        this.samples_ = [];
    }

    PowerSeries.prototype = {
        __proto__: tr.model.EventContainer.prototype, get device() {
            return this.device_;
        }, get samples() {
            return this.samples_;
        }, get stableId() {
            return this.device_.stableId + '.PowerSeries';
        }, addPowerSample(ts, val) {
            const sample = new PowerSample(this, ts, val);
            this.samples_.push(sample);
            return sample;
        }, getEnergyConsumedInJ(start, end) {
            const measurementRange = tr.b.math.Range.fromExplicitRange(start, end);
            let energyConsumedInJ = 0;
            let startIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, start) - 1;
            const endIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, end);
            if (startIndex < 0) {
                startIndex = 0;
            }
            for (let i = startIndex; i < endIndex; i++) {
                const sample = this.samples[i];
                const nextSample = this.samples[i + 1];
                const sampleRange = new tr.b.math.Range();
                sampleRange.addValue(sample.start);
                sampleRange.addValue(nextSample ? nextSample.start : sample.start);
                const intersectionRangeInMs = measurementRange.findIntersection(sampleRange);
                const durationInS = tr.b.convertUnit(intersectionRangeInMs.duration, tr.b.UnitPrefixScale.METRIC.MILLI, tr.b.UnitPrefixScale.METRIC.NONE);
                energyConsumedInJ += durationInS * sample.powerInW;
            }
            return energyConsumedInJ;
        }, getSamplesWithinRange(start, end) {
            const startIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, start);
            const endIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, end);
            return this.samples.slice(startIndex, endIndex);
        }, shiftTimestampsForward(amount) {
            for (let i = 0; i < this.samples_.length; ++i) {
                this.samples_[i].start += amount;
            }
        }, updateBounds() {
            this.bounds.reset();
            if (this.samples_.length === 0) return;
            this.bounds.addValue(this.samples_[0].start);
            this.bounds.addValue(this.samples_[this.samples_.length - 1].start);
        }, * childEvents() {
            yield* this.samples_;
        },
    };
    return {PowerSeries,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function Device(model) {
        if (!model) {
            throw new Error('Must provide a model.');
        }
        tr.model.EventContainer.call(this);
        this.powerSeries_ = undefined;
        this.cpuUsageSeries_ = undefined;
        this.vSyncTimestamps_ = [];
    }

    Device.compare = function (x, y) {
        return x.guid - y.guid;
    };
    Device.prototype = {
        __proto__: tr.model.EventContainer.prototype, compareTo(that) {
            return Device.compare(this, that);
        }, get userFriendlyName() {
            return 'Device';
        }, get userFriendlyDetails() {
            return 'Device';
        }, get stableId() {
            return 'Device';
        }, getSettingsKey() {
            return 'device';
        }, get powerSeries() {
            return this.powerSeries_;
        }, set powerSeries(powerSeries) {
            this.powerSeries_ = powerSeries;
        }, get cpuUsageSeries() {
            return this.cpuUsageSeries_;
        }, set cpuUsageSeries(cpuUsageSeries) {
            this.cpuUsageSeries_ = cpuUsageSeries;
        }, get vSyncTimestamps() {
            return this.vSyncTimestamps_;
        }, set vSyncTimestamps(value) {
            this.vSyncTimestamps_ = value;
        }, updateBounds() {
            this.bounds.reset();
            for (const child of this.childEventContainers()) {
                child.updateBounds();
                this.bounds.addRange(child.bounds);
            }
        }, shiftTimestampsForward(amount) {
            for (const child of this.childEventContainers()) {
                child.shiftTimestampsForward(amount);
            }
            for (let i = 0; i < this.vSyncTimestamps_.length; i++) {
                this.vSyncTimestamps_[i] += amount;
            }
        }, addCategoriesToDict(categoriesDict) {
        }, * childEventContainers() {
            if (this.powerSeries_) {
                yield this.powerSeries_;
            }
            if (this.cpuUsageSeries_) {
                yield this.cpuUsageSeries_;
            }
        }
    };
    return {Device,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function FlowEvent(category, id, title, colorId, start, args, opt_duration) {
        tr.model.TimedEvent.call(this, start);
        this.category = category || '';
        this.title = title;
        this.colorId = colorId;
        this.start = start;
        this.args = args;
        this.id = id;
        this.startSlice = undefined;
        this.endSlice = undefined;
        this.startStackFrame = undefined;
        this.endStackFrame = undefined;
        if (opt_duration !== undefined) {
            this.duration = opt_duration;
        }
    }

    FlowEvent.prototype = {
        __proto__: tr.model.TimedEvent.prototype, get userFriendlyName() {
            return 'Flow event named ' + this.title + ' at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.timestamp);
        }
    };
    tr.model.EventRegistry.register(FlowEvent, {name: 'flowEvent', pluralName: 'flowEvents'});
    return {FlowEvent,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ContainerMemoryDump(start) {
        tr.model.TimedEvent.call(this, start);
        this.levelOfDetail = undefined;
        this.memoryAllocatorDumps_ = undefined;
        this.memoryAllocatorDumpsByFullName_ = undefined;
    }

    ContainerMemoryDump.LevelOfDetail = {BACKGROUND: 0, LIGHT: 1, DETAILED: 2};
    ContainerMemoryDump.prototype = {
        __proto__: tr.model.TimedEvent.prototype, shiftTimestampsForward(amount) {
            this.start += amount;
        }, get memoryAllocatorDumps() {
            return this.memoryAllocatorDumps_;
        }, set memoryAllocatorDumps(memoryAllocatorDumps) {
            this.memoryAllocatorDumps_ = memoryAllocatorDumps;
            this.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
        }, getMemoryAllocatorDumpByFullName(fullName) {
            if (this.memoryAllocatorDumps_ === undefined) return undefined;
            if (this.memoryAllocatorDumpsByFullName_ === undefined) {
                const index = {};

                function addDumpsToIndex(dumps) {
                    dumps.forEach(function (dump) {
                        index[dump.fullName] = dump;
                        addDumpsToIndex(dump.children);
                    });
                }

                addDumpsToIndex(this.memoryAllocatorDumps_);
                this.memoryAllocatorDumpsByFullName_ = index;
            }
            return this.memoryAllocatorDumpsByFullName_[fullName];
        }, forceRebuildingMemoryAllocatorDumpByFullNameIndex() {
            this.memoryAllocatorDumpsByFullName_ = undefined;
        }, iterateRootAllocatorDumps(fn, opt_this) {
            if (this.memoryAllocatorDumps === undefined) return;
            this.memoryAllocatorDumps.forEach(fn, opt_this || this);
        }
    };
    return {ContainerMemoryDump,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function MemoryAllocatorDump(containerMemoryDump, fullName, opt_guid) {
        this.fullName = fullName;
        this.parent = undefined;
        this.children = [];
        this.numerics = {};
        this.diagnostics = {};
        this.containerMemoryDump = containerMemoryDump;
        this.owns = undefined;
        this.ownedBy = [];
        this.ownedBySiblingSizes = new Map();
        this.retains = [];
        this.retainedBy = [];
        this.weak = false;
        this.infos = [];
        this.guid = opt_guid;
    }

    MemoryAllocatorDump.SIZE_NUMERIC_NAME = 'size';
    MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME = 'effective_size';
    MemoryAllocatorDump.RESIDENT_SIZE_NUMERIC_NAME = 'resident_size';
    MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME = MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME;
    MemoryAllocatorDump.prototype = {
        get name() {
            return this.fullName.substring(this.fullName.lastIndexOf('/') + 1);
        }, get quantifiedName() {
            return '\'' + this.fullName + '\' in ' +
                this.containerMemoryDump.containerName;
        }, getDescendantDumpByFullName(fullName) {
            return this.containerMemoryDump.getMemoryAllocatorDumpByFullName(this.fullName + '/' + fullName);
        }, isDescendantOf(otherDump) {
            if (this === otherDump) return true;
            if (this.parent === undefined) return false;
            return this.parent.isDescendantOf(otherDump);
        }, addNumeric(name, numeric) {
            if (!(numeric instanceof tr.b.Scalar)) {
                throw new Error('Numeric value must be an instance of Scalar.');
            }
            if (name in this.numerics) {
                throw new Error('Duplicate numeric name: ' + name + '.');
            }
            this.numerics[name] = numeric;
        }, addDiagnostic(name, text) {
            if (typeof text !== 'string') {
                throw new Error('Diagnostic text must be a string.');
            }
            if (name in this.diagnostics) {
                throw new Error('Duplicate diagnostic name: ' + name + '.');
            }
            this.diagnostics[name] = text;
        }, aggregateNumericsRecursively(opt_model) {
            const numericNames = new Set();
            this.children.forEach(function (child) {
                child.aggregateNumericsRecursively(opt_model);
                for (const [item, value] of Object.entries(child.numerics)) {
                    numericNames.add(item, value);
                }
            }, this);
            numericNames.forEach(function (numericName) {
                if (numericName === MemoryAllocatorDump.SIZE_NUMERIC_NAME || numericName === MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME || this.numerics[numericName] !== undefined) {
                    return;
                }
                this.numerics[numericName] = MemoryAllocatorDump.aggregateNumerics(this.children.map(function (child) {
                    return child.numerics[numericName];
                }), opt_model);
            }, this);
        }
    };
    MemoryAllocatorDump.aggregateNumerics = function (numerics, opt_model) {
        let shouldLogWarning = !!opt_model;
        let aggregatedUnit = undefined;
        let aggregatedValue = 0;
        numerics.forEach(function (numeric) {
            if (numeric === undefined) return;
            const unit = numeric.unit;
            if (aggregatedUnit === undefined) {
                aggregatedUnit = unit;
            } else if (aggregatedUnit !== unit) {
                if (shouldLogWarning) {
                    opt_model.importWarning({
                        type: 'numeric_parse_error', message: 'Multiple units provided for numeric: \'' +
                            aggregatedUnit.unitName + '\' and \'' + unit.unitName + '\'.'
                    });
                    shouldLogWarning = false;
                }
                aggregatedUnit = tr.b.Unit.byName.unitlessNumber_smallerIsBetter;
            }
            aggregatedValue += numeric.value;
        }, this);
        if (aggregatedUnit === undefined) return undefined;
        return new tr.b.Scalar(aggregatedUnit, aggregatedValue);
    };

    function MemoryAllocatorDumpLink(source, target, opt_importance) {
        this.source = source;
        this.target = target;
        this.importance = opt_importance;
        this.size = undefined;
    }

    const MemoryAllocatorDumpInfoType = {
        PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN: 0,
        PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER: 1
    };
    return {MemoryAllocatorDump, MemoryAllocatorDumpLink, MemoryAllocatorDumpInfoType,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function GlobalMemoryDump(model, start) {
        tr.model.ContainerMemoryDump.call(this, start);
        this.model = model;
        this.processMemoryDumps = {};
    }

    const SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME;
    const EFFECTIVE_SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME;
    const MemoryAllocatorDumpInfoType = tr.model.MemoryAllocatorDumpInfoType;
    const PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN = MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN;
    const PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER = MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER;

    function getSize(dump) {
        const numeric = dump.numerics[SIZE_NUMERIC_NAME];
        if (numeric === undefined) return 0;
        return numeric.value;
    }

    function hasSize(dump) {
        return dump.numerics[SIZE_NUMERIC_NAME] !== undefined;
    }

    function optional(value, defaultValue) {
        if (value === undefined) return defaultValue;
        return value;
    }

    GlobalMemoryDump.prototype = {
        __proto__: tr.model.ContainerMemoryDump.prototype, get stableId() {
            return 'memory.' + this.model.globalMemoryDumps.indexOf(this);
        }, get userFriendlyName() {
            return 'Global memory dump at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }, get containerName() {
            return 'global space';
        }, finalizeGraph() {
            this.removeWeakDumps();
            this.setUpTracingOverheadOwnership();
            this.aggregateNumerics();
            this.calculateSizes();
            this.calculateEffectiveSizes();
            this.discountTracingOverheadFromVmRegions();
            this.forceRebuildingMemoryAllocatorDumpByFullNameIndices();
        }, removeWeakDumps() {
            this.traverseAllocatorDumpsInDepthFirstPreOrder(function (dump) {
                if (dump.weak) return;
                if ((dump.owns !== undefined && dump.owns.target.weak) || (dump.parent !== undefined && dump.parent.weak)) {
                    dump.weak = true;
                }
            });

            function removeWeakDumpsFromListRecursively(dumps) {
                tr.b.inPlaceFilter(dumps, function (dump) {
                    if (dump.weak) {
                        return false;
                    }
                    removeWeakDumpsFromListRecursively(dump.children);
                    tr.b.inPlaceFilter(dump.ownedBy, function (ownershipLink) {
                        return !ownershipLink.source.weak;
                    });
                    return true;
                });
            }

            this.iterateContainerDumps(function (containerDump) {
                const memoryAllocatorDumps = containerDump.memoryAllocatorDumps;
                if (memoryAllocatorDumps !== undefined) {
                    removeWeakDumpsFromListRecursively(memoryAllocatorDumps);
                }
            });
        }, calculateSizes() {
            this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateMemoryAllocatorDumpSize_.bind(this));
        }, calculateMemoryAllocatorDumpSize_(dump) {
            let shouldDefineSize = false;

            function getDependencySize(dependencyDump) {
                const numeric = dependencyDump.numerics[SIZE_NUMERIC_NAME];
                if (numeric === undefined) return 0;
                shouldDefineSize = true;
                return numeric.value;
            }

            const sizeNumeric = dump.numerics[SIZE_NUMERIC_NAME];
            let size = 0;
            let checkDependencySizeIsConsistent = function () {
            };
            if (sizeNumeric !== undefined) {
                size = sizeNumeric.value;
                shouldDefineSize = true;
                if (sizeNumeric.unit !== tr.b.Unit.byName.sizeInBytes_smallerIsBetter) {
                    this.model.importWarning({
                        type: 'memory_dump_parse_error',
                        message: 'Invalid unit of \'size\' numeric of memory allocator ' + 'dump ' + dump.quantifiedName + ': ' +
                            sizeNumeric.unit.unitName + '.'
                    });
                }
                checkDependencySizeIsConsistent = function (dependencySize, dependencyInfoType, dependencyName) {
                    if (size >= dependencySize) return;
                    this.model.importWarning({
                        type: 'memory_dump_parse_error', message: 'Size provided by memory allocator dump \'' +
                            dump.fullName + '\'' +
                            tr.b.Unit.byName.sizeInBytes.format(size) + ') is less than ' + dependencyName + ' (' +
                            tr.b.Unit.byName.sizeInBytes.format(dependencySize) + ').'
                    });
                    dump.infos.push({type: dependencyInfoType, providedSize: size, dependencySize});
                }.bind(this);
            }
            let aggregatedChildrenSize = 0;
            const allOverlaps = {};
            dump.children.forEach(function (childDump) {
                function aggregateDescendantDump(descendantDump) {
                    const ownedDumpLink = descendantDump.owns;
                    if (ownedDumpLink !== undefined && ownedDumpLink.target.isDescendantOf(dump)) {
                        let ownedChildDump = ownedDumpLink.target;
                        while (ownedChildDump.parent !== dump) {
                            ownedChildDump = ownedChildDump.parent;
                        }
                        if (childDump !== ownedChildDump) {
                            const ownedBySiblingSize = getDependencySize(descendantDump);
                            if (ownedBySiblingSize > 0) {
                                const previousTotalOwnedBySiblingSize = ownedChildDump.ownedBySiblingSizes.get(childDump) || 0;
                                const updatedTotalOwnedBySiblingSize = previousTotalOwnedBySiblingSize + ownedBySiblingSize;
                                ownedChildDump.ownedBySiblingSizes.set(childDump, updatedTotalOwnedBySiblingSize);
                            }
                        }
                        return;
                    }
                    if (descendantDump.children.length === 0) {
                        aggregatedChildrenSize += getDependencySize(descendantDump);
                        return;
                    }
                    descendantDump.children.forEach(aggregateDescendantDump);
                }

                aggregateDescendantDump(childDump);
            });
            checkDependencySizeIsConsistent(aggregatedChildrenSize, PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN, 'the aggregated size of its children');
            let largestOwnerSize = 0;
            dump.ownedBy.forEach(function (ownershipLink) {
                const owner = ownershipLink.source;
                const ownerSize = getDependencySize(owner);
                largestOwnerSize = Math.max(largestOwnerSize, ownerSize);
            });
            checkDependencySizeIsConsistent(largestOwnerSize, PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER, 'the size of its largest owner');
            if (!shouldDefineSize) {
                delete dump.numerics[SIZE_NUMERIC_NAME];
                return;
            }
            size = Math.max(size, aggregatedChildrenSize, largestOwnerSize);
            dump.numerics[SIZE_NUMERIC_NAME] = new tr.b.Scalar(tr.b.Unit.byName.sizeInBytes_smallerIsBetter, size);
            if (aggregatedChildrenSize < size && dump.children !== undefined && dump.children.length > 0) {
                const virtualChild = new tr.model.MemoryAllocatorDump(dump.containerMemoryDump, dump.fullName + '/<unspecified>');
                virtualChild.parent = dump;
                dump.children.unshift(virtualChild);
                virtualChild.numerics[SIZE_NUMERIC_NAME] = new tr.b.Scalar(tr.b.Unit.byName.sizeInBytes_smallerIsBetter, size - aggregatedChildrenSize);
            }
        }, calculateEffectiveSizes() {
            this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateDumpSubSizes_.bind(this));
            this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateDumpOwnershipCoefficient_.bind(this));
            this.traverseAllocatorDumpsInDepthFirstPreOrder(this.calculateDumpCumulativeOwnershipCoefficient_.bind(this));
            this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateDumpEffectiveSize_.bind(this));
        }, calculateDumpSubSizes_(dump) {
            if (!hasSize(dump)) return;
            if (dump.children === undefined || dump.children.length === 0) {
                const size = getSize(dump);
                dump.notOwningSubSize_ = size;
                dump.notOwnedSubSize_ = size;
                return;
            }
            let notOwningSubSize = 0;
            dump.children.forEach(function (childDump) {
                if (childDump.owns !== undefined) return;
                notOwningSubSize += optional(childDump.notOwningSubSize_, 0);
            });
            dump.notOwningSubSize_ = notOwningSubSize;
            let notOwnedSubSize = 0;
            dump.children.forEach(function (childDump) {
                if (childDump.ownedBy.length === 0) {
                    notOwnedSubSize += optional(childDump.notOwnedSubSize_, 0);
                    return;
                }
                let largestChildOwnerSize = 0;
                childDump.ownedBy.forEach(function (ownershipLink) {
                    largestChildOwnerSize = Math.max(largestChildOwnerSize, getSize(ownershipLink.source));
                });
                notOwnedSubSize += getSize(childDump) - largestChildOwnerSize;
            });
            dump.notOwnedSubSize_ = notOwnedSubSize;
        }, calculateDumpOwnershipCoefficient_(dump) {
            if (!hasSize(dump)) return;
            if (dump.ownedBy.length === 0) return;
            const owners = dump.ownedBy.map(function (ownershipLink) {
                return {
                    dump: ownershipLink.source,
                    importance: optional(ownershipLink.importance, 0),
                    notOwningSubSize: optional(ownershipLink.source.notOwningSubSize_, 0)
                };
            });
            owners.sort(function (a, b) {
                if (a.importance === b.importance) {
                    return a.notOwningSubSize - b.notOwningSubSize;
                }
                return b.importance - a.importance;
            });
            let currentImportanceStartPos = 0;
            let alreadyAttributedSubSize = 0;
            while (currentImportanceStartPos < owners.length) {
                const currentImportance = owners[currentImportanceStartPos].importance;
                let nextImportanceStartPos = currentImportanceStartPos + 1;
                while (nextImportanceStartPos < owners.length && owners[nextImportanceStartPos].importance === currentImportance) {
                    nextImportanceStartPos++;
                }
                let attributedNotOwningSubSize = 0;
                for (let pos = currentImportanceStartPos; pos < nextImportanceStartPos; pos++) {
                    const owner = owners[pos];
                    const notOwningSubSize = owner.notOwningSubSize;
                    if (notOwningSubSize > alreadyAttributedSubSize) {
                        attributedNotOwningSubSize += (notOwningSubSize - alreadyAttributedSubSize) / (nextImportanceStartPos - pos);
                        alreadyAttributedSubSize = notOwningSubSize;
                    }
                    let owningCoefficient = 0;
                    if (notOwningSubSize !== 0) {
                        owningCoefficient = attributedNotOwningSubSize / notOwningSubSize;
                    }
                    owner.dump.owningCoefficient_ = owningCoefficient;
                }
                currentImportanceStartPos = nextImportanceStartPos;
            }
            const notOwnedSubSize = optional(dump.notOwnedSubSize_, 0);
            const remainderSubSize = notOwnedSubSize - alreadyAttributedSubSize;
            let ownedCoefficient = 0;
            if (notOwnedSubSize !== 0) {
                ownedCoefficient = remainderSubSize / notOwnedSubSize;
            }
            dump.ownedCoefficient_ = ownedCoefficient;
        }, calculateDumpCumulativeOwnershipCoefficient_(dump) {
            if (!hasSize(dump)) return;
            let cumulativeOwnedCoefficient = optional(dump.ownedCoefficient_, 1);
            const parent = dump.parent;
            if (dump.parent !== undefined) {
                cumulativeOwnedCoefficient *= dump.parent.cumulativeOwnedCoefficient_;
            }
            dump.cumulativeOwnedCoefficient_ = cumulativeOwnedCoefficient;
            let cumulativeOwningCoefficient;
            if (dump.owns !== undefined) {
                cumulativeOwningCoefficient = dump.owningCoefficient_ * dump.owns.target.cumulativeOwningCoefficient_;
            } else if (dump.parent !== undefined) {
                cumulativeOwningCoefficient = dump.parent.cumulativeOwningCoefficient_;
            } else {
                cumulativeOwningCoefficient = 1;
            }
            dump.cumulativeOwningCoefficient_ = cumulativeOwningCoefficient;
        }, calculateDumpEffectiveSize_(dump) {
            if (!hasSize(dump)) {
                delete dump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME];
                return;
            }
            let effectiveSize;
            if (dump.children === undefined || dump.children.length === 0) {
                effectiveSize = getSize(dump) * dump.cumulativeOwningCoefficient_ * dump.cumulativeOwnedCoefficient_;
            } else {
                effectiveSize = 0;
                dump.children.forEach(function (childDump) {
                    if (!hasSize(childDump)) return;
                    effectiveSize += childDump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME].value;
                });
            }
            dump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME] = new tr.b.Scalar(tr.b.Unit.byName.sizeInBytes_smallerIsBetter, effectiveSize);
        }, aggregateNumerics() {
            this.iterateRootAllocatorDumps(function (dump) {
                dump.aggregateNumericsRecursively(this.model);
            });
            this.iterateRootAllocatorDumps(this.propagateNumericsAndDiagnosticsRecursively);
            for (const processMemoryDump of Object.values(this.processMemoryDumps)) {
                processMemoryDump.iterateRootAllocatorDumps(function (dump) {
                    dump.aggregateNumericsRecursively(this.model);
                }, this);
            }
        }, propagateNumericsAndDiagnosticsRecursively(globalAllocatorDump) {
            ['numerics', 'diagnostics'].forEach(function (field) {
                for (const [name, value] of
                    Object.entries(globalAllocatorDump[field])) {
                    globalAllocatorDump.ownedBy.forEach(function (ownershipLink) {
                        const processAllocatorDump = ownershipLink.source;
                        if (processAllocatorDump[field][name] !== undefined) {
                            return;
                        }
                        processAllocatorDump[field][name] = value;
                    });
                }
            });
            globalAllocatorDump.children.forEach(this.propagateNumericsAndDiagnosticsRecursively, this);
        }, setUpTracingOverheadOwnership() {
            for (const dump of Object.values(this.processMemoryDumps)) {
                dump.setUpTracingOverheadOwnership(this.model);
            }
        }, discountTracingOverheadFromVmRegions() {
            for (const dump of Object.values(this.processMemoryDumps)) {
                dump.discountTracingOverheadFromVmRegions(this.model);
            }
        }, forceRebuildingMemoryAllocatorDumpByFullNameIndices() {
            this.iterateContainerDumps(function (containerDump) {
                containerDump.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
            });
        }, iterateContainerDumps(fn) {
            fn.call(this, this);
            for (const processDump of Object.values(this.processMemoryDumps)) {
                fn.call(this, processDump);
            }
        }, iterateAllRootAllocatorDumps(fn) {
            this.iterateContainerDumps(function (containerDump) {
                containerDump.iterateRootAllocatorDumps(fn, this);
            });
        }, traverseAllocatorDumpsInDepthFirstPostOrder(fn) {
            const visitedDumps = new WeakSet();
            const openDumps = new WeakSet();

            function visit(dump) {
                if (visitedDumps.has(dump)) return;
                if (openDumps.has(dump)) {
                    throw new Error(dump.userFriendlyName + ' contains a cycle');
                }
                openDumps.add(dump);
                dump.ownedBy.forEach(function (ownershipLink) {
                    visit.call(this, ownershipLink.source);
                }, this);
                dump.children.forEach(visit, this);
                fn.call(this, dump);
                visitedDumps.add(dump);
                openDumps.delete(dump);
            }

            this.iterateAllRootAllocatorDumps(visit);
        }, traverseAllocatorDumpsInDepthFirstPreOrder(fn) {
            const visitedDumps = new WeakSet();

            function visit(dump) {
                if (visitedDumps.has(dump)) return;
                if (dump.owns !== undefined && !visitedDumps.has(dump.owns.target)) {
                    return;
                }
                if (dump.parent !== undefined && !visitedDumps.has(dump.parent)) {
                    return;
                }
                fn.call(this, dump);
                visitedDumps.add(dump);
                dump.ownedBy.forEach(function (ownershipLink) {
                    visit.call(this, ownershipLink.source);
                }, this);
                dump.children.forEach(visit, this);
            }

            this.iterateAllRootAllocatorDumps(visit);
        }
    };
    tr.model.EventRegistry.register(GlobalMemoryDump, {name: 'globalMemoryDump', pluralName: 'globalMemoryDumps'});
    return {GlobalMemoryDump,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const InstantEventType = {GLOBAL: 1, PROCESS: 2};

    function InstantEvent(category, title, colorId, start, args, parent) {
        tr.model.TimedEvent.call(this, start);
        this.category = category || '';
        this.title = title;
        this.colorId = colorId;
        this.args = args;
        this.parent_ = parent;
        this.type = undefined;
    }

    InstantEvent.prototype = {__proto__: tr.model.TimedEvent.prototype,};

    function GlobalInstantEvent(category, title, colorId, start, args, parent) {
        InstantEvent.apply(this, arguments);
        this.type = InstantEventType.GLOBAL;
    }

    GlobalInstantEvent.prototype = {
        __proto__: InstantEvent.prototype, get userFriendlyName() {
            return 'Global instant event ' + this.title + ' @ ' +
                tr.b.Unit.byName.timeStampInMs.format(start);
        }, get stableId() {
            return 'instant.' + this.parent_.instantEvents.indexOf(this);
        },
    };

    function ProcessInstantEvent(category, title, colorId, start, args, parent) {
        InstantEvent.apply(this, arguments);
        this.type = InstantEventType.PROCESS;
    }

    ProcessInstantEvent.prototype = {
        __proto__: InstantEvent.prototype, get userFriendlyName() {
            return 'Process-level instant event ' + this.title + ' @ ' +
                tr.b.Unit.byName.timeStampInMs.format(start);
        }, get stableId() {
            return this.parent_.stableId + '.instant.' +
                this.parent_.instantEvents.indexOf(this);
        },
    };
    tr.model.EventRegistry.register(InstantEvent, {name: 'instantEvent', pluralName: 'instantEvents'});
    return {GlobalInstantEvent, ProcessInstantEvent, InstantEventType, InstantEvent,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const Cpu = tr.model.Cpu;
    const ProcessBase = tr.model.ProcessBase;

    function Kernel(model) {
        ProcessBase.call(this, model);
        this.cpus = {};
        this.softwareMeasuredCpuCount_ = undefined;
    }

    Kernel.compare = function (x, y) {
        return 0;
    };
    Kernel.prototype = {
        __proto__: ProcessBase.prototype, compareTo(that) {
            return Kernel.compare(this, that);
        }, get userFriendlyName() {
            return 'Kernel';
        }, get userFriendlyDetails() {
            return 'Kernel';
        }, get stableId() {
            return 'Kernel';
        }, getOrCreateCpu(cpuNumber) {
            if (!this.cpus[cpuNumber]) {
                this.cpus[cpuNumber] = new Cpu(this, cpuNumber);
            }
            return this.cpus[cpuNumber];
        }, get softwareMeasuredCpuCount() {
            return this.softwareMeasuredCpuCount_;
        }, set softwareMeasuredCpuCount(softwareMeasuredCpuCount) {
            if (this.softwareMeasuredCpuCount_ !== undefined && this.softwareMeasuredCpuCount_ !== softwareMeasuredCpuCount) {
                throw new Error('Cannot change the softwareMeasuredCpuCount once it is set');
            }
            this.softwareMeasuredCpuCount_ = softwareMeasuredCpuCount;
        }, get bestGuessAtCpuCount() {
            const realCpuCount = Object.keys(this.cpus).length;
            if (realCpuCount !== 0) {
                return realCpuCount;
            }
            return this.softwareMeasuredCpuCount;
        }, updateBounds() {
            ProcessBase.prototype.updateBounds.call(this);
            for (const cpuNumber in this.cpus) {
                const cpu = this.cpus[cpuNumber];
                cpu.updateBounds();
                this.bounds.addRange(cpu.bounds);
            }
        }, createSubSlices() {
            ProcessBase.prototype.createSubSlices.call(this);
            for (const cpuNumber in this.cpus) {
                const cpu = this.cpus[cpuNumber];
                cpu.createSubSlices();
            }
        }, addCategoriesToDict(categoriesDict) {
            ProcessBase.prototype.addCategoriesToDict.call(this, categoriesDict);
            for (const cpuNumber in this.cpus) {
                this.cpus[cpuNumber].addCategoriesToDict(categoriesDict);
            }
        }, getSettingsKey() {
            return 'kernel';
        }, * childEventContainers() {
            yield* ProcessBase.prototype.childEventContainers.call(this);
            yield* Object.values(this.cpus);
        },
    };
    return {Kernel,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ModelIndices(model) {
        this.flowEventsById_ = {};
        model.flowEvents.forEach(function (fe) {
            if (fe.id !== undefined) {
                if (!this.flowEventsById_.hasOwnProperty(fe.id)) {
                    this.flowEventsById_[fe.id] = [];
                }
                this.flowEventsById_[fe.id].push(fe);
            }
        }, this);
    }

    ModelIndices.prototype = {
        addEventWithId(id, event) {
            if (!this.flowEventsById_.hasOwnProperty(id)) {
                this.flowEventsById_[id] = [];
            }
            this.flowEventsById_[id].push(event);
        }, getFlowEventsWithId(id) {
            if (!this.flowEventsById_.hasOwnProperty(id)) {
                return [];
            }
            return this.flowEventsById_[id];
        }
    };
    return {ModelIndices,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ModelStats() {
        this.traceEventCountsByKey_ = new Map();
        this.allTraceEventStats_ = [];
        this.traceEventStatsInTimeIntervals_ = new Map();
        this.allTraceEventStatsInTimeIntervals_ = [];
        this.hasEventSizesinBytes_ = false;
        this.traceImportDurationMs_ = undefined;
    }

    ModelStats.prototype = {
        TIME_INTERVAL_SIZE_IN_MS: 100,
        willProcessBasicTraceEvent(phase, category, title, ts, opt_eventSizeinBytes) {
            const key = phase + '/' + category + '/' + title;
            let eventStats = this.traceEventCountsByKey_.get(key);
            if (eventStats === undefined) {
                eventStats = {phase, category, title, numEvents: 0, totalEventSizeinBytes: 0};
                this.traceEventCountsByKey_.set(key, eventStats);
                this.allTraceEventStats_.push(eventStats);
            }
            eventStats.numEvents++;
            const timeIntervalKey = Math.floor(tr.b.Unit.timestampFromUs(ts) / this.TIME_INTERVAL_SIZE_IN_MS);
            let eventStatsByTimeInverval = this.traceEventStatsInTimeIntervals_.get(timeIntervalKey);
            if (eventStatsByTimeInverval === undefined) {
                eventStatsByTimeInverval = {timeInterval: timeIntervalKey, numEvents: 0, totalEventSizeinBytes: 0};
                this.traceEventStatsInTimeIntervals_.set(timeIntervalKey, eventStatsByTimeInverval);
                this.allTraceEventStatsInTimeIntervals_.push(eventStatsByTimeInverval);
            }
            eventStatsByTimeInverval.numEvents++;
            if (opt_eventSizeinBytes !== undefined) {
                this.hasEventSizesinBytes_ = true;
                eventStats.totalEventSizeinBytes += opt_eventSizeinBytes;
                eventStatsByTimeInverval.totalEventSizeinBytes += opt_eventSizeinBytes;
            }
        },
        get allTraceEventStats() {
            return this.allTraceEventStats_;
        },
        get allTraceEventStatsInTimeIntervals() {
            return this.allTraceEventStatsInTimeIntervals_;
        },
        get hasEventSizesinBytes() {
            return this.hasEventSizesinBytes_;
        },
        get traceImportDurationMs() {
            return this.traceImportDurationMs_;
        },
        set traceImportDurationMs(traceImportDurationMs) {
            this.traceImportDurationMs_ = traceImportDurationMs;
        }
    };
    return {ModelStats,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function VMRegion(startAddress, sizeInBytes, protectionFlags, mappedFile, byteStats) {
        this.startAddress = startAddress;
        this.sizeInBytes = sizeInBytes;
        this.protectionFlags = protectionFlags;
        this.mappedFile = mappedFile || '';
        this.byteStats = byteStats || {};
    }

    VMRegion.PROTECTION_FLAG_READ = 4;
    VMRegion.PROTECTION_FLAG_WRITE = 2;
    VMRegion.PROTECTION_FLAG_EXECUTE = 1;
    VMRegion.PROTECTION_FLAG_MAYSHARE = 128;
    VMRegion.prototype = {
        get uniqueIdWithinProcess() {
            return this.mappedFile + '#' + this.startAddress;
        }, get protectionFlagsToString() {
            if (this.protectionFlags === undefined) return undefined;
            return ((this.protectionFlags & VMRegion.PROTECTION_FLAG_READ ? 'r' : '-') +
                (this.protectionFlags & VMRegion.PROTECTION_FLAG_WRITE ? 'w' : '-') +
                (this.protectionFlags & VMRegion.PROTECTION_FLAG_EXECUTE ? 'x' : '-') +
                (this.protectionFlags & VMRegion.PROTECTION_FLAG_MAYSHARE ? 's' : 'p'));
        }
    };
    VMRegion.fromDict = function (dict) {
        return new VMRegion(dict.startAddress, dict.sizeInBytes, dict.protectionFlags, dict.mappedFile, dict.byteStats);
    };

    function VMRegionClassificationNode(opt_rule) {
        this.rule_ = opt_rule || VMRegionClassificationNode.CLASSIFICATION_RULES;
        this.hasRegions = false;
        this.sizeInBytes = undefined;
        this.byteStats = {};
        this.children_ = undefined;
        this.regions_ = [];
    }

    VMRegionClassificationNode.CLASSIFICATION_RULES = {
        name: 'Total',
        children: [{
            name: 'Android',
            file: /^\/dev\/ashmem(?!\/libc malloc)/,
            children: [{
                name: 'Java runtime',
                file: /^\/dev\/ashmem\/dalvik-/,
                children: [{
                    name: 'Spaces',
                    file: /\/dalvik-(alloc|main|large object|non moving|zygote) space/,
                    children: [{name: 'Normal', file: /\/dalvik-(alloc|main)/}, {
                        name: 'Large',
                        file: /\/dalvik-large object/
                    }, {name: 'Zygote', file: /\/dalvik-zygote/}, {name: 'Non-moving', file: /\/dalvik-non moving/}]
                }, {name: 'Linear Alloc', file: /\/dalvik-LinearAlloc/}, {
                    name: 'Indirect Reference Table',
                    file: /\/dalvik-indirect.ref/
                }, {name: 'Cache', file: /\/dalvik-jit-code-cache/}, {name: 'Accounting'}]
            }, {name: 'Cursor', file: /\/CursorWindow/}, {name: 'Ashmem'}]
        }, {
            name: 'Native heap',
            file: /^((\[heap\])|(\[anon:)|(\/dev\/ashmem\/libc malloc)|(\[discounted tracing overhead\])|$)/
        }, {name: 'Stack', file: /^\[stack/}, {
            name: 'Files',
            file: /\.((((jar)|(apk)|(ttf)|(odex)|(oat)|(art))$)|(dex)|(so))/,
            children: [{name: 'so', file: /\.so/}, {name: 'jar', file: /\.jar$/}, {
                name: 'apk',
                file: /\.apk$/
            }, {name: 'ttf', file: /\.ttf$/}, {name: 'dex', file: /\.((dex)|(odex$))/}, {
                name: 'oat',
                file: /\.oat$/
            }, {name: 'art', file: /\.art$/}]
        }, {
            name: 'Devices',
            file: /(^\/dev\/)|(anon_inode:dmabuf)/,
            children: [{name: 'GPU', file: /\/((nv)|(mali)|(kgsl))/}, {name: 'DMA', file: /anon_inode:dmabuf/}]
        }]
    };
    VMRegionClassificationNode.OTHER_RULE = {name: 'Other'};
    VMRegionClassificationNode.fromRegions = function (regions, opt_rules) {
        const tree = new VMRegionClassificationNode(opt_rules);
        tree.regions_ = regions;
        for (let i = 0; i < regions.length; i++) {
            tree.addStatsFromRegion_(regions[i]);
        }
        return tree;
    };
    VMRegionClassificationNode.prototype = {
        get title() {
            return this.rule_.name;
        }, get children() {
            if (this.isLeafNode) {
                return undefined;
            }
            if (this.children_ === undefined) {
                this.buildTree_();
            }
            return this.children_;
        }, get regions() {
            if (!this.isLeafNode) {
                return undefined;
            }
            return this.regions_;
        }, get allRegionsForTesting() {
            if (this.regions_ !== undefined) {
                if (this.children_ !== undefined) {
                    throw new Error('Internal error: a VM region classification node ' + 'cannot have both regions and children');
                }
                return this.regions_;
            }
            let regions = [];
            this.children_.forEach(function (childNode) {
                regions = regions.concat(childNode.allRegionsForTesting);
            });
            return regions;
        }, get isLeafNode() {
            const children = this.rule_.children;
            return children === undefined || children.length === 0;
        }, addRegion(region) {
            this.addRegionRecursively_(region, true);
        }, someRegion(fn, opt_this) {
            if (this.regions_ !== undefined) {
                return this.regions_.some(fn, opt_this);
            }
            return this.children_.some(function (childNode) {
                return childNode.someRegion(fn, opt_this);
            });
        }, addRegionRecursively_(region, addStatsToThisNode) {
            if (addStatsToThisNode) {
                this.addStatsFromRegion_(region);
            }
            if (this.regions_ !== undefined) {
                if (this.children_ !== undefined) {
                    throw new Error('Internal error: a VM region classification node ' + 'cannot have both regions and children');
                }
                this.regions_.push(region);
                return;
            }

            function regionRowMatchesChildNide(child) {
                const fileRegExp = child.rule_.file;
                if (fileRegExp === undefined) return true;
                return fileRegExp.test(region.mappedFile);
            }

            let matchedChild = this.children_.find(regionRowMatchesChildNide);
            if (matchedChild === undefined) {
                if (this.children_.length !== this.rule_.children.length) {
                    throw new Error('Internal error');
                }
                matchedChild = new VMRegionClassificationNode(VMRegionClassificationNode.OTHER_RULE);
                this.children_.push(matchedChild);
            }
            matchedChild.addRegionRecursively_(region, true);
        }, buildTree_() {
            const cachedRegions = this.regions_;
            this.regions_ = undefined;
            this.buildChildNodesRecursively_();
            for (let i = 0; i < cachedRegions.length; i++) {
                this.addRegionRecursively_(cachedRegions[i], false);
            }
        }, buildChildNodesRecursively_() {
            if (this.children_ !== undefined) {
                throw new Error('Internal error: Classification node already has children');
            }
            if (this.regions_ !== undefined && this.regions_.length !== 0) {
                throw new Error('Internal error: Classification node should have no regions');
            }
            if (this.isLeafNode) {
                return;
            }
            this.regions_ = undefined;
            this.children_ = this.rule_.children.map(function (childRule) {
                const child = new VMRegionClassificationNode(childRule);
                child.buildChildNodesRecursively_();
                return child;
            });
        }, addStatsFromRegion_(region) {
            this.hasRegions = true;
            const regionSizeInBytes = region.sizeInBytes;
            if (regionSizeInBytes !== undefined) {
                this.sizeInBytes = (this.sizeInBytes || 0) + regionSizeInBytes;
            }
            const thisByteStats = this.byteStats;
            const regionByteStats = region.byteStats;
            for (const byteStatName in regionByteStats) {
                const regionByteStatValue = regionByteStats[byteStatName];
                if (regionByteStatValue === undefined) continue;
                thisByteStats[byteStatName] = (thisByteStats[byteStatName] || 0) + regionByteStatValue;
            }
            if (region.mappedFile.includes('/base.odex') || region.mappedFile.includes('/base.vdex')) {
                if (region.byteStats.proportionalResident !== undefined) {
                    thisByteStats.javaBasePss = (thisByteStats.javaBasePss || 0) +
                        region.byteStats.proportionalResident;
                }
                if (region.byteStats.privateCleanResident !== undefined) {
                    thisByteStats.javaBaseCleanResident = (thisByteStats.javaBaseCleanResident || 0) +
                        region.byteStats.privateCleanResident;
                }
                if (region.byteStats.sharedCleanResident !== undefined) {
                    thisByteStats.javaBaseCleanResident = (thisByteStats.javaBaseCleanResident || 0) +
                        region.byteStats.sharedCleanResident;
                }
            }
            const textProtectionFlags = (VMRegion.PROTECTION_FLAG_READ | VMRegion.PROTECTION_FLAG_EXECUTE);
            if ((region.protectionFlags === textProtectionFlags) && (region.mappedFile.includes('/base.apk') || region.mappedFile.includes('/libchrome.so'))) {
                if (regionSizeInBytes !== undefined) {
                    this.nativeLibrarySizeInBytes = (this.nativeLibrarySizeInBytes || 0) + regionSizeInBytes;
                }
                if (region.byteStats.privateCleanResident !== undefined) {
                    thisByteStats.nativeLibraryPrivateCleanResident = (thisByteStats.nativeLibraryPrivateCleanResident || 0) +
                        region.byteStats.privateCleanResident;
                }
                if (region.byteStats.sharedCleanResident !== undefined) {
                    thisByteStats.nativeLibrarySharedCleanResident = (thisByteStats.nativeLibrarySharedCleanResident || 0) +
                        region.byteStats.sharedCleanResident;
                }
                if (region.byteStats.proportionalResident !== undefined) {
                    thisByteStats.nativeLibraryProportionalResident = (thisByteStats.nativeLibraryProportionalResident || 0) +
                        region.byteStats.proportionalResident;
                }
            }
        }
    };
    return {VMRegion, VMRegionClassificationNode,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const DISCOUNTED_ALLOCATOR_NAMES = ['winheap', 'malloc'];
    const TRACING_OVERHEAD_PATH = ['allocated_objects', 'tracing_overhead'];
    const SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME;
    const RESIDENT_SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.RESIDENT_SIZE_NUMERIC_NAME;

    function getSizeNumericValue(dump, sizeNumericName) {
        const sizeNumeric = dump.numerics[sizeNumericName];
        if (sizeNumeric === undefined) return 0;
        return sizeNumeric.value;
    }

    function ProcessMemoryDump(globalMemoryDump, process, start) {
        tr.model.ContainerMemoryDump.call(this, start);
        this.process = process;
        this.globalMemoryDump = globalMemoryDump;
        this.totals = undefined;
        this.vmRegions = undefined;
        this.heapDumps = undefined;
        this.tracingOverheadOwnershipSetUp_ = false;
        this.tracingOverheadDiscountedFromVmRegions_ = false;
    }

    ProcessMemoryDump.prototype = {
        __proto__: tr.model.ContainerMemoryDump.prototype, get stableId() {
            return this.process.stableId + '.memory.' +
                this.process.memoryDumps.indexOf(this);
        }, get userFriendlyName() {
            return 'Process memory dump at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }, get containerName() {
            return this.process.userFriendlyName;
        }, get processMemoryDumps() {
            const dumps = {};
            dumps[this.process.pid] = this;
            return dumps;
        }, get hasOwnVmRegions() {
            return this.vmRegions !== undefined;
        }, setUpTracingOverheadOwnership(opt_model) {
            if (this.tracingOverheadOwnershipSetUp_) return;
            this.tracingOverheadOwnershipSetUp_ = true;
            const tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
            if (tracingDump === undefined || tracingDump.owns !== undefined) {
                return;
            }
            if (tracingDump.owns !== undefined) return;
            const hasDiscountedFromAllocatorDumps = DISCOUNTED_ALLOCATOR_NAMES.some(function (allocatorName) {
                const allocatorDump = this.getMemoryAllocatorDumpByFullName(allocatorName);
                if (allocatorDump === undefined) {
                    return false;
                }
                let nextPathIndex = 0;
                let currentDump = allocatorDump;
                let currentFullName = allocatorName;
                for (; nextPathIndex < TRACING_OVERHEAD_PATH.length; nextPathIndex++) {
                    const childFullName = currentFullName + '/' +
                        TRACING_OVERHEAD_PATH[nextPathIndex];
                    const childDump = this.getMemoryAllocatorDumpByFullName(childFullName);
                    if (childDump === undefined) break;
                    currentDump = childDump;
                    currentFullName = childFullName;
                }
                for (; nextPathIndex < TRACING_OVERHEAD_PATH.length; nextPathIndex++) {
                    const childFullName = currentFullName + '/' +
                        TRACING_OVERHEAD_PATH[nextPathIndex];
                    const childDump = new tr.model.MemoryAllocatorDump(currentDump.containerMemoryDump, childFullName);
                    childDump.parent = currentDump;
                    currentDump.children.push(childDump);
                    currentFullName = childFullName;
                    currentDump = childDump;
                }
                const ownershipLink = new tr.model.MemoryAllocatorDumpLink(tracingDump, currentDump);
                tracingDump.owns = ownershipLink;
                currentDump.ownedBy.push(ownershipLink);
                return true;
            }, this);
            if (hasDiscountedFromAllocatorDumps) {
                this.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
            }
        }, discountTracingOverheadFromVmRegions(opt_model) {
            if (this.tracingOverheadDiscountedFromVmRegions_) return;
            this.tracingOverheadDiscountedFromVmRegions_ = true;
            const tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
            if (tracingDump === undefined) return;
            const discountedSize = getSizeNumericValue(tracingDump, SIZE_NUMERIC_NAME);
            const discountedResidentSize = getSizeNumericValue(tracingDump, RESIDENT_SIZE_NUMERIC_NAME);
            if (discountedSize <= 0 && discountedResidentSize <= 0) return;
            if (this.totals !== undefined) {
                if (this.totals.residentBytes !== undefined) {
                    this.totals.residentBytes -= discountedResidentSize;
                }
                if (this.totals.peakResidentBytes !== undefined) {
                    this.totals.peakResidentBytes -= discountedResidentSize;
                }
            }
            if (this.vmRegions !== undefined) {
                const hasSizeInBytes = this.vmRegions.sizeInBytes !== undefined;
                const hasPrivateDirtyResident = this.vmRegions.byteStats.privateDirtyResident !== undefined;
                const hasProportionalResident = this.vmRegions.byteStats.proportionalResident !== undefined;
                if ((hasSizeInBytes && discountedSize > 0) || ((hasPrivateDirtyResident || hasProportionalResident) && discountedResidentSize > 0)) {
                    const byteStats = {};
                    if (hasPrivateDirtyResident) {
                        byteStats.privateDirtyResident = -discountedResidentSize;
                    }
                    if (hasProportionalResident) {
                        byteStats.proportionalResident = -discountedResidentSize;
                    }
                    this.vmRegions.addRegion(tr.model.VMRegion.fromDict({
                        mappedFile: '[discounted tracing overhead]',
                        sizeInBytes: hasSizeInBytes ? -discountedSize : undefined,
                        byteStats
                    }));
                }
            }
        }
    };
    ProcessMemoryDump.hookUpMostRecentVmRegionsLinks = function (processDumps) {
        let mostRecentVmRegions = undefined;
        processDumps.forEach(function (processDump) {
            if (processDump.vmRegions !== undefined) {
                mostRecentVmRegions = processDump.vmRegions;
            }
            processDump.mostRecentVmRegions = mostRecentVmRegions;
        });
    };
    tr.model.EventRegistry.register(ProcessMemoryDump, {
        name: 'processMemoryDump',
        pluralName: 'processMemoryDumps'
    });
    return {ProcessMemoryDump,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ProcessBase = tr.model.ProcessBase;
    const ProcessInstantEvent = tr.model.ProcessInstantEvent;
    const Frame = tr.model.Frame;
    const ProcessMemoryDump = tr.model.ProcessMemoryDump;

    function Process(model, pid) {
        if (model === undefined) {
            throw new Error('model must be provided');
        }
        if (pid === undefined) {
            throw new Error('pid must be provided');
        }
        tr.model.ProcessBase.call(this, model);
        this.pid = pid;
        this.name = undefined;
        this.labels = [];
        this.uptime_seconds = 0;
        this.instantEvents = [];
        this.memoryDumps = [];
        this.frames = [];
        this.activities = [];
    }

    Process.compare = function (x, y) {
        let tmp = tr.model.ProcessBase.compare(x, y);
        if (tmp) return tmp;
        if (x.name !== undefined) {
            if (y.name !== undefined) {
                tmp = x.name.localeCompare(y.name);
            } else {
                tmp = -1;
            }
        } else if (y.name !== undefined) {
            tmp = 1;
        }
        if (tmp) return tmp;
        tmp = tr.b.compareArrays(x.labels, y.labels, function (x, y) {
            return x.localeCompare(y);
        });
        if (tmp) return tmp;
        return x.pid - y.pid;
    };
    Process.prototype = {
        __proto__: tr.model.ProcessBase.prototype, get stableId() {
            return this.pid;
        }, compareTo(that) {
            return Process.compare(this, that);
        }, * childEvents() {
            yield* ProcessBase.prototype.childEvents.call(this);
            yield* this.instantEvents;
            yield* this.frames;
            yield* this.memoryDumps;
        }, addLabelIfNeeded(labelName) {
            for (let i = 0; i < this.labels.length; i++) {
                if (this.labels[i] === labelName) return;
            }
            this.labels.push(labelName);
        }, get userFriendlyName() {
            let res;
            if (this.name) {
                res = this.name + ' (pid ' + this.pid + ')';
            } else {
                res = 'Process ' + this.pid;
            }
            if (this.labels.length) {
                res += ': ' + this.labels.join(', ');
            }
            if (this.uptime_seconds) {
                res += ', uptime:' + this.uptime_seconds + 's';
            }
            return res;
        }, get userFriendlyDetails() {
            if (this.name) {
                return this.name + ' (pid ' + this.pid + ')';
            }
            return 'pid: ' + this.pid;
        }, getSettingsKey() {
            if (!this.name) return undefined;
            if (!this.labels.length) return 'processes.' + this.name;
            return 'processes.' + this.name + '.' + this.labels.join('.');
        }, shiftTimestampsForward(amount) {
            for (let i = 0; i < this.instantEvents.length; i++) {
                this.instantEvents[i].start += amount;
            }
            for (let i = 0; i < this.frames.length; i++) {
                this.frames[i].shiftTimestampsForward(amount);
            }
            for (let i = 0; i < this.memoryDumps.length; i++) {
                this.memoryDumps[i].shiftTimestampsForward(amount);
            }
            for (let i = 0; i < this.activities.length; i++) {
                this.activities[i].shiftTimestampsForward(amount);
            }
            tr.model.ProcessBase.prototype.shiftTimestampsForward.apply(this, arguments);
        }, updateBounds() {
            tr.model.ProcessBase.prototype.updateBounds.apply(this);
            for (let i = 0; i < this.frames.length; i++) {
                this.frames[i].addBoundsToRange(this.bounds);
            }
            for (let i = 0; i < this.memoryDumps.length; i++) {
                this.memoryDumps[i].addBoundsToRange(this.bounds);
            }
            for (let i = 0; i < this.activities.length; i++) {
                this.activities[i].addBoundsToRange(this.bounds);
            }
        }, sortMemoryDumps() {
            this.memoryDumps.sort(function (x, y) {
                return x.start - y.start;
            });
            tr.model.ProcessMemoryDump.hookUpMostRecentVmRegionsLinks(this.memoryDumps);
        }
    };
    return {Process,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function Sample(start, title, leafNode, thread, opt_cpu, opt_weight, opt_args) {
        tr.model.TimedEvent.call(this, start);
        this.start_ = start;
        this.title_ = title;
        this.leafNode_ = leafNode;
        this.thread_ = thread;
        this.colorId_ = leafNode.colorId;
        this.cpu_ = opt_cpu;
        this.weight_ = opt_weight;
        this.args = opt_args || {};
    }

    Sample.prototype = {
        __proto__: tr.model.TimedEvent.prototype, get title() {
            return this.title_;
        }, get colorId() {
            return this.colorId_;
        }, get thread() {
            return this.thread_;
        }, get leafNode() {
            return this.leafNode_;
        }, get userFriendlyName() {
            return 'Sample at ' +
                tr.b.Unit.byName.timeStampInMs.format(this.start);
        }, get userFriendlyStack() {
            return this.leafNode_.userFriendlyStack;
        }, getNodesAsArray() {
            const nodes = [];
            let node = this.leafNode_;
            while (node !== undefined) {
                nodes.push(node);
                node = node.parentNode;
            }
            return nodes;
        }, get cpu() {
            return this.cpu_;
        }, get weight() {
            return this.weight_;
        },
    };
    tr.model.EventRegistry.register(Sample, {name: 'Sample', pluralName: 'Samples'});
    return {Sample,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function StackFrame(parentFrame, id, title, colorId, opt_sourceInfo) {
        if (id === undefined) {
            throw new Error('id must be given');
        }
        this.parentFrame_ = parentFrame;
        this.id = id;
        this.title_ = title;
        this.colorId = colorId;
        this.children = [];
        this.sourceInfo_ = opt_sourceInfo;
        if (this.parentFrame_) {
            this.parentFrame_.addChild(this);
        }
    }

    StackFrame.prototype = {
        get parentFrame() {
            return this.parentFrame_;
        }, get title() {
            if (this.sourceInfo_) {
                const src = this.sourceInfo_.toString();
                return this.title_ + (src === '' ? '' : ' ' + src);
            }
            return this.title_;
        }, get domain() {
            let result = 'unknown';
            if (this.sourceInfo_ && this.sourceInfo_.domain) {
                result = this.sourceInfo_.domain;
            }
            if (result === 'unknown' && this.parentFrame) {
                result = this.parentFrame.domain;
            }
            return result;
        }, get sourceInfo() {
            return this.sourceInfo_;
        }, set parentFrame(parentFrame) {
            if (this.parentFrame_) {
                Polymer.dom(this.parentFrame_).removeChild(this);
            }
            this.parentFrame_ = parentFrame;
            if (this.parentFrame_) {
                this.parentFrame_.addChild(this);
            }
        }, addChild(child) {
            this.children.push(child);
        }, removeChild(child) {
            const i = this.children.indexOf(child.id);
            if (i === -1) {
                throw new Error('omg');
            }
            this.children.splice(i, 1);
        }, removeAllChildren() {
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].parentFrame_ = undefined;
            }
            this.children.splice(0, this.children.length);
        }, get stackTrace() {
            const stack = [this];
            let cur = this.parentFrame;
            while (cur) {
                stack.push(cur);
                cur = cur.parentFrame;
            }
            return stack;
        }, getUserFriendlyStackTrace() {
            return this.stackTrace.map(function (x) {
                return x.title;
            });
        }
    };
    return {StackFrame,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    class UserModel extends tr.model.EventContainer {
        constructor(parentModel) {
            super();
            this.parentModel_ = parentModel;
            this.expectations_ = new tr.model.EventSet();
            this.segments_ = [];
        }

        get stableId() {
            return 'UserModel';
        }

        get parentModel() {
            return this.parentModel_;
        }

        sortExpectations() {
            this.expectations_.sortEvents((x, y) => (x.start - y.start));
        }

        get expectations() {
            return this.expectations_;
        }

        shiftTimestampsForward(amount) {
        }

        addCategoriesToDict(categoriesDict) {
        }

        get segments() {
            return this.segments_;
        }

        * childEvents() {
            yield* this.expectations;
        }

        * childEventContainers() {
        }

        updateBounds() {
            this.bounds.reset();
            for (const expectation of this.expectations) {
                expectation.addBoundsToRange(this.bounds);
            }
        }

        resegment(getKeyForSegment) {
            const newSegments = [];
            let prevKey = undefined;
            let prevSegment = undefined;
            for (let i = 0; i < this.segments.length; ++i) {
                const segment = this.segments[i];
                const key = getKeyForSegment(segment, i);
                if (prevSegment !== undefined && key === prevKey) {
                    prevSegment.addSegment(segment);
                } else {
                    prevSegment = segment.clone();
                    newSegments.push(prevSegment);
                }
                prevKey = key;
            }
            return newSegments;
        }
    }

    return {UserModel,};
});
'use strict';
tr.exportTo('tr', function () {
    const Process = tr.model.Process;
    const Device = tr.model.Device;
    const Kernel = tr.model.Kernel;
    const GlobalMemoryDump = tr.model.GlobalMemoryDump;
    const GlobalInstantEvent = tr.model.GlobalInstantEvent;
    const FlowEvent = tr.model.FlowEvent;
    const Alert = tr.model.Alert;
    const Sample = tr.model.Sample;

    function Model() {
        tr.model.EventContainer.call(this);
        tr.b.EventTarget.decorate(this);
        this.timestampShiftToZeroAmount_ = 0;
        this.faviconHue = 'blue';
        this.device = new Device(this);
        this.kernel = new Kernel(this);
        this.processes = {};
        this.metadata = [];
        this.categories = [];
        this.instantEvents = [];
        this.flowEvents = [];
        this.clockSyncManager = new tr.model.ClockSyncManager();
        this.intrinsicTimeUnit_ = undefined;
        this.stackFrames = {};
        this.samples = [];
        this.alerts = [];
        this.userModel = new tr.model.um.UserModel(this);
        this.flowIntervalTree = new tr.b.IntervalTree((f) => f.start, (f) => f.end);
        this.globalMemoryDumps = [];
        this.userFriendlyCategoryDrivers_ = [];
        this.annotationsByGuid_ = {};
        this.modelIndices = undefined;
        this.stats = new tr.model.ModelStats();
        this.importWarnings_ = [];
        this.reportedImportWarnings_ = {};
        this.isTimeHighResolution_ = true;
        this.patchupsToApply_ = [];
        this.doesHelperGUIDSupportThisModel_ = {};
        this.helpersByConstructorGUID_ = {};
        this.eventsByStableId_ = undefined;
    }

    Model.prototype = {
        __proto__: tr.model.EventContainer.prototype, getEventByStableId(stableId) {
            if (this.eventsByStableId_ === undefined) {
                this.eventsByStableId_ = {};
                for (const event of this.getDescendantEvents()) {
                    this.eventsByStableId_[event.stableId] = event;
                }
            }
            return this.eventsByStableId_[stableId];
        }, getOrCreateHelper(constructor) {
            if (!constructor.guid) {
                throw new Error('Helper constructors must have GUIDs');
            }
            if (this.helpersByConstructorGUID_[constructor.guid] === undefined) {
                if (this.doesHelperGUIDSupportThisModel_[constructor.guid] === undefined) {
                    this.doesHelperGUIDSupportThisModel_[constructor.guid] = constructor.supportsModel(this);
                }
                if (!this.doesHelperGUIDSupportThisModel_[constructor.guid]) {
                    return undefined;
                }
                this.helpersByConstructorGUID_[constructor.guid] = new constructor(this);
            }
            return this.helpersByConstructorGUID_[constructor.guid];
        }, * childEvents() {
            yield* this.globalMemoryDumps;
            yield* this.instantEvents;
            yield* this.flowEvents;
            yield* this.alerts;
            yield* this.samples;
        }, * childEventContainers() {
            yield this.userModel;
            yield this.device;
            yield this.kernel;
            yield* Object.values(this.processes);
        }, iterateAllPersistableObjects(callback) {
            this.kernel.iterateAllPersistableObjects(callback);
            for (const pid in this.processes) {
                this.processes[pid].iterateAllPersistableObjects(callback);
            }
        }, updateBounds() {
            this.bounds.reset();
            const bounds = this.bounds;
            for (const ec of this.childEventContainers()) {
                ec.updateBounds();
                bounds.addRange(ec.bounds);
            }
            for (const event of this.childEvents()) {
                event.addBoundsToRange(bounds);
            }
        }, shiftWorldToZero() {
            const shiftAmount = -this.bounds.min;
            this.timestampShiftToZeroAmount_ = shiftAmount;
            for (const ec of this.childEventContainers()) {
                ec.shiftTimestampsForward(shiftAmount);
            }
            for (const event of this.childEvents()) {
                event.start += shiftAmount;
            }
            this.updateBounds();
        }, convertTimestampToModelTime(sourceClockDomainName, ts) {
            if (sourceClockDomainName !== 'traceEventClock') {
                throw new Error('Only traceEventClock is supported.');
            }
            return tr.b.Unit.timestampFromUs(ts) +
                this.timestampShiftToZeroAmount_;
        }, get numProcesses() {
            let n = 0;
            for (const p in this.processes) {
                n++;
            }
            return n;
        }, getProcess(pid) {
            return this.processes[pid];
        }, getOrCreateProcess(pid) {
            if (!this.processes[pid]) {
                this.processes[pid] = new Process(this, pid);
            }
            return this.processes[pid];
        }, addStackFrame(stackFrame) {
            if (this.stackFrames[stackFrame.id]) {
                throw new Error('Stack frame already exists');
            }
            this.stackFrames[stackFrame.id] = stackFrame;
            return stackFrame;
        }, updateCategories_() {
            const categoriesDict = {};
            this.userModel.addCategoriesToDict(categoriesDict);
            this.device.addCategoriesToDict(categoriesDict);
            this.kernel.addCategoriesToDict(categoriesDict);
            for (const pid in this.processes) {
                this.processes[pid].addCategoriesToDict(categoriesDict);
            }
            this.categories = [];
            for (const category in categoriesDict) {
                if (category !== '') {
                    this.categories.push(category);
                }
            }
        }, getAllThreads() {
            const threads = [];
            for (const tid in this.kernel.threads) {
                threads.push(process.threads[tid]);
            }
            for (const pid in this.processes) {
                const process = this.processes[pid];
                for (const tid in process.threads) {
                    threads.push(process.threads[tid]);
                }
            }
            return threads;
        }, getAllProcesses(opt_predicate) {
            const processes = [];
            for (const pid in this.processes) {
                const process = this.processes[pid];
                if (opt_predicate === undefined || opt_predicate(process)) {
                    processes.push(process);
                }
            }
            return processes;
        }, getAllCounters() {
            const counters = [];
            counters.push.apply(counters, Object.values(this.device.counters || {}));
            counters.push.apply(counters, Object.values(this.kernel.counters || {}));
            for (const pid in this.processes) {
                const process = this.processes[pid];
                for (const tid in process.counters) {
                    counters.push(process.counters[tid]);
                }
            }
            return counters;
        }, getAnnotationByGUID(guid) {
            return this.annotationsByGuid_[guid];
        }, addAnnotation(annotation) {
            if (!annotation.guid) {
                throw new Error('Annotation with undefined guid given');
            }
            this.annotationsByGuid_[annotation.guid] = annotation;
            tr.b.dispatchSimpleEvent(this, 'annotationChange');
        }, removeAnnotation(annotation) {
            this.annotationsByGuid_[annotation.guid].onRemove();
            delete this.annotationsByGuid_[annotation.guid];
            tr.b.dispatchSimpleEvent(this, 'annotationChange');
        }, getAllAnnotations() {
            return Object.values(this.annotationsByGuid_);
        }, addUserFriendlyCategoryDriver(ufcd) {
            this.userFriendlyCategoryDrivers_.push(ufcd);
        }, getUserFriendlyCategoryFromEvent(event) {
            for (let i = 0; i < this.userFriendlyCategoryDrivers_.length; i++) {
                const ufc = this.userFriendlyCategoryDrivers_[i].fromEvent(event);
                if (ufc !== undefined) return ufc;
            }
            return undefined;
        }, findAllThreadsNamed(name) {
            const namedThreads = [];
            namedThreads.push.apply(namedThreads, this.kernel.findAllThreadsNamed(name));
            for (const pid in this.processes) {
                namedThreads.push.apply(namedThreads, this.processes[pid].findAllThreadsNamed(name));
            }
            return namedThreads;
        }, get importOptions() {
            return this.importOptions_;
        }, set importOptions(options) {
            this.importOptions_ = options;
        }, get intrinsicTimeUnit() {
            if (this.intrinsicTimeUnit_ === undefined) {
                return tr.b.TimeDisplayModes.ms;
            }
            return this.intrinsicTimeUnit_;
        }, set intrinsicTimeUnit(value) {
            if (this.intrinsicTimeUnit_ === value) return;
            if (this.intrinsicTimeUnit_ !== undefined) {
                throw new Error('Intrinsic time unit already set');
            }
            this.intrinsicTimeUnit_ = value;
        }, get isTimeHighResolution() {
            return this.isTimeHighResolution_;
        }, set isTimeHighResolution(value) {
            this.isTimeHighResolution_ = value;
        }, get canonicalUrl() {
            return this.canonicalUrl_;
        }, set canonicalUrl(value) {
            if (this.canonicalUrl_ === value) return;
            if (this.canonicalUrl_ !== undefined) {
                throw new Error('canonicalUrl already set');
            }
            this.canonicalUrl_ = value;
        }, importWarning(data) {
            data.showToUser = !!data.showToUser;
            this.importWarnings_.push(data);
            if (this.reportedImportWarnings_[data.type] === true) return;
            this.reportedImportWarnings_[data.type] = true;
        }, get hasImportWarnings() {
            return (this.importWarnings_.length > 0);
        }, get importWarnings() {
            return this.importWarnings_;
        }, get importWarningsThatShouldBeShownToUser() {
            return this.importWarnings_.filter(function (warning) {
                return warning.showToUser;
            });
        }, autoCloseOpenSlices() {
            this.samples.sort(function (x, y) {
                return x.start - y.start;
            });
            this.updateBounds();
            this.kernel.autoCloseOpenSlices();
            for (const pid in this.processes) {
                this.processes[pid].autoCloseOpenSlices();
            }
        }, createSubSlices() {
            this.kernel.createSubSlices();
            for (const pid in this.processes) {
                this.processes[pid].createSubSlices();
            }
        }, preInitializeObjects() {
            for (const pid in this.processes) {
                this.processes[pid].preInitializeObjects();
            }
        }, initializeObjects() {
            for (const pid in this.processes) {
                this.processes[pid].initializeObjects();
            }
        }, pruneEmptyContainers() {
            this.kernel.pruneEmptyContainers();
            for (const pid in this.processes) {
                this.processes[pid].pruneEmptyContainers();
            }
        }, mergeKernelWithUserland() {
            for (const pid in this.processes) {
                this.processes[pid].mergeKernelWithUserland();
            }
        }, computeWorldBounds(shiftWorldToZero) {
            this.updateBounds();
            this.updateCategories_();
            if (shiftWorldToZero) {
                this.shiftWorldToZero();
            }
        }, buildFlowEventIntervalTree() {
            for (let i = 0; i < this.flowEvents.length; ++i) {
                const flowEvent = this.flowEvents[i];
                this.flowIntervalTree.insert(flowEvent);
            }
            this.flowIntervalTree.updateHighValues();
        }, cleanupUndeletedObjects() {
            for (const pid in this.processes) {
                this.processes[pid].autoDeleteObjects(this.bounds.max);
            }
        }, sortMemoryDumps() {
            this.globalMemoryDumps.sort(function (x, y) {
                return x.start - y.start;
            });
            for (const pid in this.processes) {
                this.processes[pid].sortMemoryDumps();
            }
        }, finalizeMemoryGraphs() {
            this.globalMemoryDumps.forEach(function (dump) {
                dump.finalizeGraph();
            });
        }, buildEventIndices() {
            this.modelIndices = new tr.model.ModelIndices(this);
        }, sortAlerts() {
            this.alerts.sort(function (x, y) {
                return x.start - y.start;
            });
        }, applyObjectRefPatchups() {
            const unresolved = [];
            this.patchupsToApply_.forEach(function (patchup) {
                if (patchup.pidRef in this.processes) {
                    const snapshot = this.processes[patchup.pidRef].objects.getSnapshotAt(patchup.scopedId, patchup.ts);
                    if (snapshot) {
                        patchup.object[patchup.field] = snapshot;
                        snapshot.referencedAt(patchup.item, patchup.object, patchup.field);
                        return;
                    }
                }
                unresolved.push(patchup);
            }, this);
            this.patchupsToApply_ = unresolved;
        }, replacePIDRefsInPatchups(oldPidRef, newPidRef) {
            this.patchupsToApply_.forEach(function (patchup) {
                if (patchup.pidRef === oldPidRef) {
                    patchup.pidRef = newPidRef;
                }
            });
        }, joinRefs() {
            this.joinObjectRefs_();
            this.applyObjectRefPatchups();
        }, joinObjectRefs_() {
            for (const [pid, process] of Object.entries(this.processes)) {
                this.joinObjectRefsForProcess_(pid, process);
            }
        }, joinObjectRefsForProcess_(pid, process) {
            for (const thread of Object.values(process.threads)) {
                thread.asyncSliceGroup.slices.forEach(function (item) {
                    this.searchItemForIDRefs_(pid, 'start', item);
                }, this);
                thread.sliceGroup.slices.forEach(function (item) {
                    this.searchItemForIDRefs_(pid, 'start', item);
                }, this);
            }
            process.objects.iterObjectInstances(function (instance) {
                instance.snapshots.forEach(function (item) {
                    this.searchItemForIDRefs_(pid, 'ts', item);
                }, this);
            }, this);
        }, searchItemForIDRefs_(pid, itemTimestampField, item) {
            if (!item.args && !item.contexts) return;
            const patchupsToApply = this.patchupsToApply_;

            function handleField(object, fieldName, fieldValue) {
                if (!fieldValue || (!fieldValue.id_ref && !fieldValue.idRef)) {
                    return;
                }
                const scope = fieldValue.scope || tr.model.OBJECT_DEFAULT_SCOPE;
                const idRef = fieldValue.id_ref || fieldValue.idRef;
                const scopedId = new tr.model.ScopedId(scope, idRef);
                const pidRef = fieldValue.pid_ref || fieldValue.pidRef || pid;
                const ts = item[itemTimestampField];
                patchupsToApply.push({item, object, field: fieldName, pidRef, scopedId, ts});
            }

            function iterObjectFieldsRecursively(object) {
                if (!(object instanceof Object)) return;
                if ((object instanceof tr.model.ObjectSnapshot) || (object instanceof Float32Array) || (object instanceof tr.b.math.Quad)) {
                    return;
                }
                if (object instanceof Array) {
                    for (let i = 0; i < object.length; i++) {
                        handleField(object, i, object[i]);
                        iterObjectFieldsRecursively(object[i]);
                    }
                    return;
                }
                for (const key in object) {
                    const value = object[key];
                    handleField(object, key, value);
                    iterObjectFieldsRecursively(value);
                }
            }

            iterObjectFieldsRecursively(item.args);
            iterObjectFieldsRecursively(item.contexts);
        }
    };
    return {Model,};
});
'use strict';
tr.exportTo('tr.e.importer.etw', function () {
    const kThreadGuid = '3D6FA8D1-FE05-11D0-9DDA-00C04FD7BA7C';
    const kThreadDCStartOpcode = 3;

    function Decoder() {
        this.payload_ = new DataView(new ArrayBuffer(256));
    }

    Decoder.prototype = {
        __proto__: Object.prototype, reset(base64Payload) {
            const decodedSize = tr.b.Base64.getDecodedBufferLength(base64Payload);
            if (decodedSize > this.payload_.byteLength) {
                this.payload_ = new DataView(new ArrayBuffer(decodedSize));
            }
            tr.b.Base64.DecodeToTypedArray(base64Payload, this.payload_);
            this.position_ = 0;
        }, skip(length) {
            this.position_ += length;
        }, decodeUInt8() {
            const result = this.payload_.getUint8(this.position_, true);
            this.position_ += 1;
            return result;
        }, decodeUInt16() {
            const result = this.payload_.getUint16(this.position_, true);
            this.position_ += 2;
            return result;
        }, decodeUInt32() {
            const result = this.payload_.getUint32(this.position_, true);
            this.position_ += 4;
            return result;
        }, decodeUInt64ToString() {
            const low = this.decodeUInt32();
            const high = this.decodeUInt32();
            const lowStr = ('0000000' + low.toString(16)).substr(-8);
            const highStr = ('0000000' + high.toString(16)).substr(-8);
            const result = highStr + lowStr;
            return result;
        }, decodeInt8() {
            const result = this.payload_.getInt8(this.position_, true);
            this.position_ += 1;
            return result;
        }, decodeInt16() {
            const result = this.payload_.getInt16(this.position_, true);
            this.position_ += 2;
            return result;
        }, decodeInt32() {
            const result = this.payload_.getInt32(this.position_, true);
            this.position_ += 4;
            return result;
        }, decodeInt64ToString() {
            return this.decodeUInt64ToString();
        }, decodeUInteger(is64) {
            if (is64) {
                return this.decodeUInt64ToString();
            }
            return this.decodeUInt32();
        }, decodeString() {
            let str = '';
            while (true) {
                const c = this.decodeUInt8();
                if (!c) return str;
                str = str + String.fromCharCode(c);
            }
        }, decodeW16String() {
            let str = '';
            while (true) {
                const c = this.decodeUInt16();
                if (!c) return str;
                str = str + String.fromCharCode(c);
            }
        }, decodeFixedW16String(length) {
            const oldPosition = this.position_;
            let str = '';
            for (let i = 0; i < length; i++) {
                const c = this.decodeUInt16();
                if (!c) break;
                str = str + String.fromCharCode(c);
            }
            this.position_ = oldPosition + 2 * length;
            return str;
        }, decodeBytes(length) {
            const bytes = [];
            for (let i = 0; i < length; ++i) {
                const c = this.decodeUInt8();
                bytes.push(c);
            }
            return bytes;
        }, decodeSID(is64) {
            const pSid = this.decodeUInteger(is64);
            const attributes = this.decodeUInt32();
            if (is64) {
                this.decodeUInt32();
            }
            const revision = this.decodeUInt8();
            const subAuthorityCount = this.decodeUInt8();
            this.decodeUInt16();
            this.decodeUInt32();
            if (revision !== 1) {
                throw new Error('Invalid SID revision: could not decode the SID structure.');
            }
            const sid = this.decodeBytes(4 * subAuthorityCount);
            return {pSid, attributes, sid};
        }, decodeSystemTime() {
            const wYear = this.decodeInt16();
            const wMonth = this.decodeInt16();
            const wDayOfWeek = this.decodeInt16();
            const wDay = this.decodeInt16();
            const wHour = this.decodeInt16();
            const wMinute = this.decodeInt16();
            const wSecond = this.decodeInt16();
            const wMilliseconds = this.decodeInt16();
            return {wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, wMilliseconds};
        }, decodeTimeZoneInformation() {
            const bias = this.decodeUInt32();
            const standardName = this.decodeFixedW16String(32);
            const standardDate = this.decodeSystemTime();
            const standardBias = this.decodeUInt32();
            const daylightName = this.decodeFixedW16String(32);
            const daylightDate = this.decodeSystemTime();
            const daylightBias = this.decodeUInt32();
            return {bias, standardName, standardDate, standardBias, daylightName, daylightDate, daylightBias};
        }
    };

    function EtwImporter(model, events) {
        this.importPriority = 3;
        this.model_ = model;
        this.events_ = events;
        this.handlers_ = {};
        this.decoder_ = new Decoder();
        this.walltime_ = undefined;
        this.ticks_ = undefined;
        this.is64bit_ = undefined;
        this.tidsToPid_ = {};
        const allTypeInfos = tr.e.importer.etw.Parser.getAllRegisteredTypeInfos();
        this.parsers_ = allTypeInfos.map(function (typeInfo) {
            return new typeInfo.constructor(this);
        }, this);
    }

    EtwImporter.canImport = function (events) {
        if (!events.hasOwnProperty('name') || !events.hasOwnProperty('content') || events.name !== 'ETW') {
            return false;
        }
        return true;
    };
    EtwImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'EtwImporter';
        }, get model() {
            return this.model_;
        }, createThreadIfNeeded(pid, tid) {
            this.tidsToPid_[tid] = pid;
        }, removeThreadIfPresent(tid) {
            this.tidsToPid_[tid] = undefined;
        }, getPidFromWindowsTid(tid) {
            if (tid === 0) return 0;
            const pid = this.tidsToPid_[tid];
            if (pid === undefined) {
                return 0;
            }
            return pid;
        }, getThreadFromWindowsTid(tid) {
            const pid = this.getPidFromWindowsTid(tid);
            const process = this.model_.getProcess(pid);
            if (!process) return undefined;
            return process.getThread(tid);
        }, getOrCreateCpu(cpuNumber) {
            const cpu = this.model_.kernel.getOrCreateCpu(cpuNumber);
            return cpu;
        }, importEvents() {
            this.events_.content.forEach(this.parseInfo.bind(this));
            if (this.walltime_ === undefined || this.ticks_ === undefined) {
                throw Error('Cannot find clock sync information in the system trace.');
            }
            if (this.is64bit_ === undefined) {
                throw Error('Cannot determine pointer size of the system trace.' + 'Consider deselecting "System tracing" or disabling the "Paging ' + 'Executive" feature of Windows');
            }
            this.events_.content.forEach(this.parseEvent.bind(this));
        }, importTimestamp(timestamp) {
            const ts = parseInt(timestamp, 16);
            return (ts - this.walltime_ + this.ticks_) / 1000.;
        }, parseInfo(event) {
            if (event.hasOwnProperty('guid') && event.hasOwnProperty('walltime') && event.hasOwnProperty('tick') && event.guid === 'ClockSync') {
                this.walltime_ = parseInt(event.walltime, 16);
                this.ticks_ = parseInt(event.tick, 16);
            }
            if (this.is64bit_ === undefined && event.hasOwnProperty('guid') && event.hasOwnProperty('op') && event.hasOwnProperty('ver') && event.hasOwnProperty('payload') && event.guid === kThreadGuid && event.op === kThreadDCStartOpcode) {
                const decodedSize = tr.b.Base64.getDecodedBufferLength(event.payload);
                if (event.ver === 1) {
                    if (decodedSize >= 52) {
                        this.is64bit_ = true;
                    } else {
                        this.is64bit_ = false;
                    }
                } else if (event.ver === 2) {
                    if (decodedSize >= 64) {
                        this.is64bit_ = true;
                    } else {
                        this.is64bit_ = false;
                    }
                } else if (event.ver === 3) {
                    if (decodedSize >= 60) {
                        this.is64bit_ = true;
                    } else {
                        this.is64bit_ = false;
                    }
                }
            }
            return true;
        }, parseEvent(event) {
            if (!event.hasOwnProperty('guid') || !event.hasOwnProperty('op') || !event.hasOwnProperty('ver') || !event.hasOwnProperty('cpu') || !event.hasOwnProperty('ts') || !event.hasOwnProperty('payload')) {
                return false;
            }
            const timestamp = this.importTimestamp(event.ts);
            const header = {
                guid: event.guid,
                opcode: event.op,
                version: event.ver,
                cpu: event.cpu,
                timestamp,
                is64: this.is64bit_
            };
            const decoder = this.decoder_;
            decoder.reset(event.payload);
            const handler = this.getEventHandler(header.guid, header.opcode);
            if (!handler) return false;
            if (!handler(header, decoder)) {
                this.model_.importWarning({
                    type: 'parse_error',
                    message: 'Malformed ' + header.guid + ' event (' + event.payload + ')'
                });
                return false;
            }
            return true;
        }, registerEventHandler(guid, opcode, handler) {
            if (this.handlers_[guid] === undefined) {
                this.handlers_[guid] = [];
            }
            this.handlers_[guid][opcode] = handler;
        }, getEventHandler(guid, opcode) {
            if (this.handlers_[guid] === undefined) {
                return undefined;
            }
            return this.handlers_[guid][opcode];
        }
    };
    tr.importer.Importer.register(EtwImporter);
    return {EtwImporter,};
});
'use strict';
tr.exportTo('tr.b', function () {
    class TraceStream {
        static get HEADER_SIZE() {
            return Math.pow(2, 10);
        }

        static get CHUNK_SIZE() {
            return Math.pow(2, 20);
        }

        get isBinary() {
            throw new Error('Not implemented');
        }

        get hasData() {
            throw new Error('Not implemented');
        }

        get header() {
            throw new Error('Not implemented');
        }

        readUntilDelimiter(delim) {
            throw new Error('Not implemented');
        }

        readNumBytes(opt_size) {
            throw new Error('Not implemented');
        }

        rewind() {
            throw new Error('Not implemented');
        }

        substream(offset, opt_length, opt_headerSize) {
            throw new Error('Not implemented');
        }
    }

    return {TraceStream,};
});
'use strict';
tr.exportTo('tr.e.importer.fuchsia', function () {
    const IMPORT_PRIORITY = 0;
    const IDLE_THREAD_THRESHOLD = 6444000000;
    const ZX_THREAD_STATE_NEW = 0;
    const ZX_THREAD_STATE_RUNNING = 1;
    const ZX_THREAD_STATE_SUSPENDED = 2;
    const ZX_THREAD_STATE_BLOCKED = 3;
    const ZX_THREAD_STATE_DYING = 4;
    const ZX_THREAD_STATE_DEAD = 5;

    class FuchsiaImporter extends tr.importer.Importer {
        constructor(model, eventData) {
            super(model, eventData);
            this.importPriority = IMPORT_PRIORITY;
            this.model_ = model;
            this.events_ = eventData.events;
            this.parsers_ = [];
            this.threadInfo_ = new Map();
            this.processNames_ = new Map();
            this.threadStates_ = new Map();
        }

        static canImport(eventData) {
            if (eventData instanceof tr.b.TraceStream) {
                if (eventData.isBinary) return false;
                eventData = eventData.header;
            }
            if (eventData instanceof Object && eventData.type === 'fuchsia') {
                return true;
            }
            return false;
        }

        get importerName() {
            return 'FuchsiaImporter';
        }

        get model() {
            return this.model_;
        }

        importClockSyncMarkers() {
        }

        finalizeImport() {
        }

        isIdleThread(prio, tid) {
            if (prio === undefined) {
                return tid > IDLE_THREAD_THRESHOLD;
            }
            return prio === 0;
        }

        recordThreadState_(tid, timestamp, state, prio) {
            if (this.isIdleThread(prio, tid)) {
                return;
            }
            const states = this.threadStates_.has(tid) ? this.threadStates_.get(tid) : [];
            states.push({'ts': timestamp, state});
            this.threadStates_.set(tid, states);
        }

        processContextSwitchEvent_(event) {
            let tid = event.in.tid;
            let threadName = tid.toString();
            let procName = '';
            const prio = event.in.prio;
            if (this.threadInfo_.has(tid)) {
                const threadInfo = this.threadInfo_.get(tid);
                threadName = threadInfo.name;
                const pid = threadInfo.pid;
                if (this.processNames_.has(pid)) {
                    procName = this.processNames_.get(pid) + ':';
                }
            }
            const name = procName + threadName;
            if (this.isIdleThread(prio, tid)) {
                tid = undefined;
            }
            const cpu = this.model_.kernel.getOrCreateCpu(event.cpu);
            const timestamp = tr.b.Unit.timestampFromUs(event.ts);
            cpu.switchActiveThread(timestamp, {}, tid, name, tid);
            const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
            this.recordThreadState_(tid, timestamp, SCHEDULING_STATE.RUNNING, prio);
            let outState = SCHEDULING_STATE.UNKNOWN;
            switch (event.out.state) {
                case ZX_THREAD_STATE_NEW:
                    outState = SCHEDULING_STATE.RUNNABLE;
                    break;
                case ZX_THREAD_STATE_RUNNING:
                    outState = SCHEDULING_STATE.RUNNABLE;
                    break;
                case ZX_THREAD_STATE_BLOCKED:
                    outState = SCHEDULING_STATE.SLEEPING;
                    break;
                case ZX_THREAD_STATE_SUSPENDED:
                    outState = SCHEDULING_STATE.STOPPED;
                    break;
                case ZX_THREAD_STATE_DEAD:
                    outState = SCHEDULING_STATE.TASK_DEAD;
                    break;
            }
            this.recordThreadState_(event.out.tid, timestamp, outState, event.out.prio);
        }

        processProcessInfoEvent_(event) {
            const process = this.model_.getOrCreateProcess(event.pid);
            process.name = event.name;
            this.processNames_.set(event.pid, event.name);
            if ('sort_index' in event) {
                process.sortIndex = event.sort_index;
            }
        }

        processThreadInfoEvent_(event) {
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            thread.name = event.name;
            this.threadInfo_.set(event.tid, {'name': event.name, 'pid': event.pid});
            if ('sort_index' in event) {
                const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
                thread.sortIndex = event.sort_index;
            }
        }

        processEvent_(event) {
            switch (event.ph) {
                case'k':
                    this.processContextSwitchEvent_(event);
                    break;
                case'p':
                    this.processProcessInfoEvent_(event);
                    break;
                case't':
                    this.processThreadInfoEvent_(event);
                    break;
            }
        }

        postProcessStates_() {
            for (const [tid, states] of this.threadStates_) {
                if (!this.threadInfo_.has(tid)) {
                    continue;
                }
                const pid = this.threadInfo_.get(tid).pid;
                const thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
                const slices = [];
                for (let i = 0; i < states.length - 1; i++) {
                    slices.push(new tr.model.ThreadTimeSlice(thread, states[i].state, '', states[i].ts, {}, states[i + 1].ts - states[i].ts));
                }
                thread.timeSlices = slices;
            }
        }

        importEvents() {
            for (const event of this.events_) {
                this.processEvent_(event);
            }
            this.postProcessStates_();
        }
    }

    tr.importer.Importer.register(FuchsiaImporter);
    return {FuchsiaImporter, IMPORT_PRIORITY,};
});
'use strict';
tr.exportTo('tr.b', function () {
    const MAX_FUNCTION_ARGS_COUNT = Math.pow(2, 15) - 1;

    class InMemoryTraceStream extends tr.b.TraceStream {
        constructor(buffer, isBinary, opt_headerSize) {
            super();
            if (!buffer instanceof Uint8Array) {
                throw new Error('buffer should be a Uint8Array');
            }
            const headerSize = opt_headerSize || tr.b.TraceStream.HEADER_SIZE;
            this.data_ = buffer;
            this.isBinary_ = isBinary;
            this.header_ = InMemoryTraceStream.uint8ArrayToString_(this.data_.subarray(0, headerSize));
            this.cursor_ = 0;
        }

        get isBinary() {
            return this.isBinary_;
        }

        get hasData() {
            return this.cursor_ < this.data_.length;
        }

        get header() {
            return this.header_;
        }

        get data() {
            return this.data_;
        }

        toString() {
            this.rewind();
            return this.readNumBytes(Number.MAX_VALUE);
        }

        readUntilDelimiter(delim) {
            if (delim.length !== 1) {
                throw new Error('delim must be exactly one character');
            }
            const offset = this.data_.indexOf(delim.charCodeAt(0), this.cursor_) + 1;
            return this.readToOffset_(offset > 0 ? Math.min(offset, this.data_.length) : this.data_.length);
        }

        readNumBytes(opt_size) {
            if (opt_size !== undefined && opt_size <= 0) {
                throw new Error(`readNumBytes expects a positive size (${opt_size} given)`);
            }
            const size = opt_size || tr.b.TraceStream.CHUNK_SIZE;
            const offset = Math.min(this.cursor_ + size, this.data_.length);
            return this.readToOffset_(offset);
        }

        rewind() {
            this.cursor_ = 0;
        }

        substream(startOffset, opt_endOffset, opt_headerSize) {
            return new InMemoryTraceStream(this.data_.subarray(startOffset, opt_endOffset), this.isBinary_, opt_headerSize);
        }

        readToOffset_(offset) {
            const out = InMemoryTraceStream.uint8ArrayToString_(this.data_.subarray(this.cursor_, offset));
            this.cursor_ = offset;
            return out;
        }

        static uint8ArrayToString_(arr) {
            if (typeof TextDecoder !== 'undefined') {
                const decoder = new TextDecoder('utf-8');
                return decoder.decode(arr);
            }
            const c = [];
            for (let i = 0; i < arr.length; i += MAX_FUNCTION_ARGS_COUNT) {
                c.push(String.fromCharCode(...arr.subarray(i, i + MAX_FUNCTION_ARGS_COUNT)));
            }
            return c.join('');
        }
    }

    return {InMemoryTraceStream,};
});
!function (t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).pako = t()
    }
}(function () {
    return function t(e, a, i) {
        function n(s, o) {
            if (!a[s]) {
                if (!e[s]) {
                    var l = "function" == typeof require && require;
                    if (!o && l) return l(s, !0);
                    if (r) return r(s, !0);
                    var h = new Error("Cannot find module '" + s + "'");
                    throw h.code = "MODULE_NOT_FOUND", h
                }
                var d = a[s] = {exports: {}};
                e[s][0].call(d.exports, function (t) {
                    var a = e[s][1][t];
                    return n(a || t)
                }, d, d.exports, t, e, a, i)
            }
            return a[s].exports
        }

        for (var r = "function" == typeof require && require, s = 0; s < i.length; s++) n(i[s]);
        return n
    }({
        1: [function (t, e, a) {
            "use strict";

            function i(t) {
                if (!(this instanceof i)) return new i(t);
                this.options = s.assign({
                    level: _,
                    method: c,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: u,
                    to: ""
                }, t || {});
                var e = this.options;
                e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h, this.strm.avail_out = 0;
                var a = r.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
                if (a !== f) throw new Error(l[a]);
                if (e.header && r.deflateSetHeader(this.strm, e.header), e.dictionary) {
                    var n;
                    if (n = "string" == typeof e.dictionary ? o.string2buf(e.dictionary) : "[object ArrayBuffer]" === d.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (a = r.deflateSetDictionary(this.strm, n)) !== f) throw new Error(l[a]);
                    this._dict_set = !0
                }
            }

            function n(t, e) {
                var a = new i(e);
                if (a.push(t, !0), a.err) throw a.msg || l[a.err];
                return a.result
            }

            var r = t("./zlib/deflate"), s = t("./utils/common"), o = t("./utils/strings"),
                l = t("./zlib/messages"), h = t("./zlib/zstream"), d = Object.prototype.toString, f = 0, _ = -1,
                u = 0, c = 8;
            i.prototype.push = function (t, e) {
                var a, i, n = this.strm, l = this.options.chunkSize;
                if (this.ended) return !1;
                i = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? n.input = o.string2buf(t) : "[object ArrayBuffer]" === d.call(t) ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;
                do {
                    if (0 === n.avail_out && (n.output = new s.Buf8(l), n.next_out = 0, n.avail_out = l), 1 !== (a = r.deflate(n, i)) && a !== f) return this.onEnd(a), this.ended = !0, !1;
                    0 !== n.avail_out && (0 !== n.avail_in || 4 !== i && 2 !== i) || ("string" === this.options.to ? this.onData(o.buf2binstring(s.shrinkBuf(n.output, n.next_out))) : this.onData(s.shrinkBuf(n.output, n.next_out)))
                } while ((n.avail_in > 0 || 0 === n.avail_out) && 1 !== a);
                return 4 === i ? (a = r.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === f) : 2 !== i || (this.onEnd(f), n.avail_out = 0, !0)
            }, i.prototype.onData = function (t) {
                this.chunks.push(t)
            }, i.prototype.onEnd = function (t) {
                t === f && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            }, a.Deflate = i, a.deflate = n, a.deflateRaw = function (t, e) {
                return e = e || {}, e.raw = !0, n(t, e)
            }, a.gzip = function (t, e) {
                return e = e || {}, e.gzip = !0, n(t, e)
            }
        }, {
            "./utils/common": 3,
            "./utils/strings": 4,
            "./zlib/deflate": 8,
            "./zlib/messages": 13,
            "./zlib/zstream": 15
        }],
        2: [function (t, e, a) {
            "use strict";

            function i(t) {
                if (!(this instanceof i)) return new i(t);
                this.options = s.assign({chunkSize: 16384, windowBits: 0, to: ""}, t || {});
                var e = this.options;
                e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d, this.strm.avail_out = 0;
                var a = r.inflateInit2(this.strm, e.windowBits);
                if (a !== l.Z_OK) throw new Error(h[a]);
                this.header = new f, r.inflateGetHeader(this.strm, this.header)
            }

            function n(t, e) {
                var a = new i(e);
                if (a.push(t, !0), a.err) throw a.msg || h[a.err];
                return a.result
            }

            var r = t("./zlib/inflate"), s = t("./utils/common"), o = t("./utils/strings"),
                l = t("./zlib/constants"), h = t("./zlib/messages"), d = t("./zlib/zstream"),
                f = t("./zlib/gzheader"), _ = Object.prototype.toString;
            i.prototype.push = function (t, e) {
                var a, i, n, h, d, f, u = this.strm, c = this.options.chunkSize, b = this.options.dictionary,
                    g = !1;
                if (this.ended) return !1;
                i = e === ~~e ? e : !0 === e ? l.Z_FINISH : l.Z_NO_FLUSH, "string" == typeof t ? u.input = o.binstring2buf(t) : "[object ArrayBuffer]" === _.call(t) ? u.input = new Uint8Array(t) : u.input = t, u.next_in = 0, u.avail_in = u.input.length;
                do {
                    if (0 === u.avail_out && (u.output = new s.Buf8(c), u.next_out = 0, u.avail_out = c), (a = r.inflate(u, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && b && (f = "string" == typeof b ? o.string2buf(b) : "[object ArrayBuffer]" === _.call(b) ? new Uint8Array(b) : b, a = r.inflateSetDictionary(this.strm, f)), a === l.Z_BUF_ERROR && !0 === g && (a = l.Z_OK, g = !1), a !== l.Z_STREAM_END && a !== l.Z_OK) return this.onEnd(a), this.ended = !0, !1;
                    u.next_out && (0 !== u.avail_out && a !== l.Z_STREAM_END && (0 !== u.avail_in || i !== l.Z_FINISH && i !== l.Z_SYNC_FLUSH) || ("string" === this.options.to ? (n = o.utf8border(u.output, u.next_out), h = u.next_out - n, d = o.buf2string(u.output, n), u.next_out = h, u.avail_out = c - h, h && s.arraySet(u.output, u.output, n, h, 0), this.onData(d)) : this.onData(s.shrinkBuf(u.output, u.next_out)))), 0 === u.avail_in && 0 === u.avail_out && (g = !0)
                } while ((u.avail_in > 0 || 0 === u.avail_out) && a !== l.Z_STREAM_END);
                return a === l.Z_STREAM_END && (i = l.Z_FINISH), i === l.Z_FINISH ? (a = r.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === l.Z_OK) : i !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), u.avail_out = 0, !0)
            }, i.prototype.onData = function (t) {
                this.chunks.push(t)
            }, i.prototype.onEnd = function (t) {
                t === l.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            }, a.Inflate = i, a.inflate = n, a.inflateRaw = function (t, e) {
                return e = e || {}, e.raw = !0, n(t, e)
            }, a.ungzip = n
        }, {
            "./utils/common": 3,
            "./utils/strings": 4,
            "./zlib/constants": 6,
            "./zlib/gzheader": 9,
            "./zlib/inflate": 11,
            "./zlib/messages": 13,
            "./zlib/zstream": 15
        }],
        3: [function (t, e, a) {
            "use strict";

            function i(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }

            var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
            a.assign = function (t) {
                for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {
                    var a = e.shift();
                    if (a) {
                        if ("object" != typeof a) throw new TypeError(a + "must be non-object");
                        for (var n in a) i(a, n) && (t[n] = a[n])
                    }
                }
                return t
            }, a.shrinkBuf = function (t, e) {
                return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t)
            };
            var r = {
                arraySet: function (t, e, a, i, n) {
                    if (e.subarray && t.subarray) t.set(e.subarray(a, a + i), n); else for (var r = 0; r < i; r++) t[n + r] = e[a + r]
                }, flattenChunks: function (t) {
                    var e, a, i, n, r, s;
                    for (i = 0, e = 0, a = t.length; e < a; e++) i += t[e].length;
                    for (s = new Uint8Array(i), n = 0, e = 0, a = t.length; e < a; e++) r = t[e], s.set(r, n), n += r.length;
                    return s
                }
            }, s = {
                arraySet: function (t, e, a, i, n) {
                    for (var r = 0; r < i; r++) t[n + r] = e[a + r]
                }, flattenChunks: function (t) {
                    return [].concat.apply([], t)
                }
            };
            a.setTyped = function (t) {
                t ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, r)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, s))
            }, a.setTyped(n)
        }, {}],
        4: [function (t, e, a) {
            "use strict";

            function i(t, e) {
                if (e < 65537 && (t.subarray && s || !t.subarray && r)) return String.fromCharCode.apply(null, n.shrinkBuf(t, e));
                for (var a = "", i = 0; i < e; i++) a += String.fromCharCode(t[i]);
                return a
            }

            var n = t("./common"), r = !0, s = !0;
            try {
                String.fromCharCode.apply(null, [0])
            } catch (t) {
                r = !1
            }
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (t) {
                s = !1
            }
            for (var o = new n.Buf8(256), l = 0; l < 256; l++) o[l] = l >= 252 ? 6 : l >= 248 ? 5 : l >= 240 ? 4 : l >= 224 ? 3 : l >= 192 ? 2 : 1;
            o[254] = o[254] = 1, a.string2buf = function (t) {
                var e, a, i, r, s, o = t.length, l = 0;
                for (r = 0; r < o; r++) 55296 == (64512 & (a = t.charCodeAt(r))) && r + 1 < o && 56320 == (64512 & (i = t.charCodeAt(r + 1))) && (a = 65536 + (a - 55296 << 10) + (i - 56320), r++), l += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
                for (e = new n.Buf8(l), s = 0, r = 0; s < l; r++) 55296 == (64512 & (a = t.charCodeAt(r))) && r + 1 < o && 56320 == (64512 & (i = t.charCodeAt(r + 1))) && (a = 65536 + (a - 55296 << 10) + (i - 56320), r++), a < 128 ? e[s++] = a : a < 2048 ? (e[s++] = 192 | a >>> 6, e[s++] = 128 | 63 & a) : a < 65536 ? (e[s++] = 224 | a >>> 12, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a) : (e[s++] = 240 | a >>> 18, e[s++] = 128 | a >>> 12 & 63, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a);
                return e
            }, a.buf2binstring = function (t) {
                return i(t, t.length)
            }, a.binstring2buf = function (t) {
                for (var e = new n.Buf8(t.length), a = 0, i = e.length; a < i; a++) e[a] = t.charCodeAt(a);
                return e
            }, a.buf2string = function (t, e) {
                var a, n, r, s, l = e || t.length, h = new Array(2 * l);
                for (n = 0, a = 0; a < l;) if ((r = t[a++]) < 128) h[n++] = r; else if ((s = o[r]) > 4) h[n++] = 65533, a += s - 1; else {
                    for (r &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && a < l;) r = r << 6 | 63 & t[a++], s--;
                    s > 1 ? h[n++] = 65533 : r < 65536 ? h[n++] = r : (r -= 65536, h[n++] = 55296 | r >> 10 & 1023, h[n++] = 56320 | 1023 & r)
                }
                return i(h, n)
            }, a.utf8border = function (t, e) {
                var a;
                for ((e = e || t.length) > t.length && (e = t.length), a = e - 1; a >= 0 && 128 == (192 & t[a]);) a--;
                return a < 0 ? e : 0 === a ? e : a + o[t[a]] > e ? a : e
            }
        }, {"./common": 3}],
        5: [function (t, e, a) {
            "use strict";
            e.exports = function (t, e, a, i) {
                for (var n = 65535 & t | 0, r = t >>> 16 & 65535 | 0, s = 0; 0 !== a;) {
                    a -= s = a > 2e3 ? 2e3 : a;
                    do {
                        r = r + (n = n + e[i++] | 0) | 0
                    } while (--s);
                    n %= 65521, r %= 65521
                }
                return n | r << 16 | 0
            }
        }, {}],
        6: [function (t, e, a) {
            "use strict";
            e.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            }
        }, {}],
        7: [function (t, e, a) {
            "use strict";
            var i = function () {
                for (var t, e = [], a = 0; a < 256; a++) {
                    t = a;
                    for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
                    e[a] = t
                }
                return e
            }();
            e.exports = function (t, e, a, n) {
                var r = i, s = n + a;
                t ^= -1;
                for (var o = n; o < s; o++) t = t >>> 8 ^ r[255 & (t ^ e[o])];
                return -1 ^ t
            }
        }, {}],
        8: [function (t, e, a) {
            "use strict";

            function i(t, e) {
                return t.msg = A[e], e
            }

            function n(t) {
                return (t << 1) - (t > 4 ? 9 : 0)
            }

            function r(t) {
                for (var e = t.length; --e >= 0;) t[e] = 0
            }

            function s(t) {
                var e = t.state, a = e.pending;
                a > t.avail_out && (a = t.avail_out), 0 !== a && (z.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, 0 === e.pending && (e.pending_out = 0))
            }

            function o(t, e) {
                B._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, s(t.strm)
            }

            function l(t, e) {
                t.pending_buf[t.pending++] = e
            }

            function h(t, e) {
                t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e
            }

            function d(t, e, a, i) {
                var n = t.avail_in;
                return n > i && (n = i), 0 === n ? 0 : (t.avail_in -= n, z.arraySet(e, t.input, t.next_in, n, a), 1 === t.state.wrap ? t.adler = S(t.adler, e, n, a) : 2 === t.state.wrap && (t.adler = E(t.adler, e, n, a)), t.next_in += n, t.total_in += n, n)
            }

            function f(t, e) {
                var a, i, n = t.max_chain_length, r = t.strstart, s = t.prev_length, o = t.nice_match,
                    l = t.strstart > t.w_size - it ? t.strstart - (t.w_size - it) : 0, h = t.window, d = t.w_mask,
                    f = t.prev, _ = t.strstart + at, u = h[r + s - 1], c = h[r + s];
                t.prev_length >= t.good_match && (n >>= 2), o > t.lookahead && (o = t.lookahead);
                do {
                    if (a = e, h[a + s] === c && h[a + s - 1] === u && h[a] === h[r] && h[++a] === h[r + 1]) {
                        r += 2, a++;
                        do {
                        } while (h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && r < _);
                        if (i = at - (_ - r), r = _ - at, i > s) {
                            if (t.match_start = e, s = i, i >= o) break;
                            u = h[r + s - 1], c = h[r + s]
                        }
                    }
                } while ((e = f[e & d]) > l && 0 != --n);
                return s <= t.lookahead ? s : t.lookahead
            }

            function _(t) {
                var e, a, i, n, r, s = t.w_size;
                do {
                    if (n = t.window_size - t.lookahead - t.strstart, t.strstart >= s + (s - it)) {
                        z.arraySet(t.window, t.window, s, s, 0), t.match_start -= s, t.strstart -= s, t.block_start -= s, e = a = t.hash_size;
                        do {
                            i = t.head[--e], t.head[e] = i >= s ? i - s : 0
                        } while (--a);
                        e = a = s;
                        do {
                            i = t.prev[--e], t.prev[e] = i >= s ? i - s : 0
                        } while (--a);
                        n += s
                    }
                    if (0 === t.strm.avail_in) break;
                    if (a = d(t.strm, t.window, t.strstart + t.lookahead, n), t.lookahead += a, t.lookahead + t.insert >= et) for (r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + et - 1]) & t.hash_mask, t.prev[r & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = r, r++, t.insert--, !(t.lookahead + t.insert < et));) ;
                } while (t.lookahead < it && 0 !== t.strm.avail_in)
            }

            function u(t, e) {
                for (var a, i; ;) {
                    if (t.lookahead < it) {
                        if (_(t), t.lookahead < it && e === Z) return _t;
                        if (0 === t.lookahead) break
                    }
                    if (a = 0, t.lookahead >= et && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== a && t.strstart - a <= t.w_size - it && (t.match_length = f(t, a)), t.match_length >= et) if (i = B._tr_tally(t, t.strstart - t.match_start, t.match_length - et), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= et) {
                        t.match_length--;
                        do {
                            t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart
                        } while (0 != --t.match_length);
                        t.strstart++
                    } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else i = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
                    if (i && (o(t, !1), 0 === t.strm.avail_out)) return _t
                }
                return t.insert = t.strstart < et - 1 ? t.strstart : et - 1, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
            }

            function c(t, e) {
                for (var a, i, n; ;) {
                    if (t.lookahead < it) {
                        if (_(t), t.lookahead < it && e === Z) return _t;
                        if (0 === t.lookahead) break
                    }
                    if (a = 0, t.lookahead >= et && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = et - 1, 0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - it && (t.match_length = f(t, a), t.match_length <= 5 && (t.strategy === H || t.match_length === et && t.strstart - t.match_start > 4096) && (t.match_length = et - 1)), t.prev_length >= et && t.match_length <= t.prev_length) {
                        n = t.strstart + t.lookahead - et, i = B._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - et), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
                        do {
                            ++t.strstart <= n && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart)
                        } while (0 != --t.prev_length);
                        if (t.match_available = 0, t.match_length = et - 1, t.strstart++, i && (o(t, !1), 0 === t.strm.avail_out)) return _t
                    } else if (t.match_available) {
                        if ((i = B._tr_tally(t, 0, t.window[t.strstart - 1])) && o(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return _t
                    } else t.match_available = 1, t.strstart++, t.lookahead--
                }
                return t.match_available && (i = B._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < et - 1 ? t.strstart : et - 1, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
            }

            function b(t, e) {
                for (var a, i, n, r, s = t.window; ;) {
                    if (t.lookahead <= at) {
                        if (_(t), t.lookahead <= at && e === Z) return _t;
                        if (0 === t.lookahead) break
                    }
                    if (t.match_length = 0, t.lookahead >= et && t.strstart > 0 && (n = t.strstart - 1, (i = s[n]) === s[++n] && i === s[++n] && i === s[++n])) {
                        r = t.strstart + at;
                        do {
                        } while (i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && n < r);
                        t.match_length = at - (r - n), t.match_length > t.lookahead && (t.match_length = t.lookahead)
                    }
                    if (t.match_length >= et ? (a = B._tr_tally(t, 1, t.match_length - et), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (o(t, !1), 0 === t.strm.avail_out)) return _t
                }
                return t.insert = 0, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
            }

            function g(t, e) {
                for (var a; ;) {
                    if (0 === t.lookahead && (_(t), 0 === t.lookahead)) {
                        if (e === Z) return _t;
                        break
                    }
                    if (t.match_length = 0, a = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (o(t, !1), 0 === t.strm.avail_out)) return _t
                }
                return t.insert = 0, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
            }

            function m(t, e, a, i, n) {
                this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = i, this.func = n
            }

            function w(t) {
                t.window_size = 2 * t.w_size, r(t.head), t.max_lazy_match = x[t.level].max_lazy, t.good_match = x[t.level].good_length, t.nice_match = x[t.level].nice_length, t.max_chain_length = x[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = et - 1, t.match_available = 0, t.ins_h = 0
            }

            function p() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = q, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new z.Buf16(2 * $), this.dyn_dtree = new z.Buf16(2 * (2 * Q + 1)), this.bl_tree = new z.Buf16(2 * (2 * V + 1)), r(this.dyn_ltree), r(this.dyn_dtree), r(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new z.Buf16(tt + 1), this.heap = new z.Buf16(2 * J + 1), r(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new z.Buf16(2 * J + 1), r(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
            }

            function v(t) {
                var e;
                return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = Y, e = t.state, e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? rt : dt, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = Z, B._tr_init(e), D) : i(t, U)
            }

            function k(t) {
                var e = v(t);
                return e === D && w(t.state), e
            }

            function y(t, e, a, n, r, s) {
                if (!t) return U;
                var o = 1;
                if (e === L && (e = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), r < 1 || r > G || a !== q || n < 8 || n > 15 || e < 0 || e > 9 || s < 0 || s > M) return i(t, U);
                8 === n && (n = 9);
                var l = new p;
                return t.state = l, l.strm = t, l.wrap = o, l.gzhead = null, l.w_bits = n, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = r + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + et - 1) / et), l.window = new z.Buf8(2 * l.w_size), l.head = new z.Buf16(l.hash_size), l.prev = new z.Buf16(l.w_size), l.lit_bufsize = 1 << r + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new z.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = e, l.strategy = s, l.method = a, k(t)
            }

            var x, z = t("../utils/common"), B = t("./trees"), S = t("./adler32"), E = t("./crc32"),
                A = t("./messages"), Z = 0, R = 1, C = 3, N = 4, O = 5, D = 0, I = 1, U = -2, T = -3, F = -5,
                L = -1, H = 1, j = 2, K = 3, M = 4, P = 0, Y = 2, q = 8, G = 9, X = 15, W = 8, J = 286, Q = 30,
                V = 19, $ = 2 * J + 1, tt = 15, et = 3, at = 258, it = at + et + 1, nt = 32, rt = 42, st = 69,
                ot = 73, lt = 91, ht = 103, dt = 113, ft = 666, _t = 1, ut = 2, ct = 3, bt = 4, gt = 3;
            x = [new m(0, 0, 0, 0, function (t, e) {
                var a = 65535;
                for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5); ;) {
                    if (t.lookahead <= 1) {
                        if (_(t), 0 === t.lookahead && e === Z) return _t;
                        if (0 === t.lookahead) break
                    }
                    t.strstart += t.lookahead, t.lookahead = 0;
                    var i = t.block_start + a;
                    if ((0 === t.strstart || t.strstart >= i) && (t.lookahead = t.strstart - i, t.strstart = i, o(t, !1), 0 === t.strm.avail_out)) return _t;
                    if (t.strstart - t.block_start >= t.w_size - it && (o(t, !1), 0 === t.strm.avail_out)) return _t
                }
                return t.insert = 0, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : (t.strstart > t.block_start && (o(t, !1), t.strm.avail_out), _t)
            }), new m(4, 4, 8, 4, u), new m(4, 5, 16, 8, u), new m(4, 6, 32, 32, u), new m(4, 4, 16, 16, c), new m(8, 16, 32, 32, c), new m(8, 16, 128, 128, c), new m(8, 32, 128, 256, c), new m(32, 128, 258, 1024, c), new m(32, 258, 258, 4096, c)], a.deflateInit = function (t, e) {
                return y(t, e, q, X, W, P)
            }, a.deflateInit2 = y, a.deflateReset = k, a.deflateResetKeep = v, a.deflateSetHeader = function (t, e) {
                return t && t.state ? 2 !== t.state.wrap ? U : (t.state.gzhead = e, D) : U
            }, a.deflate = function (t, e) {
                var a, o, d, f;
                if (!t || !t.state || e > O || e < 0) return t ? i(t, U) : U;
                if (o = t.state, !t.output || !t.input && 0 !== t.avail_in || o.status === ft && e !== N) return i(t, 0 === t.avail_out ? F : U);
                if (o.strm = t, a = o.last_flush, o.last_flush = e, o.status === rt) if (2 === o.wrap) t.adler = 0, l(o, 31), l(o, 139), l(o, 8), o.gzhead ? (l(o, (o.gzhead.text ? 1 : 0) + (o.gzhead.hcrc ? 2 : 0) + (o.gzhead.extra ? 4 : 0) + (o.gzhead.name ? 8 : 0) + (o.gzhead.comment ? 16 : 0)), l(o, 255 & o.gzhead.time), l(o, o.gzhead.time >> 8 & 255), l(o, o.gzhead.time >> 16 & 255), l(o, o.gzhead.time >> 24 & 255), l(o, 9 === o.level ? 2 : o.strategy >= j || o.level < 2 ? 4 : 0), l(o, 255 & o.gzhead.os), o.gzhead.extra && o.gzhead.extra.length && (l(o, 255 & o.gzhead.extra.length), l(o, o.gzhead.extra.length >> 8 & 255)), o.gzhead.hcrc && (t.adler = E(t.adler, o.pending_buf, o.pending, 0)), o.gzindex = 0, o.status = st) : (l(o, 0), l(o, 0), l(o, 0), l(o, 0), l(o, 0), l(o, 9 === o.level ? 2 : o.strategy >= j || o.level < 2 ? 4 : 0), l(o, gt), o.status = dt); else {
                    var _ = q + (o.w_bits - 8 << 4) << 8;
                    _ |= (o.strategy >= j || o.level < 2 ? 0 : o.level < 6 ? 1 : 6 === o.level ? 2 : 3) << 6, 0 !== o.strstart && (_ |= nt), _ += 31 - _ % 31, o.status = dt, h(o, _), 0 !== o.strstart && (h(o, t.adler >>> 16), h(o, 65535 & t.adler)), t.adler = 1
                }
                if (o.status === st) if (o.gzhead.extra) {
                    for (d = o.pending; o.gzindex < (65535 & o.gzhead.extra.length) && (o.pending !== o.pending_buf_size || (o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending !== o.pending_buf_size));) l(o, 255 & o.gzhead.extra[o.gzindex]), o.gzindex++;
                    o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), o.gzindex === o.gzhead.extra.length && (o.gzindex = 0, o.status = ot)
                } else o.status = ot;
                if (o.status === ot) if (o.gzhead.name) {
                    d = o.pending;
                    do {
                        if (o.pending === o.pending_buf_size && (o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending === o.pending_buf_size)) {
                            f = 1;
                            break
                        }
                        f = o.gzindex < o.gzhead.name.length ? 255 & o.gzhead.name.charCodeAt(o.gzindex++) : 0, l(o, f)
                    } while (0 !== f);
                    o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), 0 === f && (o.gzindex = 0, o.status = lt)
                } else o.status = lt;
                if (o.status === lt) if (o.gzhead.comment) {
                    d = o.pending;
                    do {
                        if (o.pending === o.pending_buf_size && (o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending === o.pending_buf_size)) {
                            f = 1;
                            break
                        }
                        f = o.gzindex < o.gzhead.comment.length ? 255 & o.gzhead.comment.charCodeAt(o.gzindex++) : 0, l(o, f)
                    } while (0 !== f);
                    o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), 0 === f && (o.status = ht)
                } else o.status = ht;
                if (o.status === ht && (o.gzhead.hcrc ? (o.pending + 2 > o.pending_buf_size && s(t), o.pending + 2 <= o.pending_buf_size && (l(o, 255 & t.adler), l(o, t.adler >> 8 & 255), t.adler = 0, o.status = dt)) : o.status = dt), 0 !== o.pending) {
                    if (s(t), 0 === t.avail_out) return o.last_flush = -1, D
                } else if (0 === t.avail_in && n(e) <= n(a) && e !== N) return i(t, F);
                if (o.status === ft && 0 !== t.avail_in) return i(t, F);
                if (0 !== t.avail_in || 0 !== o.lookahead || e !== Z && o.status !== ft) {
                    var u = o.strategy === j ? g(o, e) : o.strategy === K ? b(o, e) : x[o.level].func(o, e);
                    if (u !== ct && u !== bt || (o.status = ft), u === _t || u === ct) return 0 === t.avail_out && (o.last_flush = -1), D;
                    if (u === ut && (e === R ? B._tr_align(o) : e !== O && (B._tr_stored_block(o, 0, 0, !1), e === C && (r(o.head), 0 === o.lookahead && (o.strstart = 0, o.block_start = 0, o.insert = 0))), s(t), 0 === t.avail_out)) return o.last_flush = -1, D
                }
                return e !== N ? D : o.wrap <= 0 ? I : (2 === o.wrap ? (l(o, 255 & t.adler), l(o, t.adler >> 8 & 255), l(o, t.adler >> 16 & 255), l(o, t.adler >> 24 & 255), l(o, 255 & t.total_in), l(o, t.total_in >> 8 & 255), l(o, t.total_in >> 16 & 255), l(o, t.total_in >> 24 & 255)) : (h(o, t.adler >>> 16), h(o, 65535 & t.adler)), s(t), o.wrap > 0 && (o.wrap = -o.wrap), 0 !== o.pending ? D : I)
            }, a.deflateEnd = function (t) {
                var e;
                return t && t.state ? (e = t.state.status) !== rt && e !== st && e !== ot && e !== lt && e !== ht && e !== dt && e !== ft ? i(t, U) : (t.state = null, e === dt ? i(t, T) : D) : U
            }, a.deflateSetDictionary = function (t, e) {
                var a, i, n, s, o, l, h, d, f = e.length;
                if (!t || !t.state) return U;
                if (a = t.state, 2 === (s = a.wrap) || 1 === s && a.status !== rt || a.lookahead) return U;
                for (1 === s && (t.adler = S(t.adler, e, f, 0)), a.wrap = 0, f >= a.w_size && (0 === s && (r(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0), d = new z.Buf8(a.w_size), z.arraySet(d, e, f - a.w_size, a.w_size, 0), e = d, f = a.w_size), o = t.avail_in, l = t.next_in, h = t.input, t.avail_in = f, t.next_in = 0, t.input = e, _(a); a.lookahead >= et;) {
                    i = a.strstart, n = a.lookahead - (et - 1);
                    do {
                        a.ins_h = (a.ins_h << a.hash_shift ^ a.window[i + et - 1]) & a.hash_mask, a.prev[i & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = i, i++
                    } while (--n);
                    a.strstart = i, a.lookahead = et - 1, _(a)
                }
                return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = et - 1, a.match_available = 0, t.next_in = l, t.input = h, t.avail_in = o, a.wrap = s, D
            }, a.deflateInfo = "pako deflate (from Nodeca project)"
        }, {"../utils/common": 3, "./adler32": 5, "./crc32": 7, "./messages": 13, "./trees": 14}],
        9: [function (t, e, a) {
            "use strict";
            e.exports = function () {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
            }
        }, {}],
        10: [function (t, e, a) {
            "use strict";
            e.exports = function (t, e) {
                var a, i, n, r, s, o, l, h, d, f, _, u, c, b, g, m, w, p, v, k, y, x, z, B, S;
                a = t.state, i = t.next_in, B = t.input, n = i + (t.avail_in - 5), r = t.next_out, S = t.output, s = r - (e - t.avail_out), o = r + (t.avail_out - 257), l = a.dmax, h = a.wsize, d = a.whave, f = a.wnext, _ = a.window, u = a.hold, c = a.bits, b = a.lencode, g = a.distcode, m = (1 << a.lenbits) - 1, w = (1 << a.distbits) - 1;
                t:do {
                    c < 15 && (u += B[i++] << c, c += 8, u += B[i++] << c, c += 8), p = b[u & m];
                    e:for (; ;) {
                        if (v = p >>> 24, u >>>= v, c -= v, 0 === (v = p >>> 16 & 255)) S[r++] = 65535 & p; else {
                            if (!(16 & v)) {
                                if (0 == (64 & v)) {
                                    p = b[(65535 & p) + (u & (1 << v) - 1)];
                                    continue e
                                }
                                if (32 & v) {
                                    a.mode = 12;
                                    break t
                                }
                                t.msg = "invalid literal/length code", a.mode = 30;
                                break t
                            }
                            k = 65535 & p, (v &= 15) && (c < v && (u += B[i++] << c, c += 8), k += u & (1 << v) - 1, u >>>= v, c -= v), c < 15 && (u += B[i++] << c, c += 8, u += B[i++] << c, c += 8), p = g[u & w];
                            a:for (; ;) {
                                if (v = p >>> 24, u >>>= v, c -= v, !(16 & (v = p >>> 16 & 255))) {
                                    if (0 == (64 & v)) {
                                        p = g[(65535 & p) + (u & (1 << v) - 1)];
                                        continue a
                                    }
                                    t.msg = "invalid distance code", a.mode = 30;
                                    break t
                                }
                                if (y = 65535 & p, v &= 15, c < v && (u += B[i++] << c, (c += 8) < v && (u += B[i++] << c, c += 8)), (y += u & (1 << v) - 1) > l) {
                                    t.msg = "invalid distance too far back", a.mode = 30;
                                    break t
                                }
                                if (u >>>= v, c -= v, v = r - s, y > v) {
                                    if ((v = y - v) > d && a.sane) {
                                        t.msg = "invalid distance too far back", a.mode = 30;
                                        break t
                                    }
                                    if (x = 0, z = _, 0 === f) {
                                        if (x += h - v, v < k) {
                                            k -= v;
                                            do {
                                                S[r++] = _[x++]
                                            } while (--v);
                                            x = r - y, z = S
                                        }
                                    } else if (f < v) {
                                        if (x += h + f - v, (v -= f) < k) {
                                            k -= v;
                                            do {
                                                S[r++] = _[x++]
                                            } while (--v);
                                            if (x = 0, f < k) {
                                                k -= v = f;
                                                do {
                                                    S[r++] = _[x++]
                                                } while (--v);
                                                x = r - y, z = S
                                            }
                                        }
                                    } else if (x += f - v, v < k) {
                                        k -= v;
                                        do {
                                            S[r++] = _[x++]
                                        } while (--v);
                                        x = r - y, z = S
                                    }
                                    for (; k > 2;) S[r++] = z[x++], S[r++] = z[x++], S[r++] = z[x++], k -= 3;
                                    k && (S[r++] = z[x++], k > 1 && (S[r++] = z[x++]))
                                } else {
                                    x = r - y;
                                    do {
                                        S[r++] = S[x++], S[r++] = S[x++], S[r++] = S[x++], k -= 3
                                    } while (k > 2);
                                    k && (S[r++] = S[x++], k > 1 && (S[r++] = S[x++]))
                                }
                                break
                            }
                        }
                        break
                    }
                } while (i < n && r < o);
                i -= k = c >> 3, u &= (1 << (c -= k << 3)) - 1, t.next_in = i, t.next_out = r, t.avail_in = i < n ? n - i + 5 : 5 - (i - n), t.avail_out = r < o ? o - r + 257 : 257 - (r - o), a.hold = u, a.bits = c
            }
        }, {}],
        11: [function (t, e, a) {
            "use strict";

            function i(t) {
                return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
            }

            function n() {
                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new u.Buf16(320), this.work = new u.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
            }

            function r(t) {
                var e;
                return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = N, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new u.Buf32(dt), e.distcode = e.distdyn = new u.Buf32(ft), e.sane = 1, e.back = -1, z) : E
            }

            function s(t) {
                var e;
                return t && t.state ? (e = t.state, e.wsize = 0, e.whave = 0, e.wnext = 0, r(t)) : E
            }

            function o(t, e) {
                var a, i;
                return t && t.state ? (i = t.state, e < 0 ? (a = 0, e = -e) : (a = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? E : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = a, i.wbits = e, s(t))) : E
            }

            function l(t, e) {
                var a, i;
                return t ? (i = new n, t.state = i, i.window = null, (a = o(t, e)) !== z && (t.state = null), a) : E
            }

            function h(t) {
                if (ut) {
                    var e;
                    for (f = new u.Buf32(512), _ = new u.Buf32(32), e = 0; e < 144;) t.lens[e++] = 8;
                    for (; e < 256;) t.lens[e++] = 9;
                    for (; e < 280;) t.lens[e++] = 7;
                    for (; e < 288;) t.lens[e++] = 8;
                    for (m(p, t.lens, 0, 288, f, 0, t.work, {bits: 9}), e = 0; e < 32;) t.lens[e++] = 5;
                    m(v, t.lens, 0, 32, _, 0, t.work, {bits: 5}), ut = !1
                }
                t.lencode = f, t.lenbits = 9, t.distcode = _, t.distbits = 5
            }

            function d(t, e, a, i) {
                var n, r = t.state;
                return null === r.window && (r.wsize = 1 << r.wbits, r.wnext = 0, r.whave = 0, r.window = new u.Buf8(r.wsize)), i >= r.wsize ? (u.arraySet(r.window, e, a - r.wsize, r.wsize, 0), r.wnext = 0, r.whave = r.wsize) : ((n = r.wsize - r.wnext) > i && (n = i), u.arraySet(r.window, e, a - i, n, r.wnext), (i -= n) ? (u.arraySet(r.window, e, a - i, i, 0), r.wnext = i, r.whave = r.wsize) : (r.wnext += n, r.wnext === r.wsize && (r.wnext = 0), r.whave < r.wsize && (r.whave += n))), 0
            }

            var f, _, u = t("../utils/common"), c = t("./adler32"), b = t("./crc32"), g = t("./inffast"),
                m = t("./inftrees"), w = 0, p = 1, v = 2, k = 4, y = 5, x = 6, z = 0, B = 1, S = 2, E = -2, A = -3,
                Z = -4, R = -5, C = 8, N = 1, O = 2, D = 3, I = 4, U = 5, T = 6, F = 7, L = 8, H = 9, j = 10,
                K = 11, M = 12, P = 13, Y = 14, q = 15, G = 16, X = 17, W = 18, J = 19, Q = 20, V = 21, $ = 22,
                tt = 23, et = 24, at = 25, it = 26, nt = 27, rt = 28, st = 29, ot = 30, lt = 31, ht = 32, dt = 852,
                ft = 592, _t = 15, ut = !0;
            a.inflateReset = s, a.inflateReset2 = o, a.inflateResetKeep = r, a.inflateInit = function (t) {
                return l(t, _t)
            }, a.inflateInit2 = l, a.inflate = function (t, e) {
                var a, n, r, s, o, l, f, _, dt, ft, _t, ut, ct, bt, gt, mt, wt, pt, vt, kt, yt, xt, zt, Bt, St = 0,
                    Et = new u.Buf8(4), At = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return E;
                (a = t.state).mode === M && (a.mode = P), o = t.next_out, r = t.output, f = t.avail_out, s = t.next_in, n = t.input, l = t.avail_in, _ = a.hold, dt = a.bits, ft = l, _t = f, xt = z;
                t:for (; ;) switch (a.mode) {
                    case N:
                        if (0 === a.wrap) {
                            a.mode = P;
                            break
                        }
                        for (; dt < 16;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        if (2 & a.wrap && 35615 === _) {
                            a.check = 0, Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0), _ = 0, dt = 0, a.mode = O;
                            break
                        }
                        if (a.flags = 0, a.head && (a.head.done = !1), !(1 & a.wrap) || (((255 & _) << 8) + (_ >> 8)) % 31) {
                            t.msg = "incorrect header check", a.mode = ot;
                            break
                        }
                        if ((15 & _) !== C) {
                            t.msg = "unknown compression method", a.mode = ot;
                            break
                        }
                        if (_ >>>= 4, dt -= 4, yt = 8 + (15 & _), 0 === a.wbits) a.wbits = yt; else if (yt > a.wbits) {
                            t.msg = "invalid window size", a.mode = ot;
                            break
                        }
                        a.dmax = 1 << yt, t.adler = a.check = 1, a.mode = 512 & _ ? j : M, _ = 0, dt = 0;
                        break;
                    case O:
                        for (; dt < 16;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        if (a.flags = _, (255 & a.flags) !== C) {
                            t.msg = "unknown compression method", a.mode = ot;
                            break
                        }
                        if (57344 & a.flags) {
                            t.msg = "unknown header flags set", a.mode = ot;
                            break
                        }
                        a.head && (a.head.text = _ >> 8 & 1), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0)), _ = 0, dt = 0, a.mode = D;
                    case D:
                        for (; dt < 32;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        a.head && (a.head.time = _), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, Et[2] = _ >>> 16 & 255, Et[3] = _ >>> 24 & 255, a.check = b(a.check, Et, 4, 0)), _ = 0, dt = 0, a.mode = I;
                    case I:
                        for (; dt < 16;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        a.head && (a.head.xflags = 255 & _, a.head.os = _ >> 8), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0)), _ = 0, dt = 0, a.mode = U;
                    case U:
                        if (1024 & a.flags) {
                            for (; dt < 16;) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            a.length = _, a.head && (a.head.extra_len = _), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0)), _ = 0, dt = 0
                        } else a.head && (a.head.extra = null);
                        a.mode = T;
                    case T:
                        if (1024 & a.flags && ((ut = a.length) > l && (ut = l), ut && (a.head && (yt = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Array(a.head.extra_len)), u.arraySet(a.head.extra, n, s, ut, yt)), 512 & a.flags && (a.check = b(a.check, n, ut, s)), l -= ut, s += ut, a.length -= ut), a.length)) break t;
                        a.length = 0, a.mode = F;
                    case F:
                        if (2048 & a.flags) {
                            if (0 === l) break t;
                            ut = 0;
                            do {
                                yt = n[s + ut++], a.head && yt && a.length < 65536 && (a.head.name += String.fromCharCode(yt))
                            } while (yt && ut < l);
                            if (512 & a.flags && (a.check = b(a.check, n, ut, s)), l -= ut, s += ut, yt) break t
                        } else a.head && (a.head.name = null);
                        a.length = 0, a.mode = L;
                    case L:
                        if (4096 & a.flags) {
                            if (0 === l) break t;
                            ut = 0;
                            do {
                                yt = n[s + ut++], a.head && yt && a.length < 65536 && (a.head.comment += String.fromCharCode(yt))
                            } while (yt && ut < l);
                            if (512 & a.flags && (a.check = b(a.check, n, ut, s)), l -= ut, s += ut, yt) break t
                        } else a.head && (a.head.comment = null);
                        a.mode = H;
                    case H:
                        if (512 & a.flags) {
                            for (; dt < 16;) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            if (_ !== (65535 & a.check)) {
                                t.msg = "header crc mismatch", a.mode = ot;
                                break
                            }
                            _ = 0, dt = 0
                        }
                        a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), t.adler = a.check = 0, a.mode = M;
                        break;
                    case j:
                        for (; dt < 32;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        t.adler = a.check = i(_), _ = 0, dt = 0, a.mode = K;
                    case K:
                        if (0 === a.havedict) return t.next_out = o, t.avail_out = f, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = dt, S;
                        t.adler = a.check = 1, a.mode = M;
                    case M:
                        if (e === y || e === x) break t;
                    case P:
                        if (a.last) {
                            _ >>>= 7 & dt, dt -= 7 & dt, a.mode = nt;
                            break
                        }
                        for (; dt < 3;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        switch (a.last = 1 & _, _ >>>= 1, dt -= 1, 3 & _) {
                            case 0:
                                a.mode = Y;
                                break;
                            case 1:
                                if (h(a), a.mode = Q, e === x) {
                                    _ >>>= 2, dt -= 2;
                                    break t
                                }
                                break;
                            case 2:
                                a.mode = X;
                                break;
                            case 3:
                                t.msg = "invalid block type", a.mode = ot
                        }
                        _ >>>= 2, dt -= 2;
                        break;
                    case Y:
                        for (_ >>>= 7 & dt, dt -= 7 & dt; dt < 32;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        if ((65535 & _) != (_ >>> 16 ^ 65535)) {
                            t.msg = "invalid stored block lengths", a.mode = ot;
                            break
                        }
                        if (a.length = 65535 & _, _ = 0, dt = 0, a.mode = q, e === x) break t;
                    case q:
                        a.mode = G;
                    case G:
                        if (ut = a.length) {
                            if (ut > l && (ut = l), ut > f && (ut = f), 0 === ut) break t;
                            u.arraySet(r, n, s, ut, o), l -= ut, s += ut, f -= ut, o += ut, a.length -= ut;
                            break
                        }
                        a.mode = M;
                        break;
                    case X:
                        for (; dt < 14;) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        if (a.nlen = 257 + (31 & _), _ >>>= 5, dt -= 5, a.ndist = 1 + (31 & _), _ >>>= 5, dt -= 5, a.ncode = 4 + (15 & _), _ >>>= 4, dt -= 4, a.nlen > 286 || a.ndist > 30) {
                            t.msg = "too many length or distance symbols", a.mode = ot;
                            break
                        }
                        a.have = 0, a.mode = W;
                    case W:
                        for (; a.have < a.ncode;) {
                            for (; dt < 3;) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            a.lens[At[a.have++]] = 7 & _, _ >>>= 3, dt -= 3
                        }
                        for (; a.have < 19;) a.lens[At[a.have++]] = 0;
                        if (a.lencode = a.lendyn, a.lenbits = 7, zt = {bits: a.lenbits}, xt = m(w, a.lens, 0, 19, a.lencode, 0, a.work, zt), a.lenbits = zt.bits, xt) {
                            t.msg = "invalid code lengths set", a.mode = ot;
                            break
                        }
                        a.have = 0, a.mode = J;
                    case J:
                        for (; a.have < a.nlen + a.ndist;) {
                            for (; St = a.lencode[_ & (1 << a.lenbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= dt);) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            if (wt < 16) _ >>>= gt, dt -= gt, a.lens[a.have++] = wt; else {
                                if (16 === wt) {
                                    for (Bt = gt + 2; dt < Bt;) {
                                        if (0 === l) break t;
                                        l--, _ += n[s++] << dt, dt += 8
                                    }
                                    if (_ >>>= gt, dt -= gt, 0 === a.have) {
                                        t.msg = "invalid bit length repeat", a.mode = ot;
                                        break
                                    }
                                    yt = a.lens[a.have - 1], ut = 3 + (3 & _), _ >>>= 2, dt -= 2
                                } else if (17 === wt) {
                                    for (Bt = gt + 3; dt < Bt;) {
                                        if (0 === l) break t;
                                        l--, _ += n[s++] << dt, dt += 8
                                    }
                                    dt -= gt, yt = 0, ut = 3 + (7 & (_ >>>= gt)), _ >>>= 3, dt -= 3
                                } else {
                                    for (Bt = gt + 7; dt < Bt;) {
                                        if (0 === l) break t;
                                        l--, _ += n[s++] << dt, dt += 8
                                    }
                                    dt -= gt, yt = 0, ut = 11 + (127 & (_ >>>= gt)), _ >>>= 7, dt -= 7
                                }
                                if (a.have + ut > a.nlen + a.ndist) {
                                    t.msg = "invalid bit length repeat", a.mode = ot;
                                    break
                                }
                                for (; ut--;) a.lens[a.have++] = yt
                            }
                        }
                        if (a.mode === ot) break;
                        if (0 === a.lens[256]) {
                            t.msg = "invalid code -- missing end-of-block", a.mode = ot;
                            break
                        }
                        if (a.lenbits = 9, zt = {bits: a.lenbits}, xt = m(p, a.lens, 0, a.nlen, a.lencode, 0, a.work, zt), a.lenbits = zt.bits, xt) {
                            t.msg = "invalid literal/lengths set", a.mode = ot;
                            break
                        }
                        if (a.distbits = 6, a.distcode = a.distdyn, zt = {bits: a.distbits}, xt = m(v, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, zt), a.distbits = zt.bits, xt) {
                            t.msg = "invalid distances set", a.mode = ot;
                            break
                        }
                        if (a.mode = Q, e === x) break t;
                    case Q:
                        a.mode = V;
                    case V:
                        if (l >= 6 && f >= 258) {
                            t.next_out = o, t.avail_out = f, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = dt, g(t, _t), o = t.next_out, r = t.output, f = t.avail_out, s = t.next_in, n = t.input, l = t.avail_in, _ = a.hold, dt = a.bits, a.mode === M && (a.back = -1);
                            break
                        }
                        for (a.back = 0; St = a.lencode[_ & (1 << a.lenbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= dt);) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        if (mt && 0 == (240 & mt)) {
                            for (pt = gt, vt = mt, kt = wt; St = a.lencode[kt + ((_ & (1 << pt + vt) - 1) >> pt)], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(pt + gt <= dt);) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            _ >>>= pt, dt -= pt, a.back += pt
                        }
                        if (_ >>>= gt, dt -= gt, a.back += gt, a.length = wt, 0 === mt) {
                            a.mode = it;
                            break
                        }
                        if (32 & mt) {
                            a.back = -1, a.mode = M;
                            break
                        }
                        if (64 & mt) {
                            t.msg = "invalid literal/length code", a.mode = ot;
                            break
                        }
                        a.extra = 15 & mt, a.mode = $;
                    case $:
                        if (a.extra) {
                            for (Bt = a.extra; dt < Bt;) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            a.length += _ & (1 << a.extra) - 1, _ >>>= a.extra, dt -= a.extra, a.back += a.extra
                        }
                        a.was = a.length, a.mode = tt;
                    case tt:
                        for (; St = a.distcode[_ & (1 << a.distbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= dt);) {
                            if (0 === l) break t;
                            l--, _ += n[s++] << dt, dt += 8
                        }
                        if (0 == (240 & mt)) {
                            for (pt = gt, vt = mt, kt = wt; St = a.distcode[kt + ((_ & (1 << pt + vt) - 1) >> pt)], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(pt + gt <= dt);) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            _ >>>= pt, dt -= pt, a.back += pt
                        }
                        if (_ >>>= gt, dt -= gt, a.back += gt, 64 & mt) {
                            t.msg = "invalid distance code", a.mode = ot;
                            break
                        }
                        a.offset = wt, a.extra = 15 & mt, a.mode = et;
                    case et:
                        if (a.extra) {
                            for (Bt = a.extra; dt < Bt;) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            a.offset += _ & (1 << a.extra) - 1, _ >>>= a.extra, dt -= a.extra, a.back += a.extra
                        }
                        if (a.offset > a.dmax) {
                            t.msg = "invalid distance too far back", a.mode = ot;
                            break
                        }
                        a.mode = at;
                    case at:
                        if (0 === f) break t;
                        if (ut = _t - f, a.offset > ut) {
                            if ((ut = a.offset - ut) > a.whave && a.sane) {
                                t.msg = "invalid distance too far back", a.mode = ot;
                                break
                            }
                            ut > a.wnext ? (ut -= a.wnext, ct = a.wsize - ut) : ct = a.wnext - ut, ut > a.length && (ut = a.length), bt = a.window
                        } else bt = r, ct = o - a.offset, ut = a.length;
                        ut > f && (ut = f), f -= ut, a.length -= ut;
                        do {
                            r[o++] = bt[ct++]
                        } while (--ut);
                        0 === a.length && (a.mode = V);
                        break;
                    case it:
                        if (0 === f) break t;
                        r[o++] = a.length, f--, a.mode = V;
                        break;
                    case nt:
                        if (a.wrap) {
                            for (; dt < 32;) {
                                if (0 === l) break t;
                                l--, _ |= n[s++] << dt, dt += 8
                            }
                            if (_t -= f, t.total_out += _t, a.total += _t, _t && (t.adler = a.check = a.flags ? b(a.check, r, _t, o - _t) : c(a.check, r, _t, o - _t)), _t = f, (a.flags ? _ : i(_)) !== a.check) {
                                t.msg = "incorrect data check", a.mode = ot;
                                break
                            }
                            _ = 0, dt = 0
                        }
                        a.mode = rt;
                    case rt:
                        if (a.wrap && a.flags) {
                            for (; dt < 32;) {
                                if (0 === l) break t;
                                l--, _ += n[s++] << dt, dt += 8
                            }
                            if (_ !== (4294967295 & a.total)) {
                                t.msg = "incorrect length check", a.mode = ot;
                                break
                            }
                            _ = 0, dt = 0
                        }
                        a.mode = st;
                    case st:
                        xt = B;
                        break t;
                    case ot:
                        xt = A;
                        break t;
                    case lt:
                        return Z;
                    case ht:
                    default:
                        return E
                }
                return t.next_out = o, t.avail_out = f, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = dt, (a.wsize || _t !== t.avail_out && a.mode < ot && (a.mode < nt || e !== k)) && d(t, t.output, t.next_out, _t - t.avail_out) ? (a.mode = lt, Z) : (ft -= t.avail_in, _t -= t.avail_out, t.total_in += ft, t.total_out += _t, a.total += _t, a.wrap && _t && (t.adler = a.check = a.flags ? b(a.check, r, _t, t.next_out - _t) : c(a.check, r, _t, t.next_out - _t)), t.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === M ? 128 : 0) + (a.mode === Q || a.mode === q ? 256 : 0), (0 === ft && 0 === _t || e === k) && xt === z && (xt = R), xt)
            }, a.inflateEnd = function (t) {
                if (!t || !t.state) return E;
                var e = t.state;
                return e.window && (e.window = null), t.state = null, z
            }, a.inflateGetHeader = function (t, e) {
                var a;
                return t && t.state ? 0 == (2 & (a = t.state).wrap) ? E : (a.head = e, e.done = !1, z) : E
            }, a.inflateSetDictionary = function (t, e) {
                var a, i, n = e.length;
                return t && t.state ? 0 !== (a = t.state).wrap && a.mode !== K ? E : a.mode === K && (i = 1, (i = c(i, e, n, 0)) !== a.check) ? A : d(t, e, n, n) ? (a.mode = lt, Z) : (a.havedict = 1, z) : E
            }, a.inflateInfo = "pako inflate (from Nodeca project)"
        }, {"../utils/common": 3, "./adler32": 5, "./crc32": 7, "./inffast": 10, "./inftrees": 12}],
        12: [function (t, e, a) {
            "use strict";
            var i = t("../utils/common"),
                n = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
                r = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
                s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
                o = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            e.exports = function (t, e, a, l, h, d, f, _) {
                var u, c, b, g, m, w, p, v, k, y = _.bits, x = 0, z = 0, B = 0, S = 0, E = 0, A = 0, Z = 0, R = 0,
                    C = 0, N = 0, O = null, D = 0, I = new i.Buf16(16), U = new i.Buf16(16), T = null, F = 0;
                for (x = 0; x <= 15; x++) I[x] = 0;
                for (z = 0; z < l; z++) I[e[a + z]]++;
                for (E = y, S = 15; S >= 1 && 0 === I[S]; S--) ;
                if (E > S && (E = S), 0 === S) return h[d++] = 20971520, h[d++] = 20971520, _.bits = 1, 0;
                for (B = 1; B < S && 0 === I[B]; B++) ;
                for (E < B && (E = B), R = 1, x = 1; x <= 15; x++) if (R <<= 1, (R -= I[x]) < 0) return -1;
                if (R > 0 && (0 === t || 1 !== S)) return -1;
                for (U[1] = 0, x = 1; x < 15; x++) U[x + 1] = U[x] + I[x];
                for (z = 0; z < l; z++) 0 !== e[a + z] && (f[U[e[a + z]]++] = z);
                if (0 === t ? (O = T = f, w = 19) : 1 === t ? (O = n, D -= 257, T = r, F -= 257, w = 256) : (O = s, T = o, w = -1), N = 0, z = 0, x = B, m = d, A = E, Z = 0, b = -1, C = 1 << E, g = C - 1, 1 === t && C > 852 || 2 === t && C > 592) return 1;
                for (; ;) {
                    p = x - Z, f[z] < w ? (v = 0, k = f[z]) : f[z] > w ? (v = T[F + f[z]], k = O[D + f[z]]) : (v = 96, k = 0), u = 1 << x - Z, B = c = 1 << A;
                    do {
                        h[m + (N >> Z) + (c -= u)] = p << 24 | v << 16 | k | 0
                    } while (0 !== c);
                    for (u = 1 << x - 1; N & u;) u >>= 1;
                    if (0 !== u ? (N &= u - 1, N += u) : N = 0, z++, 0 == --I[x]) {
                        if (x === S) break;
                        x = e[a + f[z]]
                    }
                    if (x > E && (N & g) !== b) {
                        for (0 === Z && (Z = E), m += B, R = 1 << (A = x - Z); A + Z < S && !((R -= I[A + Z]) <= 0);) A++, R <<= 1;
                        if (C += 1 << A, 1 === t && C > 852 || 2 === t && C > 592) return 1;
                        h[b = N & g] = E << 24 | A << 16 | m - d | 0
                    }
                }
                return 0 !== N && (h[m + N] = x - Z << 24 | 64 << 16 | 0), _.bits = E, 0
            }
        }, {"../utils/common": 3}],
        13: [function (t, e, a) {
            "use strict";
            e.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            }
        }, {}],
        14: [function (t, e, a) {
            "use strict";

            function i(t) {
                for (var e = t.length; --e >= 0;) t[e] = 0
            }

            function n(t, e, a, i, n) {
                this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = i, this.max_length = n, this.has_stree = t && t.length
            }

            function r(t, e) {
                this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
            }

            function s(t) {
                return t < 256 ? et[t] : et[256 + (t >>> 7)]
            }

            function o(t, e) {
                t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255
            }

            function l(t, e, a) {
                t.bi_valid > M - a ? (t.bi_buf |= e << t.bi_valid & 65535, o(t, t.bi_buf), t.bi_buf = e >> M - t.bi_valid, t.bi_valid += a - M) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a)
            }

            function h(t, e, a) {
                l(t, a[2 * e], a[2 * e + 1])
            }

            function d(t, e) {
                var a = 0;
                do {
                    a |= 1 & t, t >>>= 1, a <<= 1
                } while (--e > 0);
                return a >>> 1
            }

            function f(t) {
                16 === t.bi_valid ? (o(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8)
            }

            function _(t, e) {
                var a, i, n, r, s, o, l = e.dyn_tree, h = e.max_code, d = e.stat_desc.static_tree,
                    f = e.stat_desc.has_stree, _ = e.stat_desc.extra_bits, u = e.stat_desc.extra_base,
                    c = e.stat_desc.max_length, b = 0;
                for (r = 0; r <= K; r++) t.bl_count[r] = 0;
                for (l[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < j; a++) (r = l[2 * l[2 * (i = t.heap[a]) + 1] + 1] + 1) > c && (r = c, b++), l[2 * i + 1] = r, i > h || (t.bl_count[r]++, s = 0, i >= u && (s = _[i - u]), o = l[2 * i], t.opt_len += o * (r + s), f && (t.static_len += o * (d[2 * i + 1] + s)));
                if (0 !== b) {
                    do {
                        for (r = c - 1; 0 === t.bl_count[r];) r--;
                        t.bl_count[r]--, t.bl_count[r + 1] += 2, t.bl_count[c]--, b -= 2
                    } while (b > 0);
                    for (r = c; 0 !== r; r--) for (i = t.bl_count[r]; 0 !== i;) (n = t.heap[--a]) > h || (l[2 * n + 1] !== r && (t.opt_len += (r - l[2 * n + 1]) * l[2 * n], l[2 * n + 1] = r), i--)
                }
            }

            function u(t, e, a) {
                var i, n, r = new Array(K + 1), s = 0;
                for (i = 1; i <= K; i++) r[i] = s = s + a[i - 1] << 1;
                for (n = 0; n <= e; n++) {
                    var o = t[2 * n + 1];
                    0 !== o && (t[2 * n] = d(r[o]++, o))
                }
            }

            function c() {
                var t, e, a, i, r, s = new Array(K + 1);
                for (a = 0, i = 0; i < U - 1; i++) for (it[i] = a, t = 0; t < 1 << W[i]; t++) at[a++] = i;
                for (at[a - 1] = i, r = 0, i = 0; i < 16; i++) for (nt[i] = r, t = 0; t < 1 << J[i]; t++) et[r++] = i;
                for (r >>= 7; i < L; i++) for (nt[i] = r << 7, t = 0; t < 1 << J[i] - 7; t++) et[256 + r++] = i;
                for (e = 0; e <= K; e++) s[e] = 0;
                for (t = 0; t <= 143;) $[2 * t + 1] = 8, t++, s[8]++;
                for (; t <= 255;) $[2 * t + 1] = 9, t++, s[9]++;
                for (; t <= 279;) $[2 * t + 1] = 7, t++, s[7]++;
                for (; t <= 287;) $[2 * t + 1] = 8, t++, s[8]++;
                for (u($, F + 1, s), t = 0; t < L; t++) tt[2 * t + 1] = 5, tt[2 * t] = d(t, 5);
                rt = new n($, W, T + 1, F, K), st = new n(tt, J, 0, L, K), ot = new n(new Array(0), Q, 0, H, P)
            }

            function b(t) {
                var e;
                for (e = 0; e < F; e++) t.dyn_ltree[2 * e] = 0;
                for (e = 0; e < L; e++) t.dyn_dtree[2 * e] = 0;
                for (e = 0; e < H; e++) t.bl_tree[2 * e] = 0;
                t.dyn_ltree[2 * Y] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0
            }

            function g(t) {
                t.bi_valid > 8 ? o(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
            }

            function m(t, e, a, i) {
                g(t), i && (o(t, a), o(t, ~a)), A.arraySet(t.pending_buf, t.window, e, a, t.pending), t.pending += a
            }

            function w(t, e, a, i) {
                var n = 2 * e, r = 2 * a;
                return t[n] < t[r] || t[n] === t[r] && i[e] <= i[a]
            }

            function p(t, e, a) {
                for (var i = t.heap[a], n = a << 1; n <= t.heap_len && (n < t.heap_len && w(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !w(e, i, t.heap[n], t.depth));) t.heap[a] = t.heap[n], a = n, n <<= 1;
                t.heap[a] = i
            }

            function v(t, e, a) {
                var i, n, r, o, d = 0;
                if (0 !== t.last_lit) do {
                    i = t.pending_buf[t.d_buf + 2 * d] << 8 | t.pending_buf[t.d_buf + 2 * d + 1], n = t.pending_buf[t.l_buf + d], d++, 0 === i ? h(t, n, e) : (h(t, (r = at[n]) + T + 1, e), 0 !== (o = W[r]) && l(t, n -= it[r], o), h(t, r = s(--i), a), 0 !== (o = J[r]) && l(t, i -= nt[r], o))
                } while (d < t.last_lit);
                h(t, Y, e)
            }

            function k(t, e) {
                var a, i, n, r = e.dyn_tree, s = e.stat_desc.static_tree, o = e.stat_desc.has_stree,
                    l = e.stat_desc.elems, h = -1;
                for (t.heap_len = 0, t.heap_max = j, a = 0; a < l; a++) 0 !== r[2 * a] ? (t.heap[++t.heap_len] = h = a, t.depth[a] = 0) : r[2 * a + 1] = 0;
                for (; t.heap_len < 2;) r[2 * (n = t.heap[++t.heap_len] = h < 2 ? ++h : 0)] = 1, t.depth[n] = 0, t.opt_len--, o && (t.static_len -= s[2 * n + 1]);
                for (e.max_code = h, a = t.heap_len >> 1; a >= 1; a--) p(t, r, a);
                n = l;
                do {
                    a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], p(t, r, 1), i = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = i, r[2 * n] = r[2 * a] + r[2 * i], t.depth[n] = (t.depth[a] >= t.depth[i] ? t.depth[a] : t.depth[i]) + 1, r[2 * a + 1] = r[2 * i + 1] = n, t.heap[1] = n++, p(t, r, 1)
                } while (t.heap_len >= 2);
                t.heap[--t.heap_max] = t.heap[1], _(t, e), u(r, h, t.bl_count)
            }

            function y(t, e, a) {
                var i, n, r = -1, s = e[1], o = 0, l = 7, h = 4;
                for (0 === s && (l = 138, h = 3), e[2 * (a + 1) + 1] = 65535, i = 0; i <= a; i++) n = s, s = e[2 * (i + 1) + 1], ++o < l && n === s || (o < h ? t.bl_tree[2 * n] += o : 0 !== n ? (n !== r && t.bl_tree[2 * n]++, t.bl_tree[2 * q]++) : o <= 10 ? t.bl_tree[2 * G]++ : t.bl_tree[2 * X]++, o = 0, r = n, 0 === s ? (l = 138, h = 3) : n === s ? (l = 6, h = 3) : (l = 7, h = 4))
            }

            function x(t, e, a) {
                var i, n, r = -1, s = e[1], o = 0, d = 7, f = 4;
                for (0 === s && (d = 138, f = 3), i = 0; i <= a; i++) if (n = s, s = e[2 * (i + 1) + 1], !(++o < d && n === s)) {
                    if (o < f) do {
                        h(t, n, t.bl_tree)
                    } while (0 != --o); else 0 !== n ? (n !== r && (h(t, n, t.bl_tree), o--), h(t, q, t.bl_tree), l(t, o - 3, 2)) : o <= 10 ? (h(t, G, t.bl_tree), l(t, o - 3, 3)) : (h(t, X, t.bl_tree), l(t, o - 11, 7));
                    o = 0, r = n, 0 === s ? (d = 138, f = 3) : n === s ? (d = 6, f = 3) : (d = 7, f = 4)
                }
            }

            function z(t) {
                var e;
                for (y(t, t.dyn_ltree, t.l_desc.max_code), y(t, t.dyn_dtree, t.d_desc.max_code), k(t, t.bl_desc), e = H - 1; e >= 3 && 0 === t.bl_tree[2 * V[e] + 1]; e--) ;
                return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
            }

            function B(t, e, a, i) {
                var n;
                for (l(t, e - 257, 5), l(t, a - 1, 5), l(t, i - 4, 4), n = 0; n < i; n++) l(t, t.bl_tree[2 * V[n] + 1], 3);
                x(t, t.dyn_ltree, e - 1), x(t, t.dyn_dtree, a - 1)
            }

            function S(t) {
                var e, a = 4093624447;
                for (e = 0; e <= 31; e++, a >>>= 1) if (1 & a && 0 !== t.dyn_ltree[2 * e]) return R;
                if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return C;
                for (e = 32; e < T; e++) if (0 !== t.dyn_ltree[2 * e]) return C;
                return R
            }

            function E(t, e, a, i) {
                l(t, (O << 1) + (i ? 1 : 0), 3), m(t, e, a, !0)
            }

            var A = t("../utils/common"), Z = 4, R = 0, C = 1, N = 2, O = 0, D = 1, I = 2, U = 29, T = 256,
                F = T + 1 + U, L = 30, H = 19, j = 2 * F + 1, K = 15, M = 16, P = 7, Y = 256, q = 16, G = 17,
                X = 18, W = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
                J = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                Q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                V = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], $ = new Array(2 * (F + 2));
            i($);
            var tt = new Array(2 * L);
            i(tt);
            var et = new Array(512);
            i(et);
            var at = new Array(256);
            i(at);
            var it = new Array(U);
            i(it);
            var nt = new Array(L);
            i(nt);
            var rt, st, ot, lt = !1;
            a._tr_init = function (t) {
                lt || (c(), lt = !0), t.l_desc = new r(t.dyn_ltree, rt), t.d_desc = new r(t.dyn_dtree, st), t.bl_desc = new r(t.bl_tree, ot), t.bi_buf = 0, t.bi_valid = 0, b(t)
            }, a._tr_stored_block = E, a._tr_flush_block = function (t, e, a, i) {
                var n, r, s = 0;
                t.level > 0 ? (t.strm.data_type === N && (t.strm.data_type = S(t)), k(t, t.l_desc), k(t, t.d_desc), s = z(t), n = t.opt_len + 3 + 7 >>> 3, (r = t.static_len + 3 + 7 >>> 3) <= n && (n = r)) : n = r = a + 5, a + 4 <= n && -1 !== e ? E(t, e, a, i) : t.strategy === Z || r === n ? (l(t, (D << 1) + (i ? 1 : 0), 3), v(t, $, tt)) : (l(t, (I << 1) + (i ? 1 : 0), 3), B(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), v(t, t.dyn_ltree, t.dyn_dtree)), b(t), i && g(t)
            }, a._tr_tally = function (t, e, a) {
                return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & a, t.last_lit++, 0 === e ? t.dyn_ltree[2 * a]++ : (t.matches++, e--, t.dyn_ltree[2 * (at[a] + T + 1)]++, t.dyn_dtree[2 * s(e)]++), t.last_lit === t.lit_bufsize - 1
            }, a._tr_align = function (t) {
                l(t, D << 1, 3), h(t, Y, $), f(t)
            }
        }, {"../utils/common": 3}],
        15: [function (t, e, a) {
            "use strict";
            e.exports = function () {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
            }
        }, {}],
        "/": [function (t, e, a) {
            "use strict";
            var i = {};
            (0, t("./lib/utils/common").assign)(i, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = i
        }, {"./lib/deflate": 1, "./lib/inflate": 2, "./lib/utils/common": 3, "./lib/zlib/constants": 6}]
    }, {}, [])("/")
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    const GZIP_MEMBER_HEADER_ID_SIZE = 3;
    const GZIP_HEADER_ID1 = 0x1f;
    const GZIP_HEADER_ID2 = 0x8b;
    const GZIP_DEFLATE_COMPRESSION = 8;

    function _stringToUInt8Array(str) {
        const array = new Uint8Array(str.length);
        for (let i = 0; i < str.length; ++i) {
            array[i] = str.charCodeAt(i);
        }
        return array;
    }

    function GzipImporter(model, eventData) {
        this.inflateAsTraceStream = false;
        if (typeof (eventData) === 'string' || eventData instanceof String) {
            eventData = _stringToUInt8Array(eventData);
        } else if (eventData instanceof ArrayBuffer) {
            eventData = new Uint8Array(eventData);
        } else if (eventData instanceof tr.b.InMemoryTraceStream) {
            eventData = eventData.data;
            this.inflateAsTraceStream_ = true;
        } else {
            throw new Error('Unknown gzip data format');
        }
        this.model_ = model;
        this.gzipData_ = eventData;
    }

    GzipImporter.canImport = function (eventData) {
        if (eventData instanceof tr.b.InMemoryTraceStream) {
            eventData = eventData.header;
        }
        let header;
        if (eventData instanceof ArrayBuffer) {
            header = new Uint8Array(eventData.slice(0, GZIP_MEMBER_HEADER_ID_SIZE));
        } else if (typeof (eventData) === 'string' || eventData instanceof String) {
            header = eventData.substring(0, GZIP_MEMBER_HEADER_ID_SIZE);
            header = _stringToUInt8Array(header);
        } else {
            return false;
        }
        return header[0] === GZIP_HEADER_ID1 && header[1] === GZIP_HEADER_ID2 && header[2] === GZIP_DEFLATE_COMPRESSION;
    };
    GzipImporter.inflateGzipData_ = function (data) {
        let position = 0;

        function getByte() {
            if (position >= data.length) {
                throw new Error('Unexpected end of gzip data');
            }
            return data[position++];
        }

        function getWord() {
            const low = getByte();
            const high = getByte();
            return (high << 8) + low;
        }

        function skipBytes(amount) {
            position += amount;
        }

        function skipZeroTerminatedString() {
            while (getByte() !== 0) {
            }
        }

        const id1 = getByte();
        const id2 = getByte();
        if (id1 !== GZIP_HEADER_ID1 || id2 !== GZIP_HEADER_ID2) {
            throw new Error('Not gzip data');
        }
        const compressionMethod = getByte();
        if (compressionMethod !== GZIP_DEFLATE_COMPRESSION) {
            throw new Error('Unsupported compression method: ' + compressionMethod);
        }
        const flags = getByte();
        const haveHeaderCrc = flags & (1 << 1);
        const haveExtraFields = flags & (1 << 2);
        const haveFileName = flags & (1 << 3);
        const haveComment = flags & (1 << 4);
        skipBytes(4 + 1 + 1);
        if (haveExtraFields) {
            const bytesToSkip = getWord();
            skipBytes(bytesToSkip);
        }
        if (haveFileName) skipZeroTerminatedString();
        if (haveComment) skipZeroTerminatedString();
        if (haveHeaderCrc) getWord();
        const inflatedData = pako.inflateRaw(data.subarray(position));
        if (this.inflateAsTraceStream_) {
            return GzipImporter.transformToStream(inflatedData);
        }
        let string;
        try {
            string = GzipImporter.transformToString(inflatedData);
        } catch (err) {
            return GzipImporter.transformToStream(inflatedData);
        }
        if (inflatedData.length > 0 && string.length === 0) {
            return GzipImporter.transformToStream(inflatedData);
        }
        return string;
    };
    GzipImporter.transformToStream = function (data) {
        if (data instanceof Uint8Array) {
            return new tr.b.InMemoryTraceStream(data, false);
        }
        throw new Error(`Cannot transform ${type} to TraceStream.`);
    };
    GzipImporter.transformToString = function (data) {
        if (typeof (data) === 'string') return data;
        if (typeof TextDecoder === 'undefined') {
            if (data instanceof ArrayBuffer) {
                data = new Uint8Array(data);
            }
            const result = [];
            let chunk = 65536;
            let k = 0;
            const len = data.length;
            while (k < len && chunk > 1) {
                try {
                    const chunklen = Math.min(k + chunk, len);
                    let dataslice;
                    if (data instanceof Array) {
                        dataslice = data.slice(k, chunklen);
                    } else {
                        dataslice = data.subarray(k, chunklen);
                    }
                    result.push(String.fromCharCode.apply(null, dataslice));
                    k += chunk;
                } catch (e) {
                    chunk = Math.floor(chunk / 2);
                }
            }
            return result.join('');
        }
        if (data instanceof Array) {
            data = new Uint8Array(data);
        }
        return new TextDecoder('utf-8').decode(data);
    };
    GzipImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'GzipImporter';
        }, isTraceDataContainer() {
            return true;
        }, extractSubtraces() {
            const eventData = GzipImporter.inflateGzipData_(this.gzipData_);
            return eventData ? [eventData] : [];
        }
    };
    tr.importer.Importer.register(GzipImporter);
    return {GzipImporter,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    class SimpleLineReader {
        constructor(text) {
            this.data_ = text instanceof tr.b.TraceStream ? text : text.split(new RegExp('\r?\n'));
            this.curLine_ = 0;
            this.readLastLine_ = false;
            this.savedLines_ = undefined;
        }

        * [Symbol.iterator]() {
            let lastLine = undefined;
            while (this.hasData_) {
                if (this.readLastLine_) {
                    this.curLine_++;
                    this.readLastLine_ = false;
                } else if (this.data_ instanceof tr.b.TraceStream) {
                    this.curLine_++;
                    const line = this.data_.readUntilDelimiter('\n');
                    if (line.endsWith('\r\n')) {
                        lastLine = line.slice(0, -2);
                    } else if (line.endsWith('\n')) {
                        lastLine = line.slice(0, -1);
                    } else {
                        lastLine = line;
                    }
                } else {
                    this.curLine_++;
                    lastLine = this.data_[this.curLine_ - 1];
                }
                yield lastLine;
            }
        }

        get curLineNumber() {
            return this.curLine_;
        }

        get hasData_() {
            if (this.data_ instanceof tr.b.TraceStream) return this.data_.hasData;
            return this.curLine_ < this.data_.length;
        }

        advanceToLineMatching(regex) {
            for (const line of this) {
                if (this.savedLines_ !== undefined) this.savedLines_.push(line);
                if (regex.test(line)) {
                    this.goBack_();
                    return true;
                }
            }
            return false;
        }

        goBack_() {
            if (this.readLastLine_) {
                throw new Error('There should be at least one nextLine call between ' + 'any two goBack calls.');
            }
            if (this.curLine_ === 0) {
                throw new Error('There should be at least one nextLine call before ' + 'the first goBack call.');
            }
            this.readLastLine_ = true;
            this.curLine_--;
        }

        beginSavingLines() {
            this.savedLines_ = [];
        }

        endSavingLinesAndGetResult() {
            const tmp = this.savedLines_;
            this.savedLines_ = undefined;
            return tmp;
        }
    }

    return {SimpleLineReader,};
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    function Trace2HTMLImporter(model, events) {
        this.importPriority = 0;
    }

    Trace2HTMLImporter.subtraces_ = [];

    function _extractEventsFromHTML(text) {
        Trace2HTMLImporter.subtraces_ = [];
        const r = new tr.importer.SimpleLineReader(text);
        while (true) {
            if (!r.advanceToLineMatching(new RegExp('^<\s*script id="viewer-data" ' + 'type="(application\/json|text\/plain)">\r?$'))) {
                break;
            }
            r.beginSavingLines();
            if (!r.advanceToLineMatching(/^<\/\s*script>\r?$/)) return;
            let rawEvents = r.endSavingLinesAndGetResult();
            rawEvents = rawEvents.slice(1, rawEvents.length - 1);
            const data64 = rawEvents.join('\n');
            const buffer = new ArrayBuffer(tr.b.Base64.getDecodedBufferLength(data64));
            const len = tr.b.Base64.DecodeToTypedArray(data64, new DataView(buffer));
            Trace2HTMLImporter.subtraces_.push(buffer.slice(0, len));
        }
    }

    function _canImportFromHTML(text) {
        if (!/^<!DOCTYPE html>/.test(text)) return false;
        _extractEventsFromHTML(text);
        if (Trace2HTMLImporter.subtraces_.length === 0) return false;
        return true;
    }

    Trace2HTMLImporter.canImport = function (events) {
        if (events instanceof tr.b.TraceStream) return false;
        return _canImportFromHTML(events);
    };
    Trace2HTMLImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'Trace2HTMLImporter';
        }, isTraceDataContainer() {
            return true;
        }, extractSubtraces() {
            return Trace2HTMLImporter.subtraces_;
        }, importEvents() {
        }
    };
    tr.importer.Importer.register(Trace2HTMLImporter);
    return {Trace2HTMLImporter,};
});
'use strict';
tr.exportTo('tr.e.importer.v8', function () {
    function SplayTree() {
    }

    SplayTree.prototype.root_ = null;
    SplayTree.prototype.isEmpty = function () {
        return !this.root_;
    };
    SplayTree.prototype.insert = function (key, value) {
        if (this.isEmpty()) {
            this.root_ = new SplayTree.Node(key, value);
            return;
        }
        this.splay_(key);
        if (this.root_.key === key) {
            return;
        }
        const node = new SplayTree.Node(key, value);
        if (key > this.root_.key) {
            node.left = this.root_;
            node.right = this.root_.right;
            this.root_.right = null;
        } else {
            node.right = this.root_;
            node.left = this.root_.left;
            this.root_.left = null;
        }
        this.root_ = node;
    };
    SplayTree.prototype.remove = function (key) {
        if (this.isEmpty()) {
            throw Error('Key not found: ' + key);
        }
        this.splay_(key);
        if (this.root_.key !== key) {
            throw Error('Key not found: ' + key);
        }
        const removed = this.root_;
        if (!this.root_.left) {
            this.root_ = this.root_.right;
        } else {
            const right = this.root_.right;
            this.root_ = this.root_.left;
            this.splay_(key);
            this.root_.right = right;
        }
        return removed;
    };
    SplayTree.prototype.find = function (key) {
        if (this.isEmpty()) return null;
        this.splay_(key);
        return this.root_.key === key ? this.root_ : null;
    };
    SplayTree.prototype.findMin = function () {
        if (this.isEmpty()) return null;
        let current = this.root_;
        while (current.left) {
            current = current.left;
        }
        return current;
    };
    SplayTree.prototype.findMax = function (opt_startNode) {
        if (this.isEmpty()) return null;
        let current = opt_startNode || this.root_;
        while (current.right) {
            current = current.right;
        }
        return current;
    };
    SplayTree.prototype.findGreatestLessThan = function (key) {
        if (this.isEmpty()) return null;
        this.splay_(key);
        if (this.root_.key <= key) {
            return this.root_;
        }
        if (this.root_.left) {
            return this.findMax(this.root_.left);
        }
        return null;
    };
    SplayTree.prototype.exportKeysAndValues = function () {
        const result = [];
        this.traverse_(function (node) {
            result.push([node.key, node.value]);
        });
        return result;
    };
    SplayTree.prototype.exportValues = function () {
        const result = [];
        this.traverse_(function (node) {
            result.push(node.value);
        });
        return result;
    };
    SplayTree.prototype.splay_ = function (key) {
        if (this.isEmpty()) return;
        const dummy = new SplayTree.Node(null, null);
        let left = dummy;
        let right = dummy;
        let current = this.root_;
        while (true) {
            if (key < current.key) {
                if (!current.left) {
                    break;
                }
                if (key < current.left.key) {
                    const tmp = current.left;
                    current.left = tmp.right;
                    tmp.right = current;
                    current = tmp;
                    if (!current.left) {
                        break;
                    }
                }
                right.left = current;
                right = current;
                current = current.left;
            } else if (key > current.key) {
                if (!current.right) {
                    break;
                }
                if (key > current.right.key) {
                    const tmp = current.right;
                    current.right = tmp.left;
                    tmp.left = current;
                    current = tmp;
                    if (!current.right) {
                        break;
                    }
                }
                left.right = current;
                left = current;
                current = current.right;
            } else {
                break;
            }
        }
        left.right = current.left;
        right.left = current.right;
        current.left = dummy.right;
        current.right = dummy.left;
        this.root_ = current;
    };
    SplayTree.prototype.traverse_ = function (f) {
        const nodesToVisit = [this.root_];
        while (nodesToVisit.length > 0) {
            const node = nodesToVisit.shift();
            if (node === null) continue;
            f(node);
            nodesToVisit.push(node.left);
            nodesToVisit.push(node.right);
        }
    };
    SplayTree.Node = function (key, value) {
        this.key = key;
        this.value = value;
    };
    SplayTree.Node.prototype.left = null;
    SplayTree.Node.prototype.right = null;
    return {SplayTree,};
});
'use strict';
tr.exportTo('tr.e.importer.v8', function () {
    function CodeMap() {
        this.dynamics_ = new tr.e.importer.v8.SplayTree();
        this.dynamicsNameGen_ = new tr.e.importer.v8.CodeMap.NameGenerator();
        this.statics_ = new tr.e.importer.v8.SplayTree();
        this.libraries_ = new tr.e.importer.v8.SplayTree();
        this.pages_ = [];
    }

    CodeMap.PAGE_ALIGNMENT = 12;
    CodeMap.PAGE_SIZE = 1 << CodeMap.PAGE_ALIGNMENT;
    CodeMap.prototype.addCode = function (start, codeEntry) {
        this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);
        this.dynamics_.insert(start, codeEntry);
    };
    CodeMap.prototype.moveCode = function (from, to) {
        const removedNode = this.dynamics_.remove(from);
        this.deleteAllCoveredNodes_(this.dynamics_, to, to + removedNode.value.size);
        this.dynamics_.insert(to, removedNode.value);
    };
    CodeMap.prototype.deleteCode = function (start) {
        const removedNode = this.dynamics_.remove(start);
    };
    CodeMap.prototype.addLibrary = function (start, codeEntry) {
        this.markPages_(start, start + codeEntry.size);
        this.libraries_.insert(start, codeEntry);
    };
    CodeMap.prototype.addStaticCode = function (start, codeEntry) {
        this.statics_.insert(start, codeEntry);
    };
    CodeMap.prototype.markPages_ = function (start, end) {
        for (let addr = start; addr <= end; addr += CodeMap.PAGE_SIZE) {
            this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;
        }
    };
    CodeMap.prototype.deleteAllCoveredNodes_ = function (tree, start, end) {
        const toDelete = [];
        let addr = end - 1;
        while (addr >= start) {
            const node = tree.findGreatestLessThan(addr);
            if (!node) break;
            const start2 = node.key;
            const end2 = start2 + node.value.size;
            if (start2 < end && start < end2) toDelete.push(start2);
            addr = start2 - 1;
        }
        for (let i = 0, l = toDelete.length; i < l; ++i) tree.remove(toDelete[i]);
    };
    CodeMap.prototype.isAddressBelongsTo_ = function (addr, node) {
        return addr >= node.key && addr < (node.key + node.value.size);
    };
    CodeMap.prototype.findInTree_ = function (tree, addr) {
        const node = tree.findGreatestLessThan(addr);
        return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;
    };
    CodeMap.prototype.findEntryInLibraries = function (addr) {
        const pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
        if (pageAddr in this.pages_) {
            return this.findInTree_(this.libraries_, addr);
        }
        return undefined;
    };
    CodeMap.prototype.findEntry = function (addr) {
        const pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
        if (pageAddr in this.pages_) {
            return this.findInTree_(this.statics_, addr) || this.findInTree_(this.libraries_, addr);
        }
        const min = this.dynamics_.findMin();
        const max = this.dynamics_.findMax();
        if (max !== null && addr < (max.key + max.value.size) && addr >= min.key) {
            const dynaEntry = this.findInTree_(this.dynamics_, addr);
            if (dynaEntry === null) return null;
            if (!dynaEntry.nameUpdated_) {
                dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);
                dynaEntry.nameUpdated_ = true;
            }
            return dynaEntry;
        }
        return null;
    };
    CodeMap.prototype.findDynamicEntryByStartAddress = function (addr) {
        const node = this.dynamics_.find(addr);
        return node ? node.value : null;
    };
    CodeMap.prototype.getAllDynamicEntries = function () {
        return this.dynamics_.exportValues();
    };
    CodeMap.prototype.getAllDynamicEntriesWithAddresses = function () {
        return this.dynamics_.exportKeysAndValues();
    };
    CodeMap.prototype.getAllStaticEntries = function () {
        return this.statics_.exportValues();
    };
    CodeMap.prototype.getAllLibrariesEntries = function () {
        return this.libraries_.exportValues();
    };
    CodeMap.CodeState = {COMPILED: 0, OPTIMIZABLE: 1, OPTIMIZED: 2};
    CodeMap.CodeEntry = function (size, opt_name, opt_type) {
        this.id = tr.b.GUID.allocateSimple();
        this.size = size;
        this.name_ = opt_name || '';
        this.type = opt_type || '';
        this.nameUpdated_ = false;
    };
    CodeMap.CodeEntry.prototype = {
        __proto__: Object.prototype, get name() {
            return this.name_;
        }, set name(value) {
            this.name_ = value;
        }, toString() {
            this.name_ + ': ' + this.size.toString(16);
        }
    };
    CodeMap.CodeEntry.TYPE = {SHARED_LIB: 'SHARED_LIB', CPP: 'CPP'};
    CodeMap.DynamicFuncCodeEntry = function (size, type, func, state) {
        CodeMap.CodeEntry.call(this, size, '', type);
        this.func = func;
        this.state = state;
    };
    CodeMap.DynamicFuncCodeEntry.STATE_PREFIX = ['', '~', '*'];
    CodeMap.DynamicFuncCodeEntry.prototype = {
        __proto__: CodeMap.CodeEntry.prototype, get name() {
            return CodeMap.DynamicFuncCodeEntry.STATE_PREFIX[this.state] +
                this.func.name;
        }, set name(value) {
            this.name_ = value;
        }, getRawName() {
            return this.func.getName();
        }, isJSFunction() {
            return true;
        }, toString() {
            return this.type + ': ' + this.name + ': ' + this.size.toString(16);
        }
    };
    CodeMap.FunctionEntry = function (name) {
        CodeMap.CodeEntry.call(this, 0, name);
    };
    CodeMap.FunctionEntry.prototype = {
        __proto__: CodeMap.CodeEntry.prototype, get name() {
            let name = this.name_;
            if (name.length === 0) {
                name = '<anonymous>';
            } else if (name.charAt(0) === ' ') {
                name = '<anonymous>' + name;
            }
            return name;
        }, set name(value) {
            this.name_ = value;
        }
    };
    CodeMap.NameGenerator = function () {
        this.knownNames_ = {};
    };
    CodeMap.NameGenerator.prototype.getName = function (name) {
        if (!(name in this.knownNames_)) {
            this.knownNames_[name] = 0;
            return name;
        }
        const count = ++this.knownNames_[name];
        return name + ' {' + count + '}';
    };
    return {CodeMap,};
});
'use strict';
tr.exportTo('tr.e.importer.v8', function () {
    function CsvParser() {
    }

    CsvParser.CSV_FIELD_RE_ = /^"((?:[^"]|"")*)"|([^,]*)/;
    CsvParser.DOUBLE_QUOTE_RE_ = /""/g;
    CsvParser.prototype.parseLine = function (line) {
        const fieldRe = CsvParser.CSV_FIELD_RE_;
        const doubleQuoteRe = CsvParser.DOUBLE_QUOTE_RE_;
        let pos = 0;
        const endPos = line.length;
        const fields = [];
        if (endPos > 0) {
            do {
                const fieldMatch = fieldRe.exec(line.substr(pos));
                if (typeof fieldMatch[1] === 'string') {
                    const field = fieldMatch[1];
                    pos += field.length + 3;
                    fields.push(field.replace(doubleQuoteRe, '"'));
                } else {
                    const field = fieldMatch[2];
                    pos += field.length + 1;
                    fields.push(field);
                }
            } while (pos <= endPos);
        }
        return fields;
    };

    function LogReader(dispatchTable) {
        this.dispatchTable_ = dispatchTable;
        this.lineNum_ = 0;
        this.csvParser_ = new CsvParser();
    }

    LogReader.prototype.printError = function (str) {
    };
    LogReader.prototype.processLogChunk = function (chunk) {
        this.processLog_(chunk.split('\n'));
    };
    LogReader.prototype.processLogLine = function (line) {
        this.processLog_([line]);
    };
    LogReader.prototype.processStack = function (pc, func, stack) {
        const fullStack = func ? [pc, func] : [pc];
        let prevFrame = pc;
        for (let i = 0, n = stack.length; i < n; ++i) {
            const frame = stack[i];
            const firstChar = frame.charAt(0);
            if (firstChar === '+' || firstChar === '-') {
                prevFrame += parseInt(frame, 16);
                fullStack.push(prevFrame);
            } else if (firstChar !== 'o') {
                fullStack.push(parseInt(frame, 16));
            }
        }
        return fullStack;
    };
    LogReader.prototype.skipDispatch = function (dispatch) {
        return false;
    };
    LogReader.prototype.dispatchLogRow_ = function (fields) {
        const command = fields[0];
        if (!(command in this.dispatchTable_)) return;
        const dispatch = this.dispatchTable_[command];
        if (dispatch === null || this.skipDispatch(dispatch)) {
            return;
        }
        const parsedFields = [];
        for (let i = 0; i < dispatch.parsers.length; ++i) {
            const parser = dispatch.parsers[i];
            if (parser === null) {
                parsedFields.push(fields[1 + i]);
            } else if (typeof parser === 'function') {
                parsedFields.push(parser(fields[1 + i]));
            } else {
                parsedFields.push(fields.slice(1 + i));
                break;
            }
        }
        dispatch.processor.apply(this, parsedFields);
    };
    LogReader.prototype.processLog_ = function (lines) {
        for (let i = 0, n = lines.length; i < n; ++i, ++this.lineNum_) {
            const line = lines[i];
            if (!line) {
                continue;
            }
            try {
                const fields = this.csvParser_.parseLine(line);
                this.dispatchLogRow_(fields);
            } catch (e) {
                this.printError('line ' + (this.lineNum_ + 1) + ': ' +
                    (e.message || e));
            }
        }
    };
    return {LogReader,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ProfileNode(id, title, parentNode) {
        this.id_ = id;
        this.title_ = title;
        this.parentNode_ = parentNode;
        this.colorId_ = -1;
        this.userFriendlyStack_ = [];
    }

    ProfileNode.prototype = {
        __proto__: Object.prototype, get title() {
            return this.title_;
        }, get parentNode() {
            return this.parentNode_;
        }, set parentNode(value) {
            this.parentNode_ = value;
        }, get id() {
            return this.id_;
        }, get colorId() {
            return this.colorId_;
        }, set colorId(value) {
            this.colorId_ = value;
        }, get userFriendlyName() {
            return this.title_;
        }, get userFriendlyStack() {
            if (this.userFriendlyStack_.length === 0) {
                this.userFriendlyStack_ = [this.userFriendlyName];
                if (this.parentNode_ !== undefined) {
                    this.userFriendlyStack_ = this.userFriendlyStack_.concat(this.parentNode_.userFriendlyStack);
                }
            }
            return this.userFriendlyStack_;
        }, get sampleTitle() {
            throw new Error('Not implemented.');
        }
    };
    tr.model.EventRegistry.register(ProfileNode, {name: 'Node', pluralName: 'Nodes'});
    return {ProfileNode,};
});
'use strict';
tr.exportTo('tr.e.v8', function () {
    const ProfileNode = tr.model.ProfileNode;

    function V8CpuProfileNode(id, callFrame, parentNode) {
        ProfileNode.call(this, id, callFrame.functionName, parentNode);
        this.callFrame_ = tr.b.deepCopy(callFrame);
        this.deoptReason_ = '';
        this.colorId_ = tr.b.ColorScheme.getColorIdForGeneralPurposeString(callFrame.functionName);
    }

    V8CpuProfileNode.prototype = {
        __proto__: ProfileNode.prototype, get functionName() {
            return this.callFrame_.functionName;
        }, get scriptId() {
            return this.callFrame_.scriptId;
        }, get url() {
            if (!this.callFrame_.url) {
                return 'unknown';
            }
            let url = this.callFrame_.url;
            if (this.callFrame_.lineNumber === undefined) {
                return url;
            }
            url = url + ':' + this.callFrame_.lineNumber;
            if (this.callFrame_.columnNumber === undefined) {
                return url;
            }
            url = url + ':' + this.callFrame_.columnNumber;
            return url;
        }, get deoptReason() {
            return this.deoptReason_;
        }, set deoptReason(value) {
            this.deoptReason_ = value;
        }, get userFriendlyName() {
            const name = this.functionName + ' url: ' + this.url;
            return !this.deoptReason_ ? name : name + ' Deoptimized reason: ' + this.deoptReason_;
        }, get sampleTitle() {
            return 'V8 Sample';
        }
    };
    V8CpuProfileNode.constructFromObject = function (profileTree, node) {
        const nodeId = node.id;
        if (nodeId === 1) {
            return undefined;
        }
        const parentNode = profileTree.getNode(node.parent);
        const profileNode = new V8CpuProfileNode(nodeId, node.callFrame, parentNode);
        if (node.deoptReason !== undefined) {
            profileNode.deoptReason = node.deoptReason;
        }
        return profileNode;
    };
    ProfileNode.subTypes.register(V8CpuProfileNode, {
        typeName: 'cpuProfile',
        name: 'v8 cpu profile node',
        pluralName: 'v8 cpu profile nodes'
    });
    ProfileNode.subTypes.register(V8CpuProfileNode, {
        typeName: 'legacySample',
        name: 'v8 cpu profile node',
        pluralName: 'v8 cpu profile nodes'
    });
    return {ProfileNode,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ProfileTree() {
        this.startTime_ = undefined;
        this.endTime_ = undefined;
        this.tree_ = new Map();
        this.pid_ = -1;
        this.tid_ = -1;
    }

    ProfileTree.prototype = {
        __proto__: Object.prototype, get pid() {
            return this.pid_;
        }, set pid(value) {
            this.pid_ = value;
        }, get tid() {
            return this.tid_;
        }, set tid(value) {
            this.tid_ = value;
        }, get tree() {
            return this.tree_;
        }, get startTime() {
            return this.startTime_;
        }, set startTime(value) {
            this.startTime_ = value;
            this.endTime_ = value;
        }, get endTime() {
            return this.endTime_;
        }, set endTime(value) {
            this.endTime_ = value;
        }, add(node) {
            if (this.tree_.has(node.id)) {
                throw new Error('Conflict id in the profile tree.');
            }
            this.tree_.set(node.id, node);
            return node;
        }, getNode(nodeId) {
            return this.tree_.get(nodeId);
        }
    };
    return {ProfileTree,};
});
'use strict';
tr.exportTo('tr.e.importer.v8', function () {
    const CodeEntry = tr.e.importer.v8.CodeMap.CodeEntry;
    const CodeMap = tr.e.importer.v8.CodeMap;
    const ColorScheme = tr.b.ColorScheme;
    const DynamicFuncCodeEntry = tr.e.importer.v8.CodeMap.DynamicFuncCodeEntry;
    const FunctionEntry = tr.e.importer.v8.CodeMap.FunctionEntry;
    const ProfileNodeType = tr.model.ProfileNode.subTypes.getConstructor(undefined, 'legacySample');

    function V8LogImporter(model, eventData) {
        this.importPriority = 3;
        this.model_ = model;
        this.logData_ = eventData;
        this.code_map_ = new CodeMap();
        this.v8_timer_thread_ = undefined;
        this.v8_thread_ = undefined;
        this.profileTree_ = new tr.model.ProfileTree();
        this.profileTree_.add(new ProfileNodeType(-1, {url: '', functionName: 'unknown'}));
        this.v8_stack_timeline_ = [];
    }

    const kV8BinarySuffixes = ['/d8', '/libv8.so'];
    const TimerEventDefaultArgs = {
        'V8.Execute': {pause: false, no_execution: false},
        'V8.External': {pause: false, no_execution: true},
        'V8.CompileFullCode': {pause: true, no_execution: true},
        'V8.RecompileSynchronous': {pause: true, no_execution: true},
        'V8.RecompileParallel': {pause: false, no_execution: false},
        'V8.CompileEval': {pause: true, no_execution: true},
        'V8.Parse': {pause: true, no_execution: true},
        'V8.PreParse': {pause: true, no_execution: true},
        'V8.ParseLazy': {pause: true, no_execution: true},
        'V8.GCScavenger': {pause: true, no_execution: true},
        'V8.GCCompactor': {pause: true, no_execution: true},
        'V8.GCContext': {pause: true, no_execution: true}
    };
    V8LogImporter.canImport = function (eventData) {
        if (typeof (eventData) !== 'string' && !(eventData instanceof String)) {
            return false;
        }
        return eventData.substring(0, 11) === 'v8-version,' || eventData.substring(0, 12) === 'timer-event,' || eventData.substring(0, 5) === 'tick,' || eventData.substring(0, 15) === 'shared-library,' || eventData.substring(0, 9) === 'profiler,' || eventData.substring(0, 14) === 'code-creation,';
    };
    V8LogImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'V8LogImporter';
        }, processTimerEvent_(name, startInUs, lengthInUs) {
            const args = TimerEventDefaultArgs[name];
            if (args === undefined) return;
            const startInMs = tr.b.convertUnit(startInUs, tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
            const lengthInMs = tr.b.convertUnit(lengthInUs, tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
            const colorId = ColorScheme.getColorIdForGeneralPurposeString(name);
            const slice = new tr.model.ThreadSlice('v8', name, colorId, startInMs, args, lengthInMs);
            this.v8_timer_thread_.sliceGroup.pushSlice(slice);
        }, processTimerEventStart_(name, startInUs) {
            const args = TimerEventDefaultArgs[name];
            if (args === undefined) return;
            const startInMs = tr.b.convertUnit(startInUs, tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
            this.v8_timer_thread_.sliceGroup.beginSlice('v8', name, startInMs, args);
        }, processTimerEventEnd_(name, endInUs) {
            const endInMs = tr.b.convertUnit(endInUs, tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
            this.v8_timer_thread_.sliceGroup.endSlice(endInMs);
        }, processCodeCreateEvent_(type, kind, address, size, name, maybeFunc) {
            function parseState(s) {
                switch (s) {
                    case'':
                        return CodeMap.CodeState.COMPILED;
                    case'~':
                        return CodeMap.CodeState.OPTIMIZABLE;
                    case'*':
                        return CodeMap.CodeState.OPTIMIZED;
                }
                throw new Error('unknown code state: ' + s);
            }

            if (maybeFunc.length) {
                const funcAddr = parseInt(maybeFunc[0]);
                const state = parseState(maybeFunc[1]);
                let func = this.code_map_.findDynamicEntryByStartAddress(funcAddr);
                if (!func) {
                    func = new FunctionEntry(name);
                    func.kind = kind;
                    this.code_map_.addCode(funcAddr, func);
                } else if (func.name !== name) {
                    func.name = name;
                }
                let entry = this.code_map_.findDynamicEntryByStartAddress(address);
                if (entry) {
                    if (entry.size === size && entry.func === func) {
                        entry.state = state;
                    }
                } else {
                    entry = new DynamicFuncCodeEntry(size, type, func, state);
                    entry.kind = kind;
                    this.code_map_.addCode(address, entry);
                }
            } else {
                const codeEntry = new CodeEntry(size, name);
                codeEntry.kind = kind;
                this.code_map_.addCode(address, codeEntry);
            }
        }, processCodeMoveEvent_(from, to) {
            this.code_map_.moveCode(from, to);
        }, processCodeDeleteEvent_(address) {
            this.code_map_.deleteCode(address);
        }, processSharedLibrary_(name, start, end) {
            const codeEntry = new CodeEntry(end - start, name, CodeEntry.TYPE.SHARED_LIB);
            codeEntry.kind = -3;
            for (let i = 0; i < kV8BinarySuffixes.length; i++) {
                const suffix = kV8BinarySuffixes[i];
                if (name.indexOf(suffix, name.length - suffix.length) >= 0) {
                    codeEntry.kind = -1;
                    break;
                }
            }
            this.code_map_.addLibrary(start, codeEntry);
        }, processCppSymbol_(address, size, name) {
            const codeEntry = new CodeEntry(size, name, CodeEntry.TYPE.CPP);
            codeEntry.kind = -1;
            this.code_map_.addStaticCode(address, codeEntry);
        }, processTickEvent_(pc, startInUs, isExternalCallback, tosOrExternalCallback, vmstate, stack) {
            const startInMs = tr.b.convertUnit(startInUs, tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);

            function findChildWithEntryID(stackFrame, entryID) {
                for (let i = 0; i < stackFrame.children.length; i++) {
                    if (stackFrame.children[i].entryID === entryID) {
                        return stackFrame.children[i];
                    }
                }
                return undefined;
            }

            function processStack(pc, func, stack) {
                const fullStack = func ? [pc, func] : [pc];
                let prevFrame = pc;
                for (let i = 0, n = stack.length; i < n; ++i) {
                    const frame = stack[i];
                    const firstChar = frame.charAt(0);
                    if (firstChar === '+' || firstChar === '-') {
                        prevFrame += parseInt(frame, 16);
                        fullStack.push(prevFrame);
                    } else if (firstChar !== 'o') {
                        fullStack.push(parseInt(frame, 16));
                    }
                }
                return fullStack;
            }

            if (isExternalCallback) {
                pc = tosOrExternalCallback;
                tosOrExternalCallback = 0;
            } else if (tosOrExternalCallback) {
                const funcEntry = this.code_map_.findEntry(tosOrExternalCallback);
                if (!funcEntry || !funcEntry.isJSFunction || !funcEntry.isJSFunction()) {
                    tosOrExternalCallback = 0;
                }
            }
            let processedStack = processStack(pc, tosOrExternalCallback, stack);
            let node = undefined;
            let lastNode = undefined;
            processedStack = processedStack.reverse();
            for (let i = 0, n = processedStack.length; i < n; i++) {
                const frame = processedStack[i];
                if (!frame) break;
                const entry = this.code_map_.findEntry(frame);
                if (!entry && i !== 0) {
                    continue;
                }
                let sourceInfo = undefined;
                if (entry && entry.type === CodeEntry.TYPE.CPP) {
                    const libEntry = this.code_map_.findEntryInLibraries(frame);
                    if (libEntry) {
                        sourceInfo = {file: libEntry.name};
                    }
                }
                const entryId = entry ? entry.id : -1;
                node = this.profileTree_.getNode(entryId);
                if (node === undefined) {
                    node = this.profileTree_.add(new ProfileNodeType(entryId, {
                        functionName: entry.name,
                        url: sourceInfo ? sourceInfo.file : '',
                        lineNumber: sourceInfo ? sourceInfo.line : undefined,
                        columnNumber: sourceInfo ? sourceInfo.column : undefined,
                        scriptId: sourceInfo ? sourceInfo.scriptId : undefined
                    }, lastNode));
                }
                lastNode = node;
            }
            this.model_.samples.push(new tr.model.Sample(startInMs, 'V8 PC', node, this.v8_thread_, undefined, 1));
        }, processDistortion_(distortionInPicoseconds) {
        }, processPlotRange_(start, end) {
        }, processV8Version_(major, minor, build, patch, candidate) {
        }, importEvents() {
            const logreader = new tr.e.importer.v8.LogReader({
                'timer-event': {parsers: [null, parseInt, parseInt], processor: this.processTimerEvent_.bind(this)},
                'shared-library': {
                    parsers: [null, parseInt, parseInt],
                    processor: this.processSharedLibrary_.bind(this)
                },
                'timer-event-start': {
                    parsers: [null, parseInt],
                    processor: this.processTimerEventStart_.bind(this)
                },
                'timer-event-end': {parsers: [null, parseInt], processor: this.processTimerEventEnd_.bind(this)},
                'code-creation': {
                    parsers: [null, parseInt, parseInt, parseInt, null, 'var-args'],
                    processor: this.processCodeCreateEvent_.bind(this)
                },
                'code-move': {parsers: [parseInt, parseInt], processor: this.processCodeMoveEvent_.bind(this)},
                'code-delete': {parsers: [parseInt], processor: this.processCodeDeleteEvent_.bind(this)},
                'cpp': {parsers: [parseInt, parseInt, null], processor: this.processCppSymbol_.bind(this)},
                'tick': {
                    parsers: [parseInt, parseInt, parseInt, parseInt, parseInt, 'var-args'],
                    processor: this.processTickEvent_.bind(this)
                },
                'distortion': {parsers: [parseInt], processor: this.processDistortion_.bind(this)},
                'plot-range': {parsers: [parseInt, parseInt], processor: this.processPlotRange_.bind(this)},
                'v8-version': {
                    parsers: [parseInt, parseInt, parseInt, parseInt, parseInt],
                    processor: this.processV8Version_.bind(this)
                }
            });
            this.v8_timer_thread_ = this.model_.getOrCreateProcess(-32).getOrCreateThread(1);
            this.v8_timer_thread_.name = 'V8 Timers';
            this.v8_thread_ = this.model_.getOrCreateProcess(-32).getOrCreateThread(2);
            this.v8_thread_.name = 'V8';
            const lines = this.logData_.split('\n');
            for (let i = 0; i < lines.length; i++) {
                logreader.processLogLine(lines[i]);
            }

            function addSlices(slices, thread) {
                for (let i = 0; i < slices.length; i++) {
                    const duration = slices[i].end - slices[i].start;
                    const slice = new tr.model.ThreadSlice('v8', slices[i].name, ColorScheme.getColorIdForGeneralPurposeString(slices[i].name), slices[i].start, {}, duration);
                    thread.sliceGroup.pushSlice(slice);
                    addSlices(slices[i].children, thread);
                }
            }

            addSlices(this.v8_stack_timeline_, this.v8_thread_);
        }
    };
    tr.importer.Importer.register(V8LogImporter);
    return {V8LogImporter,};
});
'use strict';
if (tr.isVinn) {
    global.window = {};
}
!function (a) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = a(); else if ("function" == typeof define && define.amd) define([], a); else {
        var b;
        "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.JSZip = a()
    }
}(function () {
    return function a(b, c, d) {
        function e(g, h) {
            if (!c[g]) {
                if (!b[g]) {
                    var i = "function" == typeof require && require;
                    if (!h && i) return i(g, !0);
                    if (f) return f(g, !0);
                    throw new Error("Cannot find module '" + g + "'")
                }
                var j = c[g] = {exports: {}};
                b[g][0].call(j.exports, function (a) {
                    var c = b[g][1][a];
                    return e(c ? c : a)
                }, j, j.exports, a, b, c, d)
            }
            return c[g].exports
        }

        for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
        return e
    }({
        1: [function (a, b, c) {
            "use strict";
            var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            c.encode = function (a) {
                for (var b, c, e, f, g, h, i, j = "", k = 0; k < a.length;) b = a.charCodeAt(k++), c = a.charCodeAt(k++), e = a.charCodeAt(k++), f = b >> 2, g = (3 & b) << 4 | c >> 4, h = (15 & c) << 2 | e >> 6, i = 63 & e, isNaN(c) ? h = i = 64 : isNaN(e) && (i = 64), j = j + d.charAt(f) + d.charAt(g) + d.charAt(h) + d.charAt(i);
                return j
            }, c.decode = function (a) {
                var b, c, e, f, g, h, i, j = "", k = 0;
                for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); k < a.length;) f = d.indexOf(a.charAt(k++)), g = d.indexOf(a.charAt(k++)), h = d.indexOf(a.charAt(k++)), i = d.indexOf(a.charAt(k++)), b = f << 2 | g >> 4, c = (15 & g) << 4 | h >> 2, e = (3 & h) << 6 | i, j += String.fromCharCode(b), 64 != h && (j += String.fromCharCode(c)), 64 != i && (j += String.fromCharCode(e));
                return j
            }
        }, {}],
        2: [function (a, b) {
            "use strict";

            function c() {
                this.compressedSize = 0, this.uncompressedSize = 0, this.crc32 = 0, this.compressionMethod = null, this.compressedContent = null
            }

            c.prototype = {
                getContent: function () {
                    return null
                }, getCompressedContent: function () {
                    return null
                }
            }, b.exports = c
        }, {}],
        3: [function (a, b, c) {
            "use strict";
            c.STORE = {
                magic: "\x00\x00", compress: function (a) {
                    return a
                }, uncompress: function (a) {
                    return a
                }, compressInputType: null, uncompressInputType: null
            }, c.DEFLATE = a("./flate")
        }, {"./flate": 8}],
        4: [function (a, b) {
            "use strict";
            var c = a("./utils"),
                d = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
            b.exports = function (a, b) {
                if ("undefined" == typeof a || !a.length) return 0;
                var e = "string" !== c.getTypeOf(a);
                "undefined" == typeof b && (b = 0);
                var f = 0, g = 0, h = 0;
                b = -1 ^ b;
                for (var i = 0, j = a.length; j > i; i++) h = e ? a[i] : a.charCodeAt(i), g = 255 & (b ^ h), f = d[g], b = b >>> 8 ^ f;
                return -1 ^ b
            }
        }, {"./utils": 21}],
        5: [function (a, b) {
            "use strict";

            function c() {
                this.data = null, this.length = 0, this.index = 0
            }

            var d = a("./utils");
            c.prototype = {
                checkOffset: function (a) {
                    this.checkIndex(this.index + a)
                }, checkIndex: function (a) {
                    if (this.length < a || 0 > a) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?")
                }, setIndex: function (a) {
                    this.checkIndex(a), this.index = a
                }, skip: function (a) {
                    this.setIndex(this.index + a)
                }, byteAt: function () {
                }, readInt: function (a) {
                    var b, c = 0;
                    for (this.checkOffset(a), b = this.index + a - 1; b >= this.index; b--) c = (c << 8) + this.byteAt(b);
                    return this.index += a, c
                }, readString: function (a) {
                    return d.transformTo("string", this.readData(a))
                }, readData: function () {
                }, lastIndexOfSignature: function () {
                }, readDate: function () {
                    var a = this.readInt(4);
                    return new Date((a >> 25 & 127) + 1980, (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1)
                }
            }, b.exports = c
        }, {"./utils": 21}],
        6: [function (a, b, c) {
            "use strict";
            c.base64 = !1, c.binary = !1, c.dir = !1, c.createFolders = !1, c.date = null, c.compression = null, c.comment = null
        }, {}],
        7: [function (a, b, c) {
            "use strict";
            var d = a("./utils");
            c.string2binary = function (a) {
                return d.string2binary(a)
            }, c.string2Uint8Array = function (a) {
                return d.transformTo("uint8array", a)
            }, c.uint8Array2String = function (a) {
                return d.transformTo("string", a)
            }, c.string2Blob = function (a) {
                var b = d.transformTo("arraybuffer", a);
                return d.arrayBuffer2Blob(b)
            }, c.arrayBuffer2Blob = function (a) {
                return d.arrayBuffer2Blob(a)
            }, c.transformTo = function (a, b) {
                return d.transformTo(a, b)
            }, c.getTypeOf = function (a) {
                return d.getTypeOf(a)
            }, c.checkSupport = function (a) {
                return d.checkSupport(a)
            }, c.MAX_VALUE_16BITS = d.MAX_VALUE_16BITS, c.MAX_VALUE_32BITS = d.MAX_VALUE_32BITS, c.pretty = function (a) {
                return d.pretty(a)
            }, c.findCompression = function (a) {
                return d.findCompression(a)
            }, c.isRegExp = function (a) {
                return d.isRegExp(a)
            }
        }, {"./utils": 21}],
        8: [function (a, b, c) {
            "use strict";
            var d = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array,
                e = a("pako");
            c.uncompressInputType = d ? "uint8array" : "array", c.compressInputType = d ? "uint8array" : "array", c.magic = "\b\x00", c.compress = function (a) {
                return e.deflateRaw(a)
            }, c.uncompress = function (a) {
                return e.inflateRaw(a)
            }
        }, {pako: 24}],
        9: [function (a, b) {
            "use strict";

            function c(a, b) {
                return this instanceof c ? (this.files = {}, this.comment = null, this.root = "", a && this.load(a, b), void (this.clone = function () {
                    var a = new c;
                    for (var b in this) "function" != typeof this[b] && (a[b] = this[b]);
                    return a
                })) : new c(a, b)
            }

            var d = a("./base64");
            c.prototype = a("./object"), c.prototype.load = a("./load"), c.support = a("./support"), c.defaults = a("./defaults"), c.utils = a("./deprecatedPublicUtils"), c.base64 = {
                encode: function (a) {
                    return d.encode(a)
                }, decode: function (a) {
                    return d.decode(a)
                }
            }, c.compressions = a("./compressions"), b.exports = c
        }, {
            "./base64": 1,
            "./compressions": 3,
            "./defaults": 6,
            "./deprecatedPublicUtils": 7,
            "./load": 10,
            "./object": 13,
            "./support": 17
        }],
        10: [function (a, b) {
            "use strict";
            var c = a("./base64"), d = a("./zipEntries");
            b.exports = function (a, b) {
                var e, f, g, h;
                for (b = b || {}, b.base64 && (a = c.decode(a)), f = new d(a, b), e = f.files, g = 0; g < e.length; g++) h = e[g], this.file(h.fileName, h.decompressed, {
                    binary: !0,
                    optimizedBinaryString: !0,
                    date: h.date,
                    dir: h.dir,
                    comment: h.fileComment.length ? h.fileComment : null,
                    createFolders: b.createFolders
                });
                return f.zipComment.length && (this.comment = f.zipComment), this
            }
        }, {"./base64": 1, "./zipEntries": 22}],
        11: [function (a, b) {
            (function (a) {
                "use strict";
                b.exports = function (b, c) {
                    return new a(b, c)
                }, b.exports.test = function (b) {
                    return a.isBuffer(b)
                }
            }).call(this, "undefined" != typeof Buffer ? Buffer : void 0)
        }, {}],
        12: [function (a, b) {
            "use strict";

            function c(a) {
                this.data = a, this.length = this.data.length, this.index = 0
            }

            var d = a("./uint8ArrayReader");
            c.prototype = new d, c.prototype.readData = function (a) {
                this.checkOffset(a);
                var b = this.data.slice(this.index, this.index + a);
                return this.index += a, b
            }, b.exports = c
        }, {"./uint8ArrayReader": 18}],
        13: [function (a, b) {
            "use strict";
            var c = a("./support"), d = a("./utils"), e = a("./crc32"), f = a("./signature"), g = a("./defaults"),
                h = a("./base64"), i = a("./compressions"), j = a("./compressedObject"), k = a("./nodeBuffer"),
                l = a("./utf8"), m = a("./stringWriter"), n = a("./uint8ArrayWriter"), o = function (a) {
                    if (a._data instanceof j && (a._data = a._data.getContent(), a.options.binary = !0, a.options.base64 = !1, "uint8array" === d.getTypeOf(a._data))) {
                        var b = a._data;
                        a._data = new Uint8Array(b.length), 0 !== b.length && a._data.set(b, 0)
                    }
                    return a._data
                }, p = function (a) {
                    var b = o(a), e = d.getTypeOf(b);
                    return "string" === e ? !a.options.binary && c.nodebuffer ? k(b, "utf-8") : a.asBinary() : b
                }, q = function (a) {
                    var b = o(this);
                    return null === b || "undefined" == typeof b ? "" : (this.options.base64 && (b = h.decode(b)), b = a && this.options.binary ? A.utf8decode(b) : d.transformTo("string", b), a || this.options.binary || (b = d.transformTo("string", A.utf8encode(b))), b)
                }, r = function (a, b, c) {
                    this.name = a, this.dir = c.dir, this.date = c.date, this.comment = c.comment, this._data = b, this.options = c, this._initialMetadata = {
                        dir: c.dir,
                        date: c.date
                    }
                };
            r.prototype = {
                asText: function () {
                    return q.call(this, !0)
                }, asBinary: function () {
                    return q.call(this, !1)
                }, asNodeBuffer: function () {
                    var a = p(this);
                    return d.transformTo("nodebuffer", a)
                }, asUint8Array: function () {
                    var a = p(this);
                    return d.transformTo("uint8array", a)
                }, asArrayBuffer: function () {
                    return this.asUint8Array().buffer
                }
            };
            var s = function (a, b) {
                var c, d = "";
                for (c = 0; b > c; c++) d += String.fromCharCode(255 & a), a >>>= 8;
                return d
            }, t = function () {
                var a, b, c = {};
                for (a = 0; a < arguments.length; a++) for (b in arguments[a]) arguments[a].hasOwnProperty(b) && "undefined" == typeof c[b] && (c[b] = arguments[a][b]);
                return c
            }, u = function (a) {
                return a = a || {}, a.base64 !== !0 || null !== a.binary && void 0 !== a.binary || (a.binary = !0), a = t(a, g), a.date = a.date || new Date, null !== a.compression && (a.compression = a.compression.toUpperCase()), a
            }, v = function (a, b, c) {
                var e, f = d.getTypeOf(b);
                if (c = u(c), c.createFolders && (e = w(a)) && x.call(this, e, !0), c.dir || null === b || "undefined" == typeof b) c.base64 = !1, c.binary = !1, b = null; else if ("string" === f) c.binary && !c.base64 && c.optimizedBinaryString !== !0 && (b = d.string2binary(b)); else {
                    if (c.base64 = !1, c.binary = !0, !(f || b instanceof j)) throw new Error("The data of '" + a + "' is in an unsupported format !");
                    "arraybuffer" === f && (b = d.transformTo("uint8array", b))
                }
                var g = new r(a, b, c);
                return this.files[a] = g, g
            }, w = function (a) {
                "/" == a.slice(-1) && (a = a.substring(0, a.length - 1));
                var b = a.lastIndexOf("/");
                return b > 0 ? a.substring(0, b) : ""
            }, x = function (a, b) {
                return "/" != a.slice(-1) && (a += "/"), b = "undefined" != typeof b ? b : !1, this.files[a] || v.call(this, a, null, {
                    dir: !0,
                    createFolders: b
                }), this.files[a]
            }, y = function (a, b) {
                var c, f = new j;
                return a._data instanceof j ? (f.uncompressedSize = a._data.uncompressedSize, f.crc32 = a._data.crc32, 0 === f.uncompressedSize || a.dir ? (b = i.STORE, f.compressedContent = "", f.crc32 = 0) : a._data.compressionMethod === b.magic ? f.compressedContent = a._data.getCompressedContent() : (c = a._data.getContent(), f.compressedContent = b.compress(d.transformTo(b.compressInputType, c)))) : (c = p(a), (!c || 0 === c.length || a.dir) && (b = i.STORE, c = ""), f.uncompressedSize = c.length, f.crc32 = e(c), f.compressedContent = b.compress(d.transformTo(b.compressInputType, c))), f.compressedSize = f.compressedContent.length, f.compressionMethod = b.magic, f
            }, z = function (a, b, c, g) {
                var h, i, j, k, m = (c.compressedContent, d.transformTo("string", l.utf8encode(b.name))),
                    n = b.comment || "", o = d.transformTo("string", l.utf8encode(n)),
                    p = m.length !== b.name.length, q = o.length !== n.length, r = b.options, t = "", u = "",
                    v = "";
                j = b._initialMetadata.dir !== b.dir ? b.dir : r.dir, k = b._initialMetadata.date !== b.date ? b.date : r.date, h = k.getHours(), h <<= 6, h |= k.getMinutes(), h <<= 5, h |= k.getSeconds() / 2, i = k.getFullYear() - 1980, i <<= 4, i |= k.getMonth() + 1, i <<= 5, i |= k.getDate(), p && (u = s(1, 1) + s(e(m), 4) + m, t += "up" + s(u.length, 2) + u), q && (v = s(1, 1) + s(this.crc32(o), 4) + o, t += "uc" + s(v.length, 2) + v);
                var w = "";
                w += "\n\x00", w += p || q ? "\x00\b" : "\x00\x00", w += c.compressionMethod, w += s(h, 2), w += s(i, 2), w += s(c.crc32, 4), w += s(c.compressedSize, 4), w += s(c.uncompressedSize, 4), w += s(m.length, 2), w += s(t.length, 2);
                var x = f.LOCAL_FILE_HEADER + w + m + t,
                    y = f.CENTRAL_FILE_HEADER + "\x00" + w + s(o.length, 2) + "\x00\x00\x00\x00" + (j === !0 ? "\x00\x00\x00" : "\x00\x00\x00\x00") + s(g, 4) + m + t + o;
                return {fileRecord: x, dirRecord: y, compressedObject: c}
            }, A = {
                load: function () {
                    throw new Error("Load method is not defined. Is the file jszip-load.js included ?")
                }, filter: function (a) {
                    var b, c, d, e, f = [];
                    for (b in this.files) this.files.hasOwnProperty(b) && (d = this.files[b], e = new r(d.name, d._data, t(d.options)), c = b.slice(this.root.length, b.length), b.slice(0, this.root.length) === this.root && a(c, e) && f.push(e));
                    return f
                }, file: function (a, b, c) {
                    if (1 === arguments.length) {
                        if (d.isRegExp(a)) {
                            var e = a;
                            return this.filter(function (a, b) {
                                return !b.dir && e.test(a)
                            })
                        }
                        return this.filter(function (b, c) {
                            return !c.dir && b === a
                        })[0] || null
                    }
                    return a = this.root + a, v.call(this, a, b, c), this
                }, folder: function (a) {
                    if (!a) return this;
                    if (d.isRegExp(a)) return this.filter(function (b, c) {
                        return c.dir && a.test(b)
                    });
                    var b = this.root + a, c = x.call(this, b), e = this.clone();
                    return e.root = c.name, e
                }, remove: function (a) {
                    a = this.root + a;
                    var b = this.files[a];
                    if (b || ("/" != a.slice(-1) && (a += "/"), b = this.files[a]), b && !b.dir) delete this.files[a]; else for (var c = this.filter(function (b, c) {
                        return c.name.slice(0, a.length) === a
                    }), d = 0; d < c.length; d++) delete this.files[c[d].name];
                    return this
                }, generate: function (a) {
                    a = t(a || {}, {
                        base64: !0,
                        compression: "STORE",
                        type: "base64",
                        comment: null
                    }), d.checkSupport(a.type);
                    var b, c, e = [], g = 0, j = 0,
                        k = d.transformTo("string", this.utf8encode(a.comment || this.comment || ""));
                    for (var l in this.files) if (this.files.hasOwnProperty(l)) {
                        var o = this.files[l], p = o.options.compression || a.compression.toUpperCase(), q = i[p];
                        if (!q) throw new Error(p + " is not a valid compression method !");
                        var r = y.call(this, o, q), u = z.call(this, l, o, r, g);
                        g += u.fileRecord.length + r.compressedSize, j += u.dirRecord.length, e.push(u)
                    }
                    var v = "";
                    v = f.CENTRAL_DIRECTORY_END + "\x00\x00\x00\x00" + s(e.length, 2) + s(e.length, 2) + s(j, 4) + s(g, 4) + s(k.length, 2) + k;
                    var w = a.type.toLowerCase();
                    for (b = "uint8array" === w || "arraybuffer" === w || "blob" === w || "nodebuffer" === w ? new n(g + j + v.length) : new m(g + j + v.length), c = 0; c < e.length; c++) b.append(e[c].fileRecord), b.append(e[c].compressedObject.compressedContent);
                    for (c = 0; c < e.length; c++) b.append(e[c].dirRecord);
                    b.append(v);
                    var x = b.finalize();
                    switch (a.type.toLowerCase()) {
                        case"uint8array":
                        case"arraybuffer":
                        case"nodebuffer":
                            return d.transformTo(a.type.toLowerCase(), x);
                        case"blob":
                            return d.arrayBuffer2Blob(d.transformTo("arraybuffer", x));
                        case"base64":
                            return a.base64 ? h.encode(x) : x;
                        default:
                            return x
                    }
                }, crc32: function (a, b) {
                    return e(a, b)
                }, utf8encode: function (a) {
                    return d.transformTo("string", l.utf8encode(a))
                }, utf8decode: function (a) {
                    return l.utf8decode(a)
                }
            };
            b.exports = A
        }, {
            "./base64": 1,
            "./compressedObject": 2,
            "./compressions": 3,
            "./crc32": 4,
            "./defaults": 6,
            "./nodeBuffer": 11,
            "./signature": 14,
            "./stringWriter": 16,
            "./support": 17,
            "./uint8ArrayWriter": 19,
            "./utf8": 20,
            "./utils": 21
        }],
        14: [function (a, b, c) {
            "use strict";
            c.LOCAL_FILE_HEADER = "PK", c.CENTRAL_FILE_HEADER = "PK", c.CENTRAL_DIRECTORY_END = "PK", c.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", c.ZIP64_CENTRAL_DIRECTORY_END = "PK", c.DATA_DESCRIPTOR = "PK\b"
        }, {}],
        15: [function (a, b) {
            "use strict";

            function c(a, b) {
                this.data = a, b || (this.data = e.string2binary(this.data)), this.length = this.data.length, this.index = 0
            }

            var d = a("./dataReader"), e = a("./utils");
            c.prototype = new d, c.prototype.byteAt = function (a) {
                return this.data.charCodeAt(a)
            }, c.prototype.lastIndexOfSignature = function (a) {
                return this.data.lastIndexOf(a)
            }, c.prototype.readData = function (a) {
                this.checkOffset(a);
                var b = this.data.slice(this.index, this.index + a);
                return this.index += a, b
            }, b.exports = c
        }, {"./dataReader": 5, "./utils": 21}],
        16: [function (a, b) {
            "use strict";
            var c = a("./utils"), d = function () {
                this.data = []
            };
            d.prototype = {
                append: function (a) {
                    a = c.transformTo("string", a), this.data.push(a)
                }, finalize: function () {
                    return this.data.join("")
                }
            }, b.exports = d
        }, {"./utils": 21}],
        17: [function (a, b, c) {
            (function (a) {
                "use strict";
                if (c.base64 = !0, c.array = !0, c.string = !0, c.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, c.nodebuffer = "undefined" != typeof a, c.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) c.blob = !1; else {
                    var b = new ArrayBuffer(0);
                    try {
                        c.blob = 0 === new Blob([b], {type: "application/zip"}).size
                    } catch (d) {
                        try {
                            var e = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
                                f = new e;
                            f.append(b), c.blob = 0 === f.getBlob("application/zip").size
                        } catch (d) {
                            c.blob = !1
                        }
                    }
                }
            }).call(this, "undefined" != typeof Buffer ? Buffer : void 0)
        }, {}],
        18: [function (a, b) {
            "use strict";

            function c(a) {
                a && (this.data = a, this.length = this.data.length, this.index = 0)
            }

            var d = a("./dataReader");
            c.prototype = new d, c.prototype.byteAt = function (a) {
                return this.data[a]
            }, c.prototype.lastIndexOfSignature = function (a) {
                for (var b = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), e = a.charCodeAt(3), f = this.length - 4; f >= 0; --f) if (this.data[f] === b && this.data[f + 1] === c && this.data[f + 2] === d && this.data[f + 3] === e) return f;
                return -1
            }, c.prototype.readData = function (a) {
                if (this.checkOffset(a), 0 === a) return new Uint8Array(0);
                var b = this.data.subarray(this.index, this.index + a);
                return this.index += a, b
            }, b.exports = c
        }, {"./dataReader": 5}],
        19: [function (a, b) {
            "use strict";
            var c = a("./utils"), d = function (a) {
                this.data = new Uint8Array(a), this.index = 0
            };
            d.prototype = {
                append: function (a) {
                    0 !== a.length && (a = c.transformTo("uint8array", a), this.data.set(a, this.index), this.index += a.length)
                }, finalize: function () {
                    return this.data
                }
            }, b.exports = d
        }, {"./utils": 21}],
        20: [function (a, b, c) {
            "use strict";
            for (var d = a("./utils"), e = a("./support"), f = a("./nodeBuffer"), g = new Array(256), h = 0; 256 > h; h++) g[h] = h >= 252 ? 6 : h >= 248 ? 5 : h >= 240 ? 4 : h >= 224 ? 3 : h >= 192 ? 2 : 1;
            g[254] = g[254] = 1;
            var i = function (a) {
                var b, c, d, f, g, h = a.length, i = 0;
                for (f = 0; h > f; f++) c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), i += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
                for (b = e.uint8array ? new Uint8Array(i) : new Array(i), g = 0, f = 0; i > g; f++) c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), 128 > c ? b[g++] = c : 2048 > c ? (b[g++] = 192 | c >>> 6, b[g++] = 128 | 63 & c) : 65536 > c ? (b[g++] = 224 | c >>> 12, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c) : (b[g++] = 240 | c >>> 18, b[g++] = 128 | c >>> 12 & 63, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c);
                return b
            }, j = function (a, b) {
                var c;
                for (b = b || a.length, b > a.length && (b = a.length), c = b - 1; c >= 0 && 128 === (192 & a[c]);) c--;
                return 0 > c ? b : 0 === c ? b : c + g[a[c]] > b ? c : b
            }, k = function (a) {
                var b, c, e, f, h = a.length, i = new Array(2 * h);
                for (c = 0, b = 0; h > b;) if (e = a[b++], 128 > e) i[c++] = e; else if (f = g[e], f > 4) i[c++] = 65533, b += f - 1; else {
                    for (e &= 2 === f ? 31 : 3 === f ? 15 : 7; f > 1 && h > b;) e = e << 6 | 63 & a[b++], f--;
                    f > 1 ? i[c++] = 65533 : 65536 > e ? i[c++] = e : (e -= 65536, i[c++] = 55296 | e >> 10 & 1023, i[c++] = 56320 | 1023 & e)
                }
                return i.length !== c && (i.subarray ? i = i.subarray(0, c) : i.length = c), d.applyFromCharCode(i)
            };
            c.utf8encode = function (a) {
                return e.nodebuffer ? f(a, "utf-8") : i(a)
            }, c.utf8decode = function (a) {
                if (e.nodebuffer) return d.transformTo("nodebuffer", a).toString("utf-8");
                a = d.transformTo(e.uint8array ? "uint8array" : "array", a);
                for (var b = [], c = 0, f = a.length, g = 65536; f > c;) {
                    var h = j(a, Math.min(c + g, f));
                    b.push(e.uint8array ? k(a.subarray(c, h)) : k(a.slice(c, h))), c = h
                }
                return b.join("")
            }
        }, {"./nodeBuffer": 11, "./support": 17, "./utils": 21}],
        21: [function (a, b, c) {
            "use strict";

            function d(a) {
                return a
            }

            function e(a, b) {
                for (var c = 0; c < a.length; ++c) b[c] = 255 & a.charCodeAt(c);
                return b
            }

            function f(a) {
                var b = 65536, d = [], e = a.length, f = c.getTypeOf(a), g = 0, h = !0;
                try {
                    switch (f) {
                        case"uint8array":
                            String.fromCharCode.apply(null, new Uint8Array(0));
                            break;
                        case"nodebuffer":
                            String.fromCharCode.apply(null, j(0))
                    }
                } catch (i) {
                    h = !1
                }
                if (!h) {
                    for (var k = "", l = 0; l < a.length; l++) k += String.fromCharCode(a[l]);
                    return k
                }
                for (; e > g && b > 1;) try {
                    d.push("array" === f || "nodebuffer" === f ? String.fromCharCode.apply(null, a.slice(g, Math.min(g + b, e))) : String.fromCharCode.apply(null, a.subarray(g, Math.min(g + b, e)))), g += b
                } catch (i) {
                    b = Math.floor(b / 2)
                }
                return d.join("")
            }

            function g(a, b) {
                for (var c = 0; c < a.length; c++) b[c] = a[c];
                return b
            }

            var h = a("./support"), i = a("./compressions"), j = a("./nodeBuffer");
            c.string2binary = function (a) {
                for (var b = "", c = 0; c < a.length; c++) b += String.fromCharCode(255 & a.charCodeAt(c));
                return b
            }, c.arrayBuffer2Blob = function (a) {
                c.checkSupport("blob");
                try {
                    return new Blob([a], {type: "application/zip"})
                } catch (b) {
                    try {
                        var d = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
                            e = new d;
                        return e.append(a), e.getBlob("application/zip")
                    } catch (b) {
                        throw new Error("Bug : can't construct the Blob.")
                    }
                }
            }, c.applyFromCharCode = f;
            var k = {};
            k.string = {
                string: d, array: function (a) {
                    return e(a, new Array(a.length))
                }, arraybuffer: function (a) {
                    return k.string.uint8array(a).buffer
                }, uint8array: function (a) {
                    return e(a, new Uint8Array(a.length))
                }, nodebuffer: function (a) {
                    return e(a, j(a.length))
                }
            }, k.array = {
                string: f, array: d, arraybuffer: function (a) {
                    return new Uint8Array(a).buffer
                }, uint8array: function (a) {
                    return new Uint8Array(a)
                }, nodebuffer: function (a) {
                    return j(a)
                }
            }, k.arraybuffer = {
                string: function (a) {
                    return f(new Uint8Array(a))
                }, array: function (a) {
                    return g(new Uint8Array(a), new Array(a.byteLength))
                }, arraybuffer: d, uint8array: function (a) {
                    return new Uint8Array(a)
                }, nodebuffer: function (a) {
                    return j(new Uint8Array(a))
                }
            }, k.uint8array = {
                string: f, array: function (a) {
                    return g(a, new Array(a.length))
                }, arraybuffer: function (a) {
                    return a.buffer
                }, uint8array: d, nodebuffer: function (a) {
                    return j(a)
                }
            }, k.nodebuffer = {
                string: f, array: function (a) {
                    return g(a, new Array(a.length))
                }, arraybuffer: function (a) {
                    return k.nodebuffer.uint8array(a).buffer
                }, uint8array: function (a) {
                    return g(a, new Uint8Array(a.length))
                }, nodebuffer: d
            }, c.transformTo = function (a, b) {
                if (b || (b = ""), !a) return b;
                c.checkSupport(a);
                var d = c.getTypeOf(b), e = k[d][a](b);
                return e
            }, c.getTypeOf = function (a) {
                return "string" == typeof a ? "string" : "[object Array]" === Object.prototype.toString.call(a) ? "array" : h.nodebuffer && j.test(a) ? "nodebuffer" : h.uint8array && a instanceof Uint8Array ? "uint8array" : h.arraybuffer && a instanceof ArrayBuffer ? "arraybuffer" : void 0
            }, c.checkSupport = function (a) {
                var b = h[a.toLowerCase()];
                if (!b) throw new Error(a + " is not supported by this browser")
            }, c.MAX_VALUE_16BITS = 65535, c.MAX_VALUE_32BITS = -1, c.pretty = function (a) {
                var b, c, d = "";
                for (c = 0; c < (a || "").length; c++) b = a.charCodeAt(c), d += "\\x" + (16 > b ? "0" : "") + b.toString(16).toUpperCase();
                return d
            }, c.findCompression = function (a) {
                for (var b in i) if (i.hasOwnProperty(b) && i[b].magic === a) return i[b];
                return null
            }, c.isRegExp = function (a) {
                return "[object RegExp]" === Object.prototype.toString.call(a)
            }
        }, {"./compressions": 3, "./nodeBuffer": 11, "./support": 17}],
        22: [function (a, b) {
            "use strict";

            function c(a, b) {
                this.files = [], this.loadOptions = b, a && this.load(a)
            }

            var d = a("./stringReader"), e = a("./nodeBufferReader"), f = a("./uint8ArrayReader"), g = a("./utils"),
                h = a("./signature"), i = a("./zipEntry"), j = a("./support"), k = a("./object");
            c.prototype = {
                checkSignature: function (a) {
                    var b = this.reader.readString(4);
                    if (b !== a) throw new Error("Corrupted zip or bug : unexpected signature (" + g.pretty(b) + ", expected " + g.pretty(a) + ")")
                }, readBlockEndOfCentral: function () {
                    this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2), this.zipComment = this.reader.readString(this.zipCommentLength), this.zipComment = k.utf8decode(this.zipComment)
                }, readBlockZip64EndOfCentral: function () {
                    this.zip64EndOfCentralSize = this.reader.readInt(8), this.versionMadeBy = this.reader.readString(2), this.versionNeeded = this.reader.readInt(2), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                    for (var a, b, c, d = this.zip64EndOfCentralSize - 44, e = 0; d > e;) a = this.reader.readInt(2), b = this.reader.readInt(4), c = this.reader.readString(b), this.zip64ExtensibleData[a] = {
                        id: a,
                        length: b,
                        value: c
                    }
                }, readBlockZip64EndOfCentralLocator: function () {
                    if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1) throw new Error("Multi-volumes zip are not supported")
                }, readLocalFiles: function () {
                    var a, b;
                    for (a = 0; a < this.files.length; a++) b = this.files[a], this.reader.setIndex(b.localHeaderOffset), this.checkSignature(h.LOCAL_FILE_HEADER), b.readLocalPart(this.reader), b.handleUTF8()
                }, readCentralDir: function () {
                    var a;
                    for (this.reader.setIndex(this.centralDirOffset); this.reader.readString(4) === h.CENTRAL_FILE_HEADER;) a = new i({zip64: this.zip64}, this.loadOptions), a.readCentralPart(this.reader), this.files.push(a)
                }, readEndOfCentral: function () {
                    var a = this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);
                    if (-1 === a) throw new Error("Corrupted zip : can't find end of central directory");
                    if (this.reader.setIndex(a), this.checkSignature(h.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === g.MAX_VALUE_16BITS || this.diskWithCentralDirStart === g.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === g.MAX_VALUE_16BITS || this.centralDirRecords === g.MAX_VALUE_16BITS || this.centralDirSize === g.MAX_VALUE_32BITS || this.centralDirOffset === g.MAX_VALUE_32BITS) {
                        if (this.zip64 = !0, a = this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR), -1 === a) throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
                        this.reader.setIndex(a), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral()
                    }
                }, prepareReader: function (a) {
                    var b = g.getTypeOf(a);
                    this.reader = "string" !== b || j.uint8array ? "nodebuffer" === b ? new e(a) : new f(g.transformTo("uint8array", a)) : new d(a, this.loadOptions.optimizedBinaryString)
                }, load: function (a) {
                    this.prepareReader(a), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles()
                }
            }, b.exports = c
        }, {
            "./nodeBufferReader": 12,
            "./object": 13,
            "./signature": 14,
            "./stringReader": 15,
            "./support": 17,
            "./uint8ArrayReader": 18,
            "./utils": 21,
            "./zipEntry": 23
        }],
        23: [function (a, b) {
            "use strict";

            function c(a, b) {
                this.options = a, this.loadOptions = b
            }

            var d = a("./stringReader"), e = a("./utils"), f = a("./compressedObject"), g = a("./object");
            c.prototype = {
                isEncrypted: function () {
                    return 1 === (1 & this.bitFlag)
                }, useUTF8: function () {
                    return 2048 === (2048 & this.bitFlag)
                }, prepareCompressedContent: function (a, b, c) {
                    return function () {
                        var d = a.index;
                        a.setIndex(b);
                        var e = a.readData(c);
                        return a.setIndex(d), e
                    }
                }, prepareContent: function (a, b, c, d, f) {
                    return function () {
                        var a = e.transformTo(d.uncompressInputType, this.getCompressedContent()),
                            b = d.uncompress(a);
                        if (b.length !== f) throw new Error("Bug : uncompressed data size mismatch");
                        return b
                    }
                }, readLocalPart: function (a) {
                    var b, c;
                    if (a.skip(22), this.fileNameLength = a.readInt(2), c = a.readInt(2), this.fileName = a.readString(this.fileNameLength), a.skip(c), -1 == this.compressedSize || -1 == this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");
                    if (b = e.findCompression(this.compressionMethod), null === b) throw new Error("Corrupted zip : compression " + e.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")");
                    if (this.decompressed = new f, this.decompressed.compressedSize = this.compressedSize, this.decompressed.uncompressedSize = this.uncompressedSize, this.decompressed.crc32 = this.crc32, this.decompressed.compressionMethod = this.compressionMethod, this.decompressed.getCompressedContent = this.prepareCompressedContent(a, a.index, this.compressedSize, b), this.decompressed.getContent = this.prepareContent(a, a.index, this.compressedSize, b, this.uncompressedSize), this.loadOptions.checkCRC32 && (this.decompressed = e.transformTo("string", this.decompressed.getContent()), g.crc32(this.decompressed) !== this.crc32)) throw new Error("Corrupted zip : CRC32 mismatch")
                }, readCentralPart: function (a) {
                    if (this.versionMadeBy = a.readString(2), this.versionNeeded = a.readInt(2), this.bitFlag = a.readInt(2), this.compressionMethod = a.readString(2), this.date = a.readDate(), this.crc32 = a.readInt(4), this.compressedSize = a.readInt(4), this.uncompressedSize = a.readInt(4), this.fileNameLength = a.readInt(2), this.extraFieldsLength = a.readInt(2), this.fileCommentLength = a.readInt(2), this.diskNumberStart = a.readInt(2), this.internalFileAttributes = a.readInt(2), this.externalFileAttributes = a.readInt(4), this.localHeaderOffset = a.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                    this.fileName = a.readString(this.fileNameLength), this.readExtraFields(a), this.parseZIP64ExtraField(a), this.fileComment = a.readString(this.fileCommentLength), this.dir = 16 & this.externalFileAttributes ? !0 : !1
                }, parseZIP64ExtraField: function () {
                    if (this.extraFields[1]) {
                        var a = new d(this.extraFields[1].value);
                        this.uncompressedSize === e.MAX_VALUE_32BITS && (this.uncompressedSize = a.readInt(8)), this.compressedSize === e.MAX_VALUE_32BITS && (this.compressedSize = a.readInt(8)), this.localHeaderOffset === e.MAX_VALUE_32BITS && (this.localHeaderOffset = a.readInt(8)), this.diskNumberStart === e.MAX_VALUE_32BITS && (this.diskNumberStart = a.readInt(4))
                    }
                }, readExtraFields: function (a) {
                    var b, c, d, e = a.index;
                    for (this.extraFields = this.extraFields || {}; a.index < e + this.extraFieldsLength;) b = a.readInt(2), c = a.readInt(2), d = a.readString(c), this.extraFields[b] = {
                        id: b,
                        length: c,
                        value: d
                    }
                }, handleUTF8: function () {
                    if (this.useUTF8()) this.fileName = g.utf8decode(this.fileName), this.fileComment = g.utf8decode(this.fileComment); else {
                        var a = this.findExtraFieldUnicodePath();
                        null !== a && (this.fileName = a);
                        var b = this.findExtraFieldUnicodeComment();
                        null !== b && (this.fileComment = b)
                    }
                }, findExtraFieldUnicodePath: function () {
                    var a = this.extraFields[28789];
                    if (a) {
                        var b = new d(a.value);
                        return 1 !== b.readInt(1) ? null : g.crc32(this.fileName) !== b.readInt(4) ? null : g.utf8decode(b.readString(a.length - 5))
                    }
                    return null
                }, findExtraFieldUnicodeComment: function () {
                    var a = this.extraFields[25461];
                    if (a) {
                        var b = new d(a.value);
                        return 1 !== b.readInt(1) ? null : g.crc32(this.fileComment) !== b.readInt(4) ? null : g.utf8decode(b.readString(a.length - 5))
                    }
                    return null
                }
            }, b.exports = c
        }, {"./compressedObject": 2, "./object": 13, "./stringReader": 15, "./utils": 21}],
        24: [function (a, b) {
            "use strict";
            var c = a("./lib/utils/common").assign, d = a("./lib/deflate"), e = a("./lib/inflate"),
                f = a("./lib/zlib/constants"), g = {};
            c(g, d, e, f), b.exports = g
        }, {"./lib/deflate": 25, "./lib/inflate": 26, "./lib/utils/common": 27, "./lib/zlib/constants": 30}],
        25: [function (a, b, c) {
            "use strict";

            function d(a, b) {
                var c = new s(b);
                if (c.push(a, !0), c.err) throw c.msg;
                return c.result
            }

            function e(a, b) {
                return b = b || {}, b.raw = !0, d(a, b)
            }

            function f(a, b) {
                return b = b || {}, b.gzip = !0, d(a, b)
            }

            var g = a("./zlib/deflate.js"), h = a("./utils/common"), i = a("./utils/strings"),
                j = a("./zlib/messages"), k = a("./zlib/zstream"), l = 0, m = 4, n = 0, o = 1, p = -1, q = 0, r = 8,
                s = function (a) {
                    this.options = h.assign({
                        level: p,
                        method: r,
                        chunkSize: 16384,
                        windowBits: 15,
                        memLevel: 8,
                        strategy: q,
                        to: ""
                    }, a || {});
                    var b = this.options;
                    b.raw && b.windowBits > 0 ? b.windowBits = -b.windowBits : b.gzip && b.windowBits > 0 && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new k, this.strm.avail_out = 0;
                    var c = g.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);
                    if (c !== n) throw new Error(j[c]);
                    b.header && g.deflateSetHeader(this.strm, b.header)
                };
            s.prototype.push = function (a, b) {
                var c, d, e = this.strm, f = this.options.chunkSize;
                if (this.ended) return !1;
                d = b === ~~b ? b : b === !0 ? m : l, e.input = "string" == typeof a ? i.string2buf(a) : a, e.next_in = 0, e.avail_in = e.input.length;
                do {
                    if (0 === e.avail_out && (e.output = new h.Buf8(f), e.next_out = 0, e.avail_out = f), c = g.deflate(e, d), c !== o && c !== n) return this.onEnd(c), this.ended = !0, !1;
                    (0 === e.avail_out || 0 === e.avail_in && d === m) && this.onData("string" === this.options.to ? i.buf2binstring(h.shrinkBuf(e.output, e.next_out)) : h.shrinkBuf(e.output, e.next_out))
                } while ((e.avail_in > 0 || 0 === e.avail_out) && c !== o);
                return d === m ? (c = g.deflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === n) : !0
            }, s.prototype.onData = function (a) {
                this.chunks.push(a)
            }, s.prototype.onEnd = function (a) {
                a === n && (this.result = "string" === this.options.to ? this.chunks.join("") : h.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg
            }, c.Deflate = s, c.deflate = d, c.deflateRaw = e, c.gzip = f
        }, {
            "./utils/common": 27,
            "./utils/strings": 28,
            "./zlib/deflate.js": 32,
            "./zlib/messages": 37,
            "./zlib/zstream": 39
        }],
        26: [function (a, b, c) {
            "use strict";

            function d(a, b) {
                var c = new m(b);
                if (c.push(a, !0), c.err) throw c.msg;
                return c.result
            }

            function e(a, b) {
                return b = b || {}, b.raw = !0, d(a, b)
            }

            var f = a("./zlib/inflate.js"), g = a("./utils/common"), h = a("./utils/strings"),
                i = a("./zlib/constants"), j = a("./zlib/messages"), k = a("./zlib/zstream"),
                l = a("./zlib/gzheader"), m = function (a) {
                    this.options = g.assign({chunkSize: 16384, windowBits: 0, to: ""}, a || {});
                    var b = this.options;
                    b.raw && b.windowBits >= 0 && b.windowBits < 16 && (b.windowBits = -b.windowBits, 0 === b.windowBits && (b.windowBits = -15)), !(b.windowBits >= 0 && b.windowBits < 16) || a && a.windowBits || (b.windowBits += 32), b.windowBits > 15 && b.windowBits < 48 && 0 === (15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new k, this.strm.avail_out = 0;
                    var c = f.inflateInit2(this.strm, b.windowBits);
                    if (c !== i.Z_OK) throw new Error(j[c]);
                    this.header = new l, f.inflateGetHeader(this.strm, this.header)
                };
            m.prototype.push = function (a, b) {
                var c, d, e, j, k, l = this.strm, m = this.options.chunkSize;
                if (this.ended) return !1;
                d = b === ~~b ? b : b === !0 ? i.Z_FINISH : i.Z_NO_FLUSH, l.input = "string" == typeof a ? h.binstring2buf(a) : a, l.next_in = 0, l.avail_in = l.input.length;
                do {
                    if (0 === l.avail_out && (l.output = new g.Buf8(m), l.next_out = 0, l.avail_out = m), c = f.inflate(l, i.Z_NO_FLUSH), c !== i.Z_STREAM_END && c !== i.Z_OK) return this.onEnd(c), this.ended = !0, !1;
                    l.next_out && (0 === l.avail_out || c === i.Z_STREAM_END || 0 === l.avail_in && d === i.Z_FINISH) && ("string" === this.options.to ? (e = h.utf8border(l.output, l.next_out), j = l.next_out - e, k = h.buf2string(l.output, e), l.next_out = j, l.avail_out = m - j, j && g.arraySet(l.output, l.output, e, j, 0), this.onData(k)) : this.onData(g.shrinkBuf(l.output, l.next_out)))
                } while (l.avail_in > 0 && c !== i.Z_STREAM_END);
                return c === i.Z_STREAM_END && (d = i.Z_FINISH), d === i.Z_FINISH ? (c = f.inflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === i.Z_OK) : !0
            }, m.prototype.onData = function (a) {
                this.chunks.push(a)
            }, m.prototype.onEnd = function (a) {
                a === i.Z_OK && (this.result = "string" === this.options.to ? this.chunks.join("") : g.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg
            }, c.Inflate = m, c.inflate = d, c.inflateRaw = e, c.ungzip = d
        }, {
            "./utils/common": 27,
            "./utils/strings": 28,
            "./zlib/constants": 30,
            "./zlib/gzheader": 33,
            "./zlib/inflate.js": 35,
            "./zlib/messages": 37,
            "./zlib/zstream": 39
        }],
        27: [function (a, b, c) {
            "use strict";
            var d = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
            c.assign = function (a) {
                for (var b = Array.prototype.slice.call(arguments, 1); b.length;) {
                    var c = b.shift();
                    if (c) {
                        if ("object" != typeof c) throw new TypeError(c + "must be non-object");
                        for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d])
                    }
                }
                return a
            }, c.shrinkBuf = function (a, b) {
                return a.length === b ? a : a.subarray ? a.subarray(0, b) : (a.length = b, a)
            };
            var e = {
                arraySet: function (a, b, c, d, e) {
                    if (b.subarray && a.subarray) return void a.set(b.subarray(c, c + d), e);
                    for (var f = 0; d > f; f++) a[e + f] = b[c + f]
                }, flattenChunks: function (a) {
                    var b, c, d, e, f, g;
                    for (d = 0, b = 0, c = a.length; c > b; b++) d += a[b].length;
                    for (g = new Uint8Array(d), e = 0, b = 0, c = a.length; c > b; b++) f = a[b], g.set(f, e), e += f.length;
                    return g
                }
            }, f = {
                arraySet: function (a, b, c, d, e) {
                    for (var f = 0; d > f; f++) a[e + f] = b[c + f]
                }, flattenChunks: function (a) {
                    return [].concat.apply([], a)
                }
            };
            c.setTyped = function (a) {
                a ? (c.Buf8 = Uint8Array, c.Buf16 = Uint16Array, c.Buf32 = Int32Array, c.assign(c, e)) : (c.Buf8 = Array, c.Buf16 = Array, c.Buf32 = Array, c.assign(c, f))
            }, c.setTyped(d)
        }, {}],
        28: [function (a, b, c) {
            "use strict";

            function d(a, b) {
                if (65537 > b && (a.subarray && g || !a.subarray && f)) return String.fromCharCode.apply(null, e.shrinkBuf(a, b));
                for (var c = "", d = 0; b > d; d++) c += String.fromCharCode(a[d]);
                return c
            }

            var e = a("./common"), f = !0, g = !0;
            try {
                String.fromCharCode.apply(null, [0])
            } catch (h) {
                f = !1
            }
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (h) {
                g = !1
            }
            for (var i = new e.Buf8(256), j = 0; 256 > j; j++) i[j] = j >= 252 ? 6 : j >= 248 ? 5 : j >= 240 ? 4 : j >= 224 ? 3 : j >= 192 ? 2 : 1;
            i[254] = i[254] = 1, c.string2buf = function (a) {
                var b, c, d, f, g, h = a.length, i = 0;
                for (f = 0; h > f; f++) c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), i += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
                for (b = new e.Buf8(i), g = 0, f = 0; i > g; f++) c = a.charCodeAt(f), 55296 === (64512 & c) && h > f + 1 && (d = a.charCodeAt(f + 1), 56320 === (64512 & d) && (c = 65536 + (c - 55296 << 10) + (d - 56320), f++)), 128 > c ? b[g++] = c : 2048 > c ? (b[g++] = 192 | c >>> 6, b[g++] = 128 | 63 & c) : 65536 > c ? (b[g++] = 224 | c >>> 12, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c) : (b[g++] = 240 | c >>> 18, b[g++] = 128 | c >>> 12 & 63, b[g++] = 128 | c >>> 6 & 63, b[g++] = 128 | 63 & c);
                return b
            }, c.buf2binstring = function (a) {
                return d(a, a.length)
            }, c.binstring2buf = function (a) {
                for (var b = new e.Buf8(a.length), c = 0, d = b.length; d > c; c++) b[c] = a.charCodeAt(c);
                return b
            }, c.buf2string = function (a, b) {
                var c, e, f, g, h = b || a.length, j = new Array(2 * h);
                for (e = 0, c = 0; h > c;) if (f = a[c++], 128 > f) j[e++] = f; else if (g = i[f], g > 4) j[e++] = 65533, c += g - 1; else {
                    for (f &= 2 === g ? 31 : 3 === g ? 15 : 7; g > 1 && h > c;) f = f << 6 | 63 & a[c++], g--;
                    g > 1 ? j[e++] = 65533 : 65536 > f ? j[e++] = f : (f -= 65536, j[e++] = 55296 | f >> 10 & 1023, j[e++] = 56320 | 1023 & f)
                }
                return d(j, e)
            }, c.utf8border = function (a, b) {
                var c;
                for (b = b || a.length, b > a.length && (b = a.length), c = b - 1; c >= 0 && 128 === (192 & a[c]);) c--;
                return 0 > c ? b : 0 === c ? b : c + i[a[c]] > b ? c : b
            }
        }, {"./common": 27}],
        29: [function (a, b) {
            "use strict";

            function c(a, b, c, d) {
                for (var e = 65535 & a | 0, f = a >>> 16 & 65535 | 0, g = 0; 0 !== c;) {
                    g = c > 2e3 ? 2e3 : c, c -= g;
                    do e = e + b[d++] | 0, f = f + e | 0; while (--g);
                    e %= 65521, f %= 65521
                }
                return e | f << 16 | 0
            }

            b.exports = c
        }, {}],
        30: [function (a, b) {
            b.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            }
        }, {}],
        31: [function (a, b) {
            "use strict";

            function c() {
                for (var a, b = [], c = 0; 256 > c; c++) {
                    a = c;
                    for (var d = 0; 8 > d; d++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
                    b[c] = a
                }
                return b
            }

            function d(a, b, c, d) {
                var f = e, g = d + c;
                a = -1 ^ a;
                for (var h = d; g > h; h++) a = a >>> 8 ^ f[255 & (a ^ b[h])];
                return -1 ^ a
            }

            var e = c();
            b.exports = d
        }, {}],
        32: [function (a, b, c) {
            "use strict";

            function d(a, b) {
                return a.msg = G[b], b
            }

            function e(a) {
                return (a << 1) - (a > 4 ? 9 : 0)
            }

            function f(a) {
                for (var b = a.length; --b >= 0;) a[b] = 0
            }

            function g(a) {
                var b = a.state, c = b.pending;
                c > a.avail_out && (c = a.avail_out), 0 !== c && (C.arraySet(a.output, b.pending_buf, b.pending_out, c, a.next_out), a.next_out += c, b.pending_out += c, a.total_out += c, a.avail_out -= c, b.pending -= c, 0 === b.pending && (b.pending_out = 0))
            }

            function h(a, b) {
                D._tr_flush_block(a, a.block_start >= 0 ? a.block_start : -1, a.strstart - a.block_start, b), a.block_start = a.strstart, g(a.strm)
            }

            function i(a, b) {
                a.pending_buf[a.pending++] = b
            }

            function j(a, b) {
                a.pending_buf[a.pending++] = b >>> 8 & 255, a.pending_buf[a.pending++] = 255 & b
            }

            function k(a, b, c, d) {
                var e = a.avail_in;
                return e > d && (e = d), 0 === e ? 0 : (a.avail_in -= e, C.arraySet(b, a.input, a.next_in, e, c), 1 === a.state.wrap ? a.adler = E(a.adler, b, e, c) : 2 === a.state.wrap && (a.adler = F(a.adler, b, e, c)), a.next_in += e, a.total_in += e, e)
            }

            function l(a, b) {
                var c, d, e = a.max_chain_length, f = a.strstart, g = a.prev_length, h = a.nice_match,
                    i = a.strstart > a.w_size - jb ? a.strstart - (a.w_size - jb) : 0, j = a.window, k = a.w_mask,
                    l = a.prev, m = a.strstart + ib, n = j[f + g - 1], o = j[f + g];
                a.prev_length >= a.good_match && (e >>= 2), h > a.lookahead && (h = a.lookahead);
                do if (c = b, j[c + g] === o && j[c + g - 1] === n && j[c] === j[f] && j[++c] === j[f + 1]) {
                    f += 2, c++;
                    do ; while (j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && j[++f] === j[++c] && m > f);
                    if (d = ib - (m - f), f = m - ib, d > g) {
                        if (a.match_start = b, g = d, d >= h) break;
                        n = j[f + g - 1], o = j[f + g]
                    }
                } while ((b = l[b & k]) > i && 0 !== --e);
                return g <= a.lookahead ? g : a.lookahead
            }

            function m(a) {
                var b, c, d, e, f, g = a.w_size;
                do {
                    if (e = a.window_size - a.lookahead - a.strstart, a.strstart >= g + (g - jb)) {
                        C.arraySet(a.window, a.window, g, g, 0), a.match_start -= g, a.strstart -= g, a.block_start -= g, c = a.hash_size, b = c;
                        do d = a.head[--b], a.head[b] = d >= g ? d - g : 0; while (--c);
                        c = g, b = c;
                        do d = a.prev[--b], a.prev[b] = d >= g ? d - g : 0; while (--c);
                        e += g
                    }
                    if (0 === a.strm.avail_in) break;
                    if (c = k(a.strm, a.window, a.strstart + a.lookahead, e), a.lookahead += c, a.lookahead + a.insert >= hb) for (f = a.strstart - a.insert, a.ins_h = a.window[f], a.ins_h = (a.ins_h << a.hash_shift ^ a.window[f + 1]) & a.hash_mask; a.insert && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[f + hb - 1]) & a.hash_mask, a.prev[f & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = f, f++, a.insert--, !(a.lookahead + a.insert < hb));) ;
                } while (a.lookahead < jb && 0 !== a.strm.avail_in)
            }

            function n(a, b) {
                var c = 65535;
                for (c > a.pending_buf_size - 5 && (c = a.pending_buf_size - 5); ;) {
                    if (a.lookahead <= 1) {
                        if (m(a), 0 === a.lookahead && b === H) return sb;
                        if (0 === a.lookahead) break
                    }
                    a.strstart += a.lookahead, a.lookahead = 0;
                    var d = a.block_start + c;
                    if ((0 === a.strstart || a.strstart >= d) && (a.lookahead = a.strstart - d, a.strstart = d, h(a, !1), 0 === a.strm.avail_out)) return sb;
                    if (a.strstart - a.block_start >= a.w_size - jb && (h(a, !1), 0 === a.strm.avail_out)) return sb
                }
                return a.insert = 0, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.strstart > a.block_start && (h(a, !1), 0 === a.strm.avail_out) ? sb : sb
            }

            function o(a, b) {
                for (var c, d; ;) {
                    if (a.lookahead < jb) {
                        if (m(a), a.lookahead < jb && b === H) return sb;
                        if (0 === a.lookahead) break
                    }
                    if (c = 0, a.lookahead >= hb && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), 0 !== c && a.strstart - c <= a.w_size - jb && (a.match_length = l(a, c)), a.match_length >= hb) if (d = D._tr_tally(a, a.strstart - a.match_start, a.match_length - hb), a.lookahead -= a.match_length, a.match_length <= a.max_lazy_match && a.lookahead >= hb) {
                        a.match_length--;
                        do a.strstart++, a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart; while (0 !== --a.match_length);
                        a.strstart++
                    } else a.strstart += a.match_length, a.match_length = 0, a.ins_h = a.window[a.strstart], a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + 1]) & a.hash_mask; else d = D._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++;
                    if (d && (h(a, !1), 0 === a.strm.avail_out)) return sb
                }
                return a.insert = a.strstart < hb - 1 ? a.strstart : hb - 1, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb
            }

            function p(a, b) {
                for (var c, d, e; ;) {
                    if (a.lookahead < jb) {
                        if (m(a), a.lookahead < jb && b === H) return sb;
                        if (0 === a.lookahead) break
                    }
                    if (c = 0, a.lookahead >= hb && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), a.prev_length = a.match_length, a.prev_match = a.match_start, a.match_length = hb - 1, 0 !== c && a.prev_length < a.max_lazy_match && a.strstart - c <= a.w_size - jb && (a.match_length = l(a, c), a.match_length <= 5 && (a.strategy === S || a.match_length === hb && a.strstart - a.match_start > 4096) && (a.match_length = hb - 1)), a.prev_length >= hb && a.match_length <= a.prev_length) {
                        e = a.strstart + a.lookahead - hb, d = D._tr_tally(a, a.strstart - 1 - a.prev_match, a.prev_length - hb), a.lookahead -= a.prev_length - 1, a.prev_length -= 2;
                        do ++a.strstart <= e && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window[a.strstart + hb - 1]) & a.hash_mask, c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart); while (0 !== --a.prev_length);
                        if (a.match_available = 0, a.match_length = hb - 1, a.strstart++, d && (h(a, !1), 0 === a.strm.avail_out)) return sb
                    } else if (a.match_available) {
                        if (d = D._tr_tally(a, 0, a.window[a.strstart - 1]), d && h(a, !1), a.strstart++, a.lookahead--, 0 === a.strm.avail_out) return sb
                    } else a.match_available = 1, a.strstart++, a.lookahead--
                }
                return a.match_available && (d = D._tr_tally(a, 0, a.window[a.strstart - 1]), a.match_available = 0), a.insert = a.strstart < hb - 1 ? a.strstart : hb - 1, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb
            }

            function q(a, b) {
                for (var c, d, e, f, g = a.window; ;) {
                    if (a.lookahead <= ib) {
                        if (m(a), a.lookahead <= ib && b === H) return sb;
                        if (0 === a.lookahead) break
                    }
                    if (a.match_length = 0, a.lookahead >= hb && a.strstart > 0 && (e = a.strstart - 1, d = g[e], d === g[++e] && d === g[++e] && d === g[++e])) {
                        f = a.strstart + ib;
                        do ; while (d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && d === g[++e] && f > e);
                        a.match_length = ib - (f - e), a.match_length > a.lookahead && (a.match_length = a.lookahead)
                    }
                    if (a.match_length >= hb ? (c = D._tr_tally(a, 1, a.match_length - hb), a.lookahead -= a.match_length, a.strstart += a.match_length, a.match_length = 0) : (c = D._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++), c && (h(a, !1), 0 === a.strm.avail_out)) return sb
                }
                return a.insert = 0, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb
            }

            function r(a, b) {
                for (var c; ;) {
                    if (0 === a.lookahead && (m(a), 0 === a.lookahead)) {
                        if (b === H) return sb;
                        break
                    }
                    if (a.match_length = 0, c = D._tr_tally(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++, c && (h(a, !1), 0 === a.strm.avail_out)) return sb
                }
                return a.insert = 0, b === K ? (h(a, !0), 0 === a.strm.avail_out ? ub : vb) : a.last_lit && (h(a, !1), 0 === a.strm.avail_out) ? sb : tb
            }

            function s(a) {
                a.window_size = 2 * a.w_size, f(a.head), a.max_lazy_match = B[a.level].max_lazy, a.good_match = B[a.level].good_length, a.nice_match = B[a.level].nice_length, a.max_chain_length = B[a.level].max_chain, a.strstart = 0, a.block_start = 0, a.lookahead = 0, a.insert = 0, a.match_length = a.prev_length = hb - 1, a.match_available = 0, a.ins_h = 0
            }

            function t() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Y, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new C.Buf16(2 * fb), this.dyn_dtree = new C.Buf16(2 * (2 * db + 1)), this.bl_tree = new C.Buf16(2 * (2 * eb + 1)), f(this.dyn_ltree), f(this.dyn_dtree), f(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new C.Buf16(gb + 1), this.heap = new C.Buf16(2 * cb + 1), f(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new C.Buf16(2 * cb + 1), f(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
            }

            function u(a) {
                var b;
                return a && a.state ? (a.total_in = a.total_out = 0, a.data_type = X, b = a.state, b.pending = 0, b.pending_out = 0, b.wrap < 0 && (b.wrap = -b.wrap), b.status = b.wrap ? lb : qb, a.adler = 2 === b.wrap ? 0 : 1, b.last_flush = H, D._tr_init(b), M) : d(a, O)
            }

            function v(a) {
                var b = u(a);
                return b === M && s(a.state), b
            }

            function w(a, b) {
                return a && a.state ? 2 !== a.state.wrap ? O : (a.state.gzhead = b, M) : O
            }

            function x(a, b, c, e, f, g) {
                if (!a) return O;
                var h = 1;
                if (b === R && (b = 6), 0 > e ? (h = 0, e = -e) : e > 15 && (h = 2, e -= 16), 1 > f || f > Z || c !== Y || 8 > e || e > 15 || 0 > b || b > 9 || 0 > g || g > V) return d(a, O);
                8 === e && (e = 9);
                var i = new t;
                return a.state = i, i.strm = a, i.wrap = h, i.gzhead = null, i.w_bits = e, i.w_size = 1 << i.w_bits, i.w_mask = i.w_size - 1, i.hash_bits = f + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size - 1, i.hash_shift = ~~((i.hash_bits + hb - 1) / hb), i.window = new C.Buf8(2 * i.w_size), i.head = new C.Buf16(i.hash_size), i.prev = new C.Buf16(i.w_size), i.lit_bufsize = 1 << f + 6, i.pending_buf_size = 4 * i.lit_bufsize, i.pending_buf = new C.Buf8(i.pending_buf_size), i.d_buf = i.lit_bufsize >> 1, i.l_buf = 3 * i.lit_bufsize, i.level = b, i.strategy = g, i.method = c, v(a)
            }

            function y(a, b) {
                return x(a, b, Y, $, _, W)
            }

            function z(a, b) {
                var c, h, k, l;
                if (!a || !a.state || b > L || 0 > b) return a ? d(a, O) : O;
                if (h = a.state, !a.output || !a.input && 0 !== a.avail_in || h.status === rb && b !== K) return d(a, 0 === a.avail_out ? Q : O);
                if (h.strm = a, c = h.last_flush, h.last_flush = b, h.status === lb) if (2 === h.wrap) a.adler = 0, i(h, 31), i(h, 139), i(h, 8), h.gzhead ? (i(h, (h.gzhead.text ? 1 : 0) + (h.gzhead.hcrc ? 2 : 0) + (h.gzhead.extra ? 4 : 0) + (h.gzhead.name ? 8 : 0) + (h.gzhead.comment ? 16 : 0)), i(h, 255 & h.gzhead.time), i(h, h.gzhead.time >> 8 & 255), i(h, h.gzhead.time >> 16 & 255), i(h, h.gzhead.time >> 24 & 255), i(h, 9 === h.level ? 2 : h.strategy >= T || h.level < 2 ? 4 : 0), i(h, 255 & h.gzhead.os), h.gzhead.extra && h.gzhead.extra.length && (i(h, 255 & h.gzhead.extra.length), i(h, h.gzhead.extra.length >> 8 & 255)), h.gzhead.hcrc && (a.adler = F(a.adler, h.pending_buf, h.pending, 0)), h.gzindex = 0, h.status = mb) : (i(h, 0), i(h, 0), i(h, 0), i(h, 0), i(h, 0), i(h, 9 === h.level ? 2 : h.strategy >= T || h.level < 2 ? 4 : 0), i(h, wb), h.status = qb); else {
                    var m = Y + (h.w_bits - 8 << 4) << 8, n = -1;
                    n = h.strategy >= T || h.level < 2 ? 0 : h.level < 6 ? 1 : 6 === h.level ? 2 : 3, m |= n << 6, 0 !== h.strstart && (m |= kb), m += 31 - m % 31, h.status = qb, j(h, m), 0 !== h.strstart && (j(h, a.adler >>> 16), j(h, 65535 & a.adler)), a.adler = 1
                }
                if (h.status === mb) if (h.gzhead.extra) {
                    for (k = h.pending; h.gzindex < (65535 & h.gzhead.extra.length) && (h.pending !== h.pending_buf_size || (h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending !== h.pending_buf_size));) i(h, 255 & h.gzhead.extra[h.gzindex]), h.gzindex++;
                    h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), h.gzindex === h.gzhead.extra.length && (h.gzindex = 0, h.status = nb)
                } else h.status = nb;
                if (h.status === nb) if (h.gzhead.name) {
                    k = h.pending;
                    do {
                        if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending === h.pending_buf_size)) {
                            l = 1;
                            break
                        }
                        l = h.gzindex < h.gzhead.name.length ? 255 & h.gzhead.name.charCodeAt(h.gzindex++) : 0, i(h, l)
                    } while (0 !== l);
                    h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), 0 === l && (h.gzindex = 0, h.status = ob)
                } else h.status = ob;
                if (h.status === ob) if (h.gzhead.comment) {
                    k = h.pending;
                    do {
                        if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), g(a), k = h.pending, h.pending === h.pending_buf_size)) {
                            l = 1;
                            break
                        }
                        l = h.gzindex < h.gzhead.comment.length ? 255 & h.gzhead.comment.charCodeAt(h.gzindex++) : 0, i(h, l)
                    } while (0 !== l);
                    h.gzhead.hcrc && h.pending > k && (a.adler = F(a.adler, h.pending_buf, h.pending - k, k)), 0 === l && (h.status = pb)
                } else h.status = pb;
                if (h.status === pb && (h.gzhead.hcrc ? (h.pending + 2 > h.pending_buf_size && g(a), h.pending + 2 <= h.pending_buf_size && (i(h, 255 & a.adler), i(h, a.adler >> 8 & 255), a.adler = 0, h.status = qb)) : h.status = qb), 0 !== h.pending) {
                    if (g(a), 0 === a.avail_out) return h.last_flush = -1, M
                } else if (0 === a.avail_in && e(b) <= e(c) && b !== K) return d(a, Q);
                if (h.status === rb && 0 !== a.avail_in) return d(a, Q);
                if (0 !== a.avail_in || 0 !== h.lookahead || b !== H && h.status !== rb) {
                    var o = h.strategy === T ? r(h, b) : h.strategy === U ? q(h, b) : B[h.level].func(h, b);
                    if ((o === ub || o === vb) && (h.status = rb), o === sb || o === ub) return 0 === a.avail_out && (h.last_flush = -1), M;
                    if (o === tb && (b === I ? D._tr_align(h) : b !== L && (D._tr_stored_block(h, 0, 0, !1), b === J && (f(h.head), 0 === h.lookahead && (h.strstart = 0, h.block_start = 0, h.insert = 0))), g(a), 0 === a.avail_out)) return h.last_flush = -1, M
                }
                return b !== K ? M : h.wrap <= 0 ? N : (2 === h.wrap ? (i(h, 255 & a.adler), i(h, a.adler >> 8 & 255), i(h, a.adler >> 16 & 255), i(h, a.adler >> 24 & 255), i(h, 255 & a.total_in), i(h, a.total_in >> 8 & 255), i(h, a.total_in >> 16 & 255), i(h, a.total_in >> 24 & 255)) : (j(h, a.adler >>> 16), j(h, 65535 & a.adler)), g(a), h.wrap > 0 && (h.wrap = -h.wrap), 0 !== h.pending ? M : N)
            }

            function A(a) {
                var b;
                return a && a.state ? (b = a.state.status, b !== lb && b !== mb && b !== nb && b !== ob && b !== pb && b !== qb && b !== rb ? d(a, O) : (a.state = null, b === qb ? d(a, P) : M)) : O
            }

            var B, C = a("../utils/common"), D = a("./trees"), E = a("./adler32"), F = a("./crc32"),
                G = a("./messages"), H = 0, I = 1, J = 3, K = 4, L = 5, M = 0, N = 1, O = -2, P = -3, Q = -5,
                R = -1, S = 1, T = 2, U = 3, V = 4, W = 0, X = 2, Y = 8, Z = 9, $ = 15, _ = 8, ab = 29, bb = 256,
                cb = bb + 1 + ab, db = 30, eb = 19, fb = 2 * cb + 1, gb = 15, hb = 3, ib = 258, jb = ib + hb + 1,
                kb = 32, lb = 42, mb = 69, nb = 73, ob = 91, pb = 103, qb = 113, rb = 666, sb = 1, tb = 2, ub = 3,
                vb = 4, wb = 3, xb = function (a, b, c, d, e) {
                    this.good_length = a, this.max_lazy = b, this.nice_length = c, this.max_chain = d, this.func = e
                };
            B = [new xb(0, 0, 0, 0, n), new xb(4, 4, 8, 4, o), new xb(4, 5, 16, 8, o), new xb(4, 6, 32, 32, o), new xb(4, 4, 16, 16, p), new xb(8, 16, 32, 32, p), new xb(8, 16, 128, 128, p), new xb(8, 32, 128, 256, p), new xb(32, 128, 258, 1024, p), new xb(32, 258, 258, 4096, p)], c.deflateInit = y, c.deflateInit2 = x, c.deflateReset = v, c.deflateResetKeep = u, c.deflateSetHeader = w, c.deflate = z, c.deflateEnd = A, c.deflateInfo = "pako deflate (from Nodeca project)"
        }, {"../utils/common": 27, "./adler32": 29, "./crc32": 31, "./messages": 37, "./trees": 38}],
        33: [function (a, b) {
            "use strict";

            function c() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
            }

            b.exports = c
        }, {}],
        34: [function (a, b) {
            "use strict";
            var c = 30, d = 12;
            b.exports = function (a, b) {
                var e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
                e = a.state, f = a.next_in, B = a.input, g = f + (a.avail_in - 5), h = a.next_out, C = a.output, i = h - (b - a.avail_out), j = h + (a.avail_out - 257), k = e.dmax, l = e.wsize, m = e.whave, n = e.wnext, o = e.window, p = e.hold, q = e.bits, r = e.lencode, s = e.distcode, t = (1 << e.lenbits) - 1, u = (1 << e.distbits) - 1;
                a:do {
                    15 > q && (p += B[f++] << q, q += 8, p += B[f++] << q, q += 8), v = r[p & t];
                    b:for (; ;) {
                        if (w = v >>> 24, p >>>= w, q -= w, w = v >>> 16 & 255, 0 === w) C[h++] = 65535 & v; else {
                            if (!(16 & w)) {
                                if (0 === (64 & w)) {
                                    v = r[(65535 & v) + (p & (1 << w) - 1)];
                                    continue b
                                }
                                if (32 & w) {
                                    e.mode = d;
                                    break a
                                }
                                a.msg = "invalid literal/length code", e.mode = c;
                                break a
                            }
                            x = 65535 & v, w &= 15, w && (w > q && (p += B[f++] << q, q += 8), x += p & (1 << w) - 1, p >>>= w, q -= w), 15 > q && (p += B[f++] << q, q += 8, p += B[f++] << q, q += 8), v = s[p & u];
                            c:for (; ;) {
                                if (w = v >>> 24, p >>>= w, q -= w, w = v >>> 16 & 255, !(16 & w)) {
                                    if (0 === (64 & w)) {
                                        v = s[(65535 & v) + (p & (1 << w) - 1)];
                                        continue c
                                    }
                                    a.msg = "invalid distance code", e.mode = c;
                                    break a
                                }
                                if (y = 65535 & v, w &= 15, w > q && (p += B[f++] << q, q += 8, w > q && (p += B[f++] << q, q += 8)), y += p & (1 << w) - 1, y > k) {
                                    a.msg = "invalid distance too far back", e.mode = c;
                                    break a
                                }
                                if (p >>>= w, q -= w, w = h - i, y > w) {
                                    if (w = y - w, w > m && e.sane) {
                                        a.msg = "invalid distance too far back", e.mode = c;
                                        break a
                                    }
                                    if (z = 0, A = o, 0 === n) {
                                        if (z += l - w, x > w) {
                                            x -= w;
                                            do C[h++] = o[z++]; while (--w);
                                            z = h - y, A = C
                                        }
                                    } else if (w > n) {
                                        if (z += l + n - w, w -= n, x > w) {
                                            x -= w;
                                            do C[h++] = o[z++]; while (--w);
                                            if (z = 0, x > n) {
                                                w = n, x -= w;
                                                do C[h++] = o[z++]; while (--w);
                                                z = h - y, A = C
                                            }
                                        }
                                    } else if (z += n - w, x > w) {
                                        x -= w;
                                        do C[h++] = o[z++]; while (--w);
                                        z = h - y, A = C
                                    }
                                    for (; x > 2;) C[h++] = A[z++], C[h++] = A[z++], C[h++] = A[z++], x -= 3;
                                    x && (C[h++] = A[z++], x > 1 && (C[h++] = A[z++]))
                                } else {
                                    z = h - y;
                                    do C[h++] = C[z++], C[h++] = C[z++], C[h++] = C[z++], x -= 3; while (x > 2);
                                    x && (C[h++] = C[z++], x > 1 && (C[h++] = C[z++]))
                                }
                                break
                            }
                        }
                        break
                    }
                } while (g > f && j > h);
                x = q >> 3, f -= x, q -= x << 3, p &= (1 << q) - 1, a.next_in = f, a.next_out = h, a.avail_in = g > f ? 5 + (g - f) : 5 - (f - g), a.avail_out = j > h ? 257 + (j - h) : 257 - (h - j), e.hold = p, e.bits = q
            }
        }, {}],
        35: [function (a, b, c) {
            "use strict";

            function d(a) {
                return (a >>> 24 & 255) + (a >>> 8 & 65280) + ((65280 & a) << 8) + ((255 & a) << 24)
            }

            function e() {
                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
            }

            function f(a) {
                var b;
                return a && a.state ? (b = a.state, a.total_in = a.total_out = b.total = 0, a.msg = "", b.wrap && (a.adler = 1 & b.wrap), b.mode = K, b.last = 0, b.havedict = 0, b.dmax = 32768, b.head = null, b.hold = 0, b.bits = 0, b.lencode = b.lendyn = new r.Buf32(ob), b.distcode = b.distdyn = new r.Buf32(pb), b.sane = 1, b.back = -1, C) : F
            }

            function g(a) {
                var b;
                return a && a.state ? (b = a.state, b.wsize = 0, b.whave = 0, b.wnext = 0, f(a)) : F
            }

            function h(a, b) {
                var c, d;
                return a && a.state ? (d = a.state, 0 > b ? (c = 0, b = -b) : (c = (b >> 4) + 1, 48 > b && (b &= 15)), b && (8 > b || b > 15) ? F : (null !== d.window && d.wbits !== b && (d.window = null), d.wrap = c, d.wbits = b, g(a))) : F
            }

            function i(a, b) {
                var c, d;
                return a ? (d = new e, a.state = d, d.window = null, c = h(a, b), c !== C && (a.state = null), c) : F
            }

            function j(a) {
                return i(a, rb)
            }

            function k(a) {
                if (sb) {
                    var b;
                    for (p = new r.Buf32(512), q = new r.Buf32(32), b = 0; 144 > b;) a.lens[b++] = 8;
                    for (; 256 > b;) a.lens[b++] = 9;
                    for (; 280 > b;) a.lens[b++] = 7;
                    for (; 288 > b;) a.lens[b++] = 8;
                    for (v(x, a.lens, 0, 288, p, 0, a.work, {bits: 9}), b = 0; 32 > b;) a.lens[b++] = 5;
                    v(y, a.lens, 0, 32, q, 0, a.work, {bits: 5}), sb = !1
                }
                a.lencode = p, a.lenbits = 9, a.distcode = q, a.distbits = 5
            }

            function l(a, b, c, d) {
                var e, f = a.state;
                return null === f.window && (f.wsize = 1 << f.wbits, f.wnext = 0, f.whave = 0, f.window = new r.Buf8(f.wsize)), d >= f.wsize ? (r.arraySet(f.window, b, c - f.wsize, f.wsize, 0), f.wnext = 0, f.whave = f.wsize) : (e = f.wsize - f.wnext, e > d && (e = d), r.arraySet(f.window, b, c - d, e, f.wnext), d -= e, d ? (r.arraySet(f.window, b, c - d, d, 0), f.wnext = d, f.whave = f.wsize) : (f.wnext += e, f.wnext === f.wsize && (f.wnext = 0), f.whave < f.wsize && (f.whave += e))), 0
            }

            function m(a, b) {
                var c, e, f, g, h, i, j, m, n, o, p, q, ob, pb, qb, rb, sb, tb, ub, vb, wb, xb, yb, zb, Ab = 0,
                    Bb = new r.Buf8(4), Cb = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                if (!a || !a.state || !a.output || !a.input && 0 !== a.avail_in) return F;
                c = a.state, c.mode === V && (c.mode = W), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, o = i, p = j, xb = C;
                a:for (; ;) switch (c.mode) {
                    case K:
                        if (0 === c.wrap) {
                            c.mode = W;
                            break
                        }
                        for (; 16 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        if (2 & c.wrap && 35615 === m) {
                            c.check = 0, Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0), m = 0, n = 0, c.mode = L;
                            break
                        }
                        if (c.flags = 0, c.head && (c.head.done = !1), !(1 & c.wrap) || (((255 & m) << 8) + (m >> 8)) % 31) {
                            a.msg = "incorrect header check", c.mode = lb;
                            break
                        }
                        if ((15 & m) !== J) {
                            a.msg = "unknown compression method", c.mode = lb;
                            break
                        }
                        if (m >>>= 4, n -= 4, wb = (15 & m) + 8, 0 === c.wbits) c.wbits = wb; else if (wb > c.wbits) {
                            a.msg = "invalid window size", c.mode = lb;
                            break
                        }
                        c.dmax = 1 << wb, a.adler = c.check = 1, c.mode = 512 & m ? T : V, m = 0, n = 0;
                        break;
                    case L:
                        for (; 16 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        if (c.flags = m, (255 & c.flags) !== J) {
                            a.msg = "unknown compression method", c.mode = lb;
                            break
                        }
                        if (57344 & c.flags) {
                            a.msg = "unknown header flags set", c.mode = lb;
                            break
                        }
                        c.head && (c.head.text = m >> 8 & 1), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0)), m = 0, n = 0, c.mode = M;
                    case M:
                        for (; 32 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        c.head && (c.head.time = m), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, Bb[2] = m >>> 16 & 255, Bb[3] = m >>> 24 & 255, c.check = t(c.check, Bb, 4, 0)), m = 0, n = 0, c.mode = N;
                    case N:
                        for (; 16 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        c.head && (c.head.xflags = 255 & m, c.head.os = m >> 8), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0)), m = 0, n = 0, c.mode = O;
                    case O:
                        if (1024 & c.flags) {
                            for (; 16 > n;) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            c.length = m, c.head && (c.head.extra_len = m), 512 & c.flags && (Bb[0] = 255 & m, Bb[1] = m >>> 8 & 255, c.check = t(c.check, Bb, 2, 0)), m = 0, n = 0
                        } else c.head && (c.head.extra = null);
                        c.mode = P;
                    case P:
                        if (1024 & c.flags && (q = c.length, q > i && (q = i), q && (c.head && (wb = c.head.extra_len - c.length, c.head.extra || (c.head.extra = new Array(c.head.extra_len)), r.arraySet(c.head.extra, e, g, q, wb)), 512 & c.flags && (c.check = t(c.check, e, q, g)), i -= q, g += q, c.length -= q), c.length)) break a;
                        c.length = 0, c.mode = Q;
                    case Q:
                        if (2048 & c.flags) {
                            if (0 === i) break a;
                            q = 0;
                            do wb = e[g + q++], c.head && wb && c.length < 65536 && (c.head.name += String.fromCharCode(wb)); while (wb && i > q);
                            if (512 & c.flags && (c.check = t(c.check, e, q, g)), i -= q, g += q, wb) break a
                        } else c.head && (c.head.name = null);
                        c.length = 0, c.mode = R;
                    case R:
                        if (4096 & c.flags) {
                            if (0 === i) break a;
                            q = 0;
                            do wb = e[g + q++], c.head && wb && c.length < 65536 && (c.head.comment += String.fromCharCode(wb)); while (wb && i > q);
                            if (512 & c.flags && (c.check = t(c.check, e, q, g)), i -= q, g += q, wb) break a
                        } else c.head && (c.head.comment = null);
                        c.mode = S;
                    case S:
                        if (512 & c.flags) {
                            for (; 16 > n;) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            if (m !== (65535 & c.check)) {
                                a.msg = "header crc mismatch", c.mode = lb;
                                break
                            }
                            m = 0, n = 0
                        }
                        c.head && (c.head.hcrc = c.flags >> 9 & 1, c.head.done = !0), a.adler = c.check = 0, c.mode = V;
                        break;
                    case T:
                        for (; 32 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        a.adler = c.check = d(m), m = 0, n = 0, c.mode = U;
                    case U:
                        if (0 === c.havedict) return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, E;
                        a.adler = c.check = 1, c.mode = V;
                    case V:
                        if (b === A || b === B) break a;
                    case W:
                        if (c.last) {
                            m >>>= 7 & n, n -= 7 & n, c.mode = ib;
                            break
                        }
                        for (; 3 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        switch (c.last = 1 & m, m >>>= 1, n -= 1, 3 & m) {
                            case 0:
                                c.mode = X;
                                break;
                            case 1:
                                if (k(c), c.mode = bb, b === B) {
                                    m >>>= 2, n -= 2;
                                    break a
                                }
                                break;
                            case 2:
                                c.mode = $;
                                break;
                            case 3:
                                a.msg = "invalid block type", c.mode = lb
                        }
                        m >>>= 2, n -= 2;
                        break;
                    case X:
                        for (m >>>= 7 & n, n -= 7 & n; 32 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        if ((65535 & m) !== (m >>> 16 ^ 65535)) {
                            a.msg = "invalid stored block lengths", c.mode = lb;
                            break
                        }
                        if (c.length = 65535 & m, m = 0, n = 0, c.mode = Y, b === B) break a;
                    case Y:
                        c.mode = Z;
                    case Z:
                        if (q = c.length) {
                            if (q > i && (q = i), q > j && (q = j), 0 === q) break a;
                            r.arraySet(f, e, g, q, h), i -= q, g += q, j -= q, h += q, c.length -= q;
                            break
                        }
                        c.mode = V;
                        break;
                    case $:
                        for (; 14 > n;) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        if (c.nlen = (31 & m) + 257, m >>>= 5, n -= 5, c.ndist = (31 & m) + 1, m >>>= 5, n -= 5, c.ncode = (15 & m) + 4, m >>>= 4, n -= 4, c.nlen > 286 || c.ndist > 30) {
                            a.msg = "too many length or distance symbols", c.mode = lb;
                            break
                        }
                        c.have = 0, c.mode = _;
                    case _:
                        for (; c.have < c.ncode;) {
                            for (; 3 > n;) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            c.lens[Cb[c.have++]] = 7 & m, m >>>= 3, n -= 3
                        }
                        for (; c.have < 19;) c.lens[Cb[c.have++]] = 0;
                        if (c.lencode = c.lendyn, c.lenbits = 7, yb = {bits: c.lenbits}, xb = v(w, c.lens, 0, 19, c.lencode, 0, c.work, yb), c.lenbits = yb.bits, xb) {
                            a.msg = "invalid code lengths set", c.mode = lb;
                            break
                        }
                        c.have = 0, c.mode = ab;
                    case ab:
                        for (; c.have < c.nlen + c.ndist;) {
                            for (; Ab = c.lencode[m & (1 << c.lenbits) - 1], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= qb);) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            if (16 > sb) m >>>= qb, n -= qb, c.lens[c.have++] = sb; else {
                                if (16 === sb) {
                                    for (zb = qb + 2; zb > n;) {
                                        if (0 === i) break a;
                                        i--, m += e[g++] << n, n += 8
                                    }
                                    if (m >>>= qb, n -= qb, 0 === c.have) {
                                        a.msg = "invalid bit length repeat", c.mode = lb;
                                        break
                                    }
                                    wb = c.lens[c.have - 1], q = 3 + (3 & m), m >>>= 2, n -= 2
                                } else if (17 === sb) {
                                    for (zb = qb + 3; zb > n;) {
                                        if (0 === i) break a;
                                        i--, m += e[g++] << n, n += 8
                                    }
                                    m >>>= qb, n -= qb, wb = 0, q = 3 + (7 & m), m >>>= 3, n -= 3
                                } else {
                                    for (zb = qb + 7; zb > n;) {
                                        if (0 === i) break a;
                                        i--, m += e[g++] << n, n += 8
                                    }
                                    m >>>= qb, n -= qb, wb = 0, q = 11 + (127 & m), m >>>= 7, n -= 7
                                }
                                if (c.have + q > c.nlen + c.ndist) {
                                    a.msg = "invalid bit length repeat", c.mode = lb;
                                    break
                                }
                                for (; q--;) c.lens[c.have++] = wb
                            }
                        }
                        if (c.mode === lb) break;
                        if (0 === c.lens[256]) {
                            a.msg = "invalid code -- missing end-of-block", c.mode = lb;
                            break
                        }
                        if (c.lenbits = 9, yb = {bits: c.lenbits}, xb = v(x, c.lens, 0, c.nlen, c.lencode, 0, c.work, yb), c.lenbits = yb.bits, xb) {
                            a.msg = "invalid literal/lengths set", c.mode = lb;
                            break
                        }
                        if (c.distbits = 6, c.distcode = c.distdyn, yb = {bits: c.distbits}, xb = v(y, c.lens, c.nlen, c.ndist, c.distcode, 0, c.work, yb), c.distbits = yb.bits, xb) {
                            a.msg = "invalid distances set", c.mode = lb;
                            break
                        }
                        if (c.mode = bb, b === B) break a;
                    case bb:
                        c.mode = cb;
                    case cb:
                        if (i >= 6 && j >= 258) {
                            a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, u(a, p), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, c.mode === V && (c.back = -1);
                            break
                        }
                        for (c.back = 0; Ab = c.lencode[m & (1 << c.lenbits) - 1], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= qb);) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        if (rb && 0 === (240 & rb)) {
                            for (tb = qb, ub = rb, vb = sb; Ab = c.lencode[vb + ((m & (1 << tb + ub) - 1) >> tb)], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= tb + qb);) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            m >>>= tb, n -= tb, c.back += tb
                        }
                        if (m >>>= qb, n -= qb, c.back += qb, c.length = sb, 0 === rb) {
                            c.mode = hb;
                            break
                        }
                        if (32 & rb) {
                            c.back = -1, c.mode = V;
                            break
                        }
                        if (64 & rb) {
                            a.msg = "invalid literal/length code", c.mode = lb;
                            break
                        }
                        c.extra = 15 & rb, c.mode = db;
                    case db:
                        if (c.extra) {
                            for (zb = c.extra; zb > n;) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            c.length += m & (1 << c.extra) - 1, m >>>= c.extra, n -= c.extra, c.back += c.extra
                        }
                        c.was = c.length, c.mode = eb;
                    case eb:
                        for (; Ab = c.distcode[m & (1 << c.distbits) - 1], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= qb);) {
                            if (0 === i) break a;
                            i--, m += e[g++] << n, n += 8
                        }
                        if (0 === (240 & rb)) {
                            for (tb = qb, ub = rb, vb = sb; Ab = c.distcode[vb + ((m & (1 << tb + ub) - 1) >> tb)], qb = Ab >>> 24, rb = Ab >>> 16 & 255, sb = 65535 & Ab, !(n >= tb + qb);) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            m >>>= tb, n -= tb, c.back += tb
                        }
                        if (m >>>= qb, n -= qb, c.back += qb, 64 & rb) {
                            a.msg = "invalid distance code", c.mode = lb;
                            break
                        }
                        c.offset = sb, c.extra = 15 & rb, c.mode = fb;
                    case fb:
                        if (c.extra) {
                            for (zb = c.extra; zb > n;) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            c.offset += m & (1 << c.extra) - 1, m >>>= c.extra, n -= c.extra, c.back += c.extra
                        }
                        if (c.offset > c.dmax) {
                            a.msg = "invalid distance too far back", c.mode = lb;
                            break
                        }
                        c.mode = gb;
                    case gb:
                        if (0 === j) break a;
                        if (q = p - j, c.offset > q) {
                            if (q = c.offset - q, q > c.whave && c.sane) {
                                a.msg = "invalid distance too far back", c.mode = lb;
                                break
                            }
                            q > c.wnext ? (q -= c.wnext, ob = c.wsize - q) : ob = c.wnext - q, q > c.length && (q = c.length), pb = c.window
                        } else pb = f, ob = h - c.offset, q = c.length;
                        q > j && (q = j), j -= q, c.length -= q;
                        do f[h++] = pb[ob++]; while (--q);
                        0 === c.length && (c.mode = cb);
                        break;
                    case hb:
                        if (0 === j) break a;
                        f[h++] = c.length, j--, c.mode = cb;
                        break;
                    case ib:
                        if (c.wrap) {
                            for (; 32 > n;) {
                                if (0 === i) break a;
                                i--, m |= e[g++] << n, n += 8
                            }
                            if (p -= j, a.total_out += p, c.total += p, p && (a.adler = c.check = c.flags ? t(c.check, f, p, h - p) : s(c.check, f, p, h - p)), p = j, (c.flags ? m : d(m)) !== c.check) {
                                a.msg = "incorrect data check", c.mode = lb;
                                break
                            }
                            m = 0, n = 0
                        }
                        c.mode = jb;
                    case jb:
                        if (c.wrap && c.flags) {
                            for (; 32 > n;) {
                                if (0 === i) break a;
                                i--, m += e[g++] << n, n += 8
                            }
                            if (m !== (4294967295 & c.total)) {
                                a.msg = "incorrect length check", c.mode = lb;
                                break
                            }
                            m = 0, n = 0
                        }
                        c.mode = kb;
                    case kb:
                        xb = D;
                        break a;
                    case lb:
                        xb = G;
                        break a;
                    case mb:
                        return H;
                    case nb:
                    default:
                        return F
                }
                return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, (c.wsize || p !== a.avail_out && c.mode < lb && (c.mode < ib || b !== z)) && l(a, a.output, a.next_out, p - a.avail_out) ? (c.mode = mb, H) : (o -= a.avail_in, p -= a.avail_out, a.total_in += o, a.total_out += p, c.total += p, c.wrap && p && (a.adler = c.check = c.flags ? t(c.check, f, p, a.next_out - p) : s(c.check, f, p, a.next_out - p)), a.data_type = c.bits + (c.last ? 64 : 0) + (c.mode === V ? 128 : 0) + (c.mode === bb || c.mode === Y ? 256 : 0), (0 === o && 0 === p || b === z) && xb === C && (xb = I), xb)
            }

            function n(a) {
                if (!a || !a.state) return F;
                var b = a.state;
                return b.window && (b.window = null), a.state = null, C
            }

            function o(a, b) {
                var c;
                return a && a.state ? (c = a.state, 0 === (2 & c.wrap) ? F : (c.head = b, b.done = !1, C)) : F
            }

            var p, q, r = a("../utils/common"), s = a("./adler32"), t = a("./crc32"), u = a("./inffast"),
                v = a("./inftrees"), w = 0, x = 1, y = 2, z = 4, A = 5, B = 6, C = 0, D = 1, E = 2, F = -2, G = -3,
                H = -4, I = -5, J = 8, K = 1, L = 2, M = 3, N = 4, O = 5, P = 6, Q = 7, R = 8, S = 9, T = 10,
                U = 11, V = 12, W = 13, X = 14, Y = 15, Z = 16, $ = 17, _ = 18, ab = 19, bb = 20, cb = 21, db = 22,
                eb = 23, fb = 24, gb = 25, hb = 26, ib = 27, jb = 28, kb = 29, lb = 30, mb = 31, nb = 32, ob = 852,
                pb = 592, qb = 15, rb = qb, sb = !0;
            c.inflateReset = g, c.inflateReset2 = h, c.inflateResetKeep = f, c.inflateInit = j, c.inflateInit2 = i, c.inflate = m, c.inflateEnd = n, c.inflateGetHeader = o, c.inflateInfo = "pako inflate (from Nodeca project)"
        }, {"../utils/common": 27, "./adler32": 29, "./crc32": 31, "./inffast": 34, "./inftrees": 36}],
        36: [function (a, b) {
            "use strict";
            var c = a("../utils/common"), d = 15, e = 852, f = 592, g = 0, h = 1, i = 2,
                j = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
                k = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
                l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
                m = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            b.exports = function (a, b, n, o, p, q, r, s) {
                var t, u, v, w, x, y, z, A, B, C = s.bits, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0,
                    L = 0, M = 0, N = null, O = 0, P = new c.Buf16(d + 1), Q = new c.Buf16(d + 1), R = null, S = 0;
                for (D = 0; d >= D; D++) P[D] = 0;
                for (E = 0; o > E; E++) P[b[n + E]]++;
                for (H = C, G = d; G >= 1 && 0 === P[G]; G--) ;
                if (H > G && (H = G), 0 === G) return p[q++] = 20971520, p[q++] = 20971520, s.bits = 1, 0;
                for (F = 1; G > F && 0 === P[F]; F++) ;
                for (F > H && (H = F), K = 1, D = 1; d >= D; D++) if (K <<= 1, K -= P[D], 0 > K) return -1;
                if (K > 0 && (a === g || 1 !== G)) return -1;
                for (Q[1] = 0, D = 1; d > D; D++) Q[D + 1] = Q[D] + P[D];
                for (E = 0; o > E; E++) 0 !== b[n + E] && (r[Q[b[n + E]]++] = E);
                if (a === g ? (N = R = r, y = 19) : a === h ? (N = j, O -= 257, R = k, S -= 257, y = 256) : (N = l, R = m, y = -1), M = 0, E = 0, D = F, x = q, I = H, J = 0, v = -1, L = 1 << H, w = L - 1, a === h && L > e || a === i && L > f) return 1;
                for (var T = 0; ;) {
                    T++, z = D - J, r[E] < y ? (A = 0, B = r[E]) : r[E] > y ? (A = R[S + r[E]], B = N[O + r[E]]) : (A = 96, B = 0), t = 1 << D - J, u = 1 << I, F = u;
                    do u -= t, p[x + (M >> J) + u] = z << 24 | A << 16 | B | 0; while (0 !== u);
                    for (t = 1 << D - 1; M & t;) t >>= 1;
                    if (0 !== t ? (M &= t - 1, M += t) : M = 0, E++, 0 === --P[D]) {
                        if (D === G) break;
                        D = b[n + r[E]]
                    }
                    if (D > H && (M & w) !== v) {
                        for (0 === J && (J = H), x += F, I = D - J, K = 1 << I; G > I + J && (K -= P[I + J], !(0 >= K));) I++, K <<= 1;
                        if (L += 1 << I, a === h && L > e || a === i && L > f) return 1;
                        v = M & w, p[v] = H << 24 | I << 16 | x - q | 0
                    }
                }
                return 0 !== M && (p[x + M] = D - J << 24 | 64 << 16 | 0), s.bits = H, 0
            }
        }, {"../utils/common": 27}],
        37: [function (a, b) {
            "use strict";
            b.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            }
        }, {}],
        38: [function (a, b, c) {
            "use strict";

            function d(a) {
                for (var b = a.length; --b >= 0;) a[b] = 0
            }

            function e(a) {
                return 256 > a ? gb[a] : gb[256 + (a >>> 7)]
            }

            function f(a, b) {
                a.pending_buf[a.pending++] = 255 & b, a.pending_buf[a.pending++] = b >>> 8 & 255
            }

            function g(a, b, c) {
                a.bi_valid > V - c ? (a.bi_buf |= b << a.bi_valid & 65535, f(a, a.bi_buf), a.bi_buf = b >> V - a.bi_valid, a.bi_valid += c - V) : (a.bi_buf |= b << a.bi_valid & 65535, a.bi_valid += c)
            }

            function h(a, b, c) {
                g(a, c[2 * b], c[2 * b + 1])
            }

            function i(a, b) {
                var c = 0;
                do c |= 1 & a, a >>>= 1, c <<= 1; while (--b > 0);
                return c >>> 1
            }

            function j(a) {
                16 === a.bi_valid ? (f(a, a.bi_buf), a.bi_buf = 0, a.bi_valid = 0) : a.bi_valid >= 8 && (a.pending_buf[a.pending++] = 255 & a.bi_buf, a.bi_buf >>= 8, a.bi_valid -= 8)
            }

            function k(a, b) {
                var c, d, e, f, g, h, i = b.dyn_tree, j = b.max_code, k = b.stat_desc.static_tree,
                    l = b.stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base,
                    o = b.stat_desc.max_length, p = 0;
                for (f = 0; U >= f; f++) a.bl_count[f] = 0;
                for (i[2 * a.heap[a.heap_max] + 1] = 0, c = a.heap_max + 1; T > c; c++) d = a.heap[c], f = i[2 * i[2 * d + 1] + 1] + 1, f > o && (f = o, p++), i[2 * d + 1] = f, d > j || (a.bl_count[f]++, g = 0, d >= n && (g = m[d - n]), h = i[2 * d], a.opt_len += h * (f + g), l && (a.static_len += h * (k[2 * d + 1] + g)));
                if (0 !== p) {
                    do {
                        for (f = o - 1; 0 === a.bl_count[f];) f--;
                        a.bl_count[f]--, a.bl_count[f + 1] += 2, a.bl_count[o]--, p -= 2
                    } while (p > 0);
                    for (f = o; 0 !== f; f--) for (d = a.bl_count[f]; 0 !== d;) e = a.heap[--c], e > j || (i[2 * e + 1] !== f && (a.opt_len += (f - i[2 * e + 1]) * i[2 * e], i[2 * e + 1] = f), d--)
                }
            }

            function l(a, b, c) {
                var d, e, f = new Array(U + 1), g = 0;
                for (d = 1; U >= d; d++) f[d] = g = g + c[d - 1] << 1;
                for (e = 0; b >= e; e++) {
                    var h = a[2 * e + 1];
                    0 !== h && (a[2 * e] = i(f[h]++, h))
                }
            }

            function m() {
                var a, b, c, d, e, f = new Array(U + 1);
                for (c = 0, d = 0; O - 1 > d; d++) for (ib[d] = c, a = 0; a < 1 << _[d]; a++) hb[c++] = d;
                for (hb[c - 1] = d, e = 0, d = 0; 16 > d; d++) for (jb[d] = e, a = 0; a < 1 << ab[d]; a++) gb[e++] = d;
                for (e >>= 7; R > d; d++) for (jb[d] = e << 7, a = 0; a < 1 << ab[d] - 7; a++) gb[256 + e++] = d;
                for (b = 0; U >= b; b++) f[b] = 0;
                for (a = 0; 143 >= a;) eb[2 * a + 1] = 8, a++, f[8]++;
                for (; 255 >= a;) eb[2 * a + 1] = 9, a++, f[9]++;
                for (; 279 >= a;) eb[2 * a + 1] = 7, a++, f[7]++;
                for (; 287 >= a;) eb[2 * a + 1] = 8, a++, f[8]++;
                for (l(eb, Q + 1, f), a = 0; R > a; a++) fb[2 * a + 1] = 5, fb[2 * a] = i(a, 5);
                kb = new nb(eb, _, P + 1, Q, U), lb = new nb(fb, ab, 0, R, U), mb = new nb(new Array(0), bb, 0, S, W)
            }

            function n(a) {
                var b;
                for (b = 0; Q > b; b++) a.dyn_ltree[2 * b] = 0;
                for (b = 0; R > b; b++) a.dyn_dtree[2 * b] = 0;
                for (b = 0; S > b; b++) a.bl_tree[2 * b] = 0;
                a.dyn_ltree[2 * X] = 1, a.opt_len = a.static_len = 0, a.last_lit = a.matches = 0
            }

            function o(a) {
                a.bi_valid > 8 ? f(a, a.bi_buf) : a.bi_valid > 0 && (a.pending_buf[a.pending++] = a.bi_buf), a.bi_buf = 0, a.bi_valid = 0
            }

            function p(a, b, c, d) {
                o(a), d && (f(a, c), f(a, ~c)), E.arraySet(a.pending_buf, a.window, b, c, a.pending), a.pending += c
            }

            function q(a, b, c, d) {
                var e = 2 * b, f = 2 * c;
                return a[e] < a[f] || a[e] === a[f] && d[b] <= d[c]
            }

            function r(a, b, c) {
                for (var d = a.heap[c], e = c << 1; e <= a.heap_len && (e < a.heap_len && q(b, a.heap[e + 1], a.heap[e], a.depth) && e++, !q(b, d, a.heap[e], a.depth));) a.heap[c] = a.heap[e], c = e, e <<= 1;
                a.heap[c] = d
            }

            function s(a, b, c) {
                var d, f, i, j, k = 0;
                if (0 !== a.last_lit) do d = a.pending_buf[a.d_buf + 2 * k] << 8 | a.pending_buf[a.d_buf + 2 * k + 1], f = a.pending_buf[a.l_buf + k], k++, 0 === d ? h(a, f, b) : (i = hb[f], h(a, i + P + 1, b), j = _[i], 0 !== j && (f -= ib[i], g(a, f, j)), d--, i = e(d), h(a, i, c), j = ab[i], 0 !== j && (d -= jb[i], g(a, d, j))); while (k < a.last_lit);
                h(a, X, b)
            }

            function t(a, b) {
                var c, d, e, f = b.dyn_tree, g = b.stat_desc.static_tree, h = b.stat_desc.has_stree,
                    i = b.stat_desc.elems, j = -1;
                for (a.heap_len = 0, a.heap_max = T, c = 0; i > c; c++) 0 !== f[2 * c] ? (a.heap[++a.heap_len] = j = c, a.depth[c] = 0) : f[2 * c + 1] = 0;
                for (; a.heap_len < 2;) e = a.heap[++a.heap_len] = 2 > j ? ++j : 0, f[2 * e] = 1, a.depth[e] = 0, a.opt_len--, h && (a.static_len -= g[2 * e + 1]);
                for (b.max_code = j, c = a.heap_len >> 1; c >= 1; c--) r(a, f, c);
                e = i;
                do c = a.heap[1], a.heap[1] = a.heap[a.heap_len--], r(a, f, 1), d = a.heap[1], a.heap[--a.heap_max] = c, a.heap[--a.heap_max] = d, f[2 * e] = f[2 * c] + f[2 * d], a.depth[e] = (a.depth[c] >= a.depth[d] ? a.depth[c] : a.depth[d]) + 1, f[2 * c + 1] = f[2 * d + 1] = e, a.heap[1] = e++, r(a, f, 1); while (a.heap_len >= 2);
                a.heap[--a.heap_max] = a.heap[1], k(a, b), l(f, j, a.bl_count)
            }

            function u(a, b, c) {
                var d, e, f = -1, g = b[1], h = 0, i = 7, j = 4;
                for (0 === g && (i = 138, j = 3), b[2 * (c + 1) + 1] = 65535, d = 0; c >= d; d++) e = g, g = b[2 * (d + 1) + 1], ++h < i && e === g || (j > h ? a.bl_tree[2 * e] += h : 0 !== e ? (e !== f && a.bl_tree[2 * e]++, a.bl_tree[2 * Y]++) : 10 >= h ? a.bl_tree[2 * Z]++ : a.bl_tree[2 * $]++, h = 0, f = e, 0 === g ? (i = 138, j = 3) : e === g ? (i = 6, j = 3) : (i = 7, j = 4))
            }

            function v(a, b, c) {
                var d, e, f = -1, i = b[1], j = 0, k = 7, l = 4;
                for (0 === i && (k = 138, l = 3), d = 0; c >= d; d++) if (e = i, i = b[2 * (d + 1) + 1], !(++j < k && e === i)) {
                    if (l > j) {
                        do h(a, e, a.bl_tree); while (0 !== --j)
                    } else 0 !== e ? (e !== f && (h(a, e, a.bl_tree), j--), h(a, Y, a.bl_tree), g(a, j - 3, 2)) : 10 >= j ? (h(a, Z, a.bl_tree), g(a, j - 3, 3)) : (h(a, $, a.bl_tree), g(a, j - 11, 7));
                    j = 0, f = e, 0 === i ? (k = 138, l = 3) : e === i ? (k = 6, l = 3) : (k = 7, l = 4)
                }
            }

            function w(a) {
                var b;
                for (u(a, a.dyn_ltree, a.l_desc.max_code), u(a, a.dyn_dtree, a.d_desc.max_code), t(a, a.bl_desc), b = S - 1; b >= 3 && 0 === a.bl_tree[2 * cb[b] + 1]; b--) ;
                return a.opt_len += 3 * (b + 1) + 5 + 5 + 4, b
            }

            function x(a, b, c, d) {
                var e;
                for (g(a, b - 257, 5), g(a, c - 1, 5), g(a, d - 4, 4), e = 0; d > e; e++) g(a, a.bl_tree[2 * cb[e] + 1], 3);
                v(a, a.dyn_ltree, b - 1), v(a, a.dyn_dtree, c - 1)
            }

            function y(a) {
                var b, c = 4093624447;
                for (b = 0; 31 >= b; b++, c >>>= 1) if (1 & c && 0 !== a.dyn_ltree[2 * b]) return G;
                if (0 !== a.dyn_ltree[18] || 0 !== a.dyn_ltree[20] || 0 !== a.dyn_ltree[26]) return H;
                for (b = 32; P > b; b++) if (0 !== a.dyn_ltree[2 * b]) return H;
                return G
            }

            function z(a) {
                pb || (m(), pb = !0), a.l_desc = new ob(a.dyn_ltree, kb), a.d_desc = new ob(a.dyn_dtree, lb), a.bl_desc = new ob(a.bl_tree, mb), a.bi_buf = 0, a.bi_valid = 0, n(a)
            }

            function A(a, b, c, d) {
                g(a, (J << 1) + (d ? 1 : 0), 3), p(a, b, c, !0)
            }

            function B(a) {
                g(a, K << 1, 3), h(a, X, eb), j(a)
            }

            function C(a, b, c, d) {
                var e, f, h = 0;
                a.level > 0 ? (a.strm.data_type === I && (a.strm.data_type = y(a)), t(a, a.l_desc), t(a, a.d_desc), h = w(a), e = a.opt_len + 3 + 7 >>> 3, f = a.static_len + 3 + 7 >>> 3, e >= f && (e = f)) : e = f = c + 5, e >= c + 4 && -1 !== b ? A(a, b, c, d) : a.strategy === F || f === e ? (g(a, (K << 1) + (d ? 1 : 0), 3), s(a, eb, fb)) : (g(a, (L << 1) + (d ? 1 : 0), 3), x(a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, h + 1), s(a, a.dyn_ltree, a.dyn_dtree)), n(a), d && o(a)
            }

            function D(a, b, c) {
                return a.pending_buf[a.d_buf + 2 * a.last_lit] = b >>> 8 & 255, a.pending_buf[a.d_buf + 2 * a.last_lit + 1] = 255 & b, a.pending_buf[a.l_buf + a.last_lit] = 255 & c, a.last_lit++, 0 === b ? a.dyn_ltree[2 * c]++ : (a.matches++, b--, a.dyn_ltree[2 * (hb[c] + P + 1)]++, a.dyn_dtree[2 * e(b)]++), a.last_lit === a.lit_bufsize - 1
            }

            var E = a("../utils/common"), F = 4, G = 0, H = 1, I = 2, J = 0, K = 1, L = 2, M = 3, N = 258, O = 29,
                P = 256, Q = P + 1 + O, R = 30, S = 19, T = 2 * Q + 1, U = 15, V = 16, W = 7, X = 256, Y = 16,
                Z = 17, $ = 18,
                _ = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
                ab = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                bb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                cb = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], db = 512,
                eb = new Array(2 * (Q + 2));
            d(eb);
            var fb = new Array(2 * R);
            d(fb);
            var gb = new Array(db);
            d(gb);
            var hb = new Array(N - M + 1);
            d(hb);
            var ib = new Array(O);
            d(ib);
            var jb = new Array(R);
            d(jb);
            var kb, lb, mb, nb = function (a, b, c, d, e) {
                this.static_tree = a, this.extra_bits = b, this.extra_base = c, this.elems = d, this.max_length = e, this.has_stree = a && a.length
            }, ob = function (a, b) {
                this.dyn_tree = a, this.max_code = 0, this.stat_desc = b
            }, pb = !1;
            c._tr_init = z, c._tr_stored_block = A, c._tr_flush_block = C, c._tr_tally = D, c._tr_align = B
        }, {"../utils/common": 27}],
        39: [function (a, b) {
            "use strict";

            function c() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
            }

            b.exports = c
        }, {}]
    }, {}, [9])(9)
});
// 'use strict';
// if (tr.isVinn) {
//     global.JSZip = global.window.JSZip;
//     global.window = undefined;
// } else if (tr.isNode) {
//     const jsZipAbsPath = HTMLImportsLoader.hrefToAbsolutePath('/jszip.min.js');
//     const jsZipModule = require(jsZipAbsPath);
//     global.JSZip = jsZipModule;
// }
'use strict';
tr.exportTo('tr.e.importer', function () {
    function ZipImporter(model, eventData) {
        if (eventData instanceof ArrayBuffer) {
            eventData = new Uint8Array(eventData);
        }
        this.model_ = model;
        this.eventData_ = eventData;
    }

    ZipImporter.canImport = function (eventData) {
        let header;
        if (eventData instanceof ArrayBuffer) {
            header = new Uint8Array(eventData.slice(0, 2));
        } else if (typeof (eventData) === 'string' || eventData instanceof String) {
            header = [eventData.charCodeAt(0), eventData.charCodeAt(1)];
        } else {
            return false;
        }
        return header[0] === 'P'.charCodeAt(0) && header[1] === 'K'.charCodeAt(0);
    };
    ZipImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'ZipImporter';
        }, isTraceDataContainer() {
            return true;
        }, extractSubtraces() {
            const zip = new JSZip(this.eventData_);
            const subtraces = [];
            for (const idx in zip.files) {
                subtraces.push(zip.files[idx].asBinary());
            }
            return subtraces;
        }
    };
    tr.importer.Importer.register(ZipImporter);
    return {ZipImporter,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function HeapEntry(heapDump, leafStackFrame, objectTypeName, size, count, valuesAreTotals) {
        this.heapDump = heapDump;
        this.leafStackFrame = leafStackFrame;
        this.objectTypeName = objectTypeName;
        this.size = size;
        this.count = count;
        this.valuesAreTotals = valuesAreTotals;
    }

    function HeapDump(processMemoryDump, allocatorName, isComplete) {
        this.processMemoryDump = processMemoryDump;
        this.allocatorName = allocatorName;
        this.isComplete = isComplete;
        this.entries = [];
    }

    HeapDump.prototype = {
        addEntry(leafStackFrame, objectTypeName, size, count, opt_valuesAreTotals) {
            if (opt_valuesAreTotals === undefined) opt_valuesAreTotals = true;
            const valuesAreTotals = opt_valuesAreTotals;
            const entry = new HeapEntry(this, leafStackFrame, objectTypeName, size, count, valuesAreTotals);
            this.entries.push(entry);
            return entry;
        }
    };
    return {HeapEntry, HeapDump,};
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    function HeapDumpTraceEventImporter(heapProfileExpander, stackFrames, processMemoryDump, idPrefix, model) {
        this.expander = heapProfileExpander;
        this.stackFrames = stackFrames;
        this.processMemoryDump = processMemoryDump;
        this.idPrefix = idPrefix;
        this.model = model;
    }

    HeapDumpTraceEventImporter.prototype = {
        getLeafStackFrame(stackFrameId) {
            if (stackFrameId === '') return undefined;
            const parentId = this.idPrefix + stackFrameId;
            const id = parentId + ':self';
            if (!this.stackFrames[id]) {
                const parentStackFrame = this.stackFrames[parentId];
                const stackFrame = new tr.model.StackFrame(parentStackFrame, id, '<self>', undefined);
                this.model.addStackFrame(stackFrame);
            }
            return this.stackFrames[id];
        }, parseEntry(entry, heapDump) {
            const size = entry.size;
            const count = entry.count;
            const leafStackFrame = this.getLeafStackFrame(entry.node.id);
            const objectTypeName = entry.type.name;
            const valuesAreTotals = false;
            if (objectTypeName === undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Missing object type name (ID ' + typeId + ')',
                });
            }
            heapDump.addEntry(leafStackFrame, objectTypeName, size, count, valuesAreTotals);
        }, parse() {
            const heapDumps = {};
            const inflated = this.expander.inflated;
            for (const [allocatorName, entries] of Object.entries(inflated)) {
                const heapDump = new tr.model.HeapDump(this.processMemoryDump, allocatorName);
                for (const entry of entries) {
                    this.parseEntry(entry, heapDump);
                }
                heapDump.isComplete = true;
                heapDumps[allocatorName] = heapDump;
            }
            return heapDumps;
        },
    };
    return {HeapDumpTraceEventImporter,};
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    function LegacyHeapDumpTraceEventImporter(model, processMemoryDump, processObjectTypeNameMap, idPrefix, dumpId, rawHeapDumps) {
        this.model_ = model;
        this.processObjectTypeNameMap_ = processObjectTypeNameMap;
        this.idPrefix_ = idPrefix;
        this.processMemoryDump_ = processMemoryDump;
        this.pid_ = this.processMemoryDump_.process.pid;
        this.dumpId_ = dumpId;
        this.rawHeapDumps_ = rawHeapDumps;
    }

    LegacyHeapDumpTraceEventImporter.prototype = {
        parseRawHeapDump(rawHeapDump, allocatorName) {
            const model = this.model_;
            const processMemoryDump = this.processMemoryDump_;
            const heapDump = new tr.model.HeapDump(processMemoryDump, allocatorName);
            const entries = rawHeapDump.entries;
            if (entries === undefined || entries.length === 0) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'No heap entries in a ' + allocatorName + ' heap dump for PID=' + this.pid_ + ' and dump ID=' + this.dumpId_ + '.'
                });
                return undefined;
            }
            const isOldFormat = entries[0].bt === undefined;
            if (!isOldFormat && this.processObjectTypeNameMap_ === undefined) {
                return undefined;
            }
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                const size = parseInt(entry.size, 16);
                const leafStackFrameIndex = entry.bt;
                let leafStackFrame;
                if (isOldFormat) {
                    if (leafStackFrameIndex === undefined) {
                        leafStackFrame = undefined;
                    } else {
                        let leafStackFrameId = this.idPrefix_ + leafStackFrameIndex;
                        if (leafStackFrameIndex === '') {
                            leafStackFrame = undefined;
                        } else {
                            leafStackFrame = model.stackFrames[leafStackFrameId];
                            if (leafStackFrame === undefined) {
                                this.model_.importWarning({
                                    type: 'memory_dump_parse_error', message: 'Missing leaf stack frame (ID ' +
                                        leafStackFrameId + ') of heap entry ' + i + ' (size ' +
                                        size + ') in a ' + allocatorName + ' heap dump for PID=' + this.pid_ + '.'
                                });
                                continue;
                            }
                        }
                        leafStackFrameId += ':self';
                        if (model.stackFrames[leafStackFrameId] !== undefined) {
                            leafStackFrame = model.stackFrames[leafStackFrameId];
                        } else {
                            leafStackFrame = new tr.model.StackFrame(leafStackFrame, leafStackFrameId, '<self>', undefined);
                            model.addStackFrame(leafStackFrame);
                        }
                    }
                } else {
                    if (leafStackFrameIndex === undefined) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Missing stack frame ID of heap entry ' + i + ' (size ' + size + ') in a ' + allocatorName + ' heap dump for PID=' + this.pid_ + '.'
                        });
                        continue;
                    }
                    const leafStackFrameId = this.idPrefix_ + leafStackFrameIndex;
                    if (leafStackFrameIndex === '') {
                        leafStackFrame = undefined;
                    } else {
                        leafStackFrame = model.stackFrames[leafStackFrameId];
                        if (leafStackFrame === undefined) {
                            this.model_.importWarning({
                                type: 'memory_dump_parse_error',
                                message: 'Missing leaf stack frame (ID ' + leafStackFrameId + ') of heap entry ' + i + ' (size ' + size + ') in a ' +
                                    allocatorName + ' heap dump for PID=' + this.pid_ + '.'
                            });
                            continue;
                        }
                    }
                }
                const objectTypeId = entry.type;
                let objectTypeName;
                if (objectTypeId === undefined) {
                    objectTypeName = undefined;
                } else if (this.processObjectTypeNameMap_ === undefined) {
                    continue;
                } else {
                    objectTypeName = this.processObjectTypeNameMap_[objectTypeId];
                    if (objectTypeName === undefined) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Missing object type name (ID ' + objectTypeId + ') of heap entry ' + i + ' (size ' + size + ') in a ' +
                                allocatorName + ' heap dump for PID=' + this.pid_ + '.'
                        });
                        continue;
                    }
                }
                const count = entry.count === undefined ? undefined : parseInt(entry.count, 16);
                heapDump.addEntry(leafStackFrame, objectTypeName, size, count);
            }
            return heapDump;
        }, parse() {
            const heapDumps = {};
            for (const allocatorName in this.rawHeapDumps_) {
                const rawHeapDump = this.rawHeapDumps_[allocatorName];
                const heapDump = this.parseRawHeapDump(rawHeapDump, allocatorName);
                if (heapDump !== undefined && heapDump.entries.length > 0) {
                    heapDumps[allocatorName] = heapDump;
                }
            }
            return heapDumps;
        },
    };
    return {LegacyHeapDumpTraceEventImporter,};
});
var oboe = require('./oboe.js')
global.oboe = oboe
// 'use strict';
// if (tr.isVinn) {
//     global.oboe = global.window.oboe;
//     global.window = undefined;
// } else if (tr.isNode) {
//     global.window = undefined;
//     const path = HTMLImportsLoader.hrefToAbsolutePath('/oboe/dist/oboe-node.js');
//     global.oboe = require(path);
// }
'use strict';
tr.exportTo('tr.e.importer', function () {
    const STRING_ID_SUFFIX = '_sid';
    const PLURAL_STRING_ID_SUFFIX = '_sids';

    function isStringReference(s) {
        return s.endsWith(STRING_ID_SUFFIX) || s.endsWith(PLURAL_STRING_ID_SUFFIX);
    }

    function getStringReferenceName(name) {
        if (name.endsWith(PLURAL_STRING_ID_SUFFIX)) {
            return name.slice(0, -PLURAL_STRING_ID_SUFFIX.length);
        }
        return name.slice(0, -STRING_ID_SUFFIX.length);
    }

    function deferenceStrings(idToString, o) {
        const clone = Object.assign({}, o);
        for (const [key, value] of Object.entries(clone)) {
            if (isStringReference(key)) {
                const name = getStringReferenceName(key);
                clone[name] = idToString(value);
            }
        }
        return clone;
    }

    function singularize(word) {
        if (word.endsWith('s')) {
            return word.slice(0, -1);
        }
        return word;
    }

    function getMetadataPairs(dataJson) {
        const isMetadata = v => typeof v !== 'object' || Array.isArray(v);
        const pairs = Object.entries(dataJson);
        const metadataPairs = pairs.filter(([_, v]) => isMetadata(v));
        return metadataPairs;
    }

    function getGroupPairs(dataJson) {
        const pairs = Object.entries(dataJson);
        const nonMapPairs = pairs.filter(([k, _]) => k !== 'maps');
        const groupPairs = nonMapPairs.filter(([_, v]) => typeof v === 'object');
        return groupPairs;
    }

    function createMap(mapJson) {
        const map = new Map();
        for (const entry of mapJson) {
            if (entry.id === undefined) {
                throw new Error('Missing required key "id" in streaming event.');
            }
            map.set(entry.id, entry);
        }
        return map;
    }

    function createMaps(mapsJson) {
        const maps = new Map();
        for (const [name, mapJson] of Object.entries(mapsJson)) {
            maps.set(name, createMap(mapJson));
        }
        return maps;
    }

    function createGroup(groupJson, opt_startTime) {
        const entries = [];
        const n = Object.values(groupJson)[0].length;
        for (let i = 0; i < n; i++) {
            const entry = {};
            for (const name in groupJson) {
                entry[name] = groupJson[name][i];
            }
            entries.push(entry);
        }
        const timeDelta = groupJson.timeDelta;
        if (opt_startTime === undefined && timeDelta !== undefined) {
            throw new Error('Missing required key "startTime" in streaming event.');
        }
        if (opt_startTime) {
            let delta = 0;
            for (const entry of entries) {
                delta += entry.timeDelta ? entry.timeDelta : 0;
                entry.time = opt_startTime + delta;
            }
        }
        return entries;
    }

    function createGroups(groupsJson, opt_startTime) {
        const groups = new Map();
        for (const [name, groupJson] of Object.entries(groupsJson)) {
            groups.set(name, createGroup(groupJson, opt_startTime));
        }
        return groups;
    }

    function createMetadata(metadataPairs) {
        const metadata = new Map();
        for (const [name, value] of metadataPairs) {
            metadata.set(name, value);
        }
        if (metadata.get('version') === undefined) {
            throw new Error('Missing required key "version" in streaming event.');
        }
        return metadata;
    }

    class ProfilingDictionaryReader {
        constructor(opt_metadata, opt_maps, opt_groups, opt_parent) {
            this.metadata = opt_metadata || new Map();
            this.maps = opt_maps || new Map();
            this.groups = opt_groups || new Map();
            this.parent_ = opt_parent || undefined;
            this.inflated_ = undefined;
            this.raw_ = undefined;
            this.boundGetString_ = this.getString.bind(this);
            this.deferenceStrings_ = o => deferenceStrings(this.boundGetString_, o);
        }

        static empty() {
            return new ProfilingDictionaryReader();
        }

        get parent() {
            return this.parent_;
        }

        get raw() {
            if (this.raw_) return this.raw_;
            this.raw_ = {};
            for (const [name, group] of this.groups.entries()) {
                this.raw_[name] = group;
            }
            return this.raw_;
        }

        get inflated() {
            if (this.inflated_) return this.inflated_;
            this.inflated_ = {};
            for (const [name, group] of this.groups.entries()) {
                this.inflated_[name] = this.inflateGroup(group);
            }
            return this.inflated_;
        }

        getNewMap(name) {
            return this.maps.get(name) || new Map();
        }

        getMapValue(mapName, id) {
            let value = this.getNewMap(mapName).get(id);
            if (value === undefined && this.parent) {
                value = this.parent.getMapValue(mapName, id);
            }
            return value;
        }

        getString(id) {
            const value = this.getMapValue('strings', id);
            if (value === undefined) return undefined;
            return value.string;
        }

        hasMap(name) {
            if (this.maps.has(name)) return true;
            if (this.parent === undefined) return false;
            return this.parent.hasMap(name);
        }

        inflateGroup(group) {
            return group.map(this.inflateEntry.bind(this));
        }

        inflateEntry(entry) {
            const inflatedEntry = {};
            for (const [name, value] of Object.entries(entry)) {
                let inflatedValue;
                if (this.hasMap(name)) {
                    const id = value;
                    inflatedValue = this.deferenceStrings_(this.getMapValue(name, id));
                } else {
                    inflatedValue = value;
                }
                inflatedEntry[singularize(name)] = inflatedValue;
            }
            return this.deferenceStrings_(inflatedEntry);
        }

        expandData(data) {
            const mapsJson = data.maps || {};
            const groupsJson = data.allocators || {};
            const metadataPairs = getMetadataPairs(data);
            const metadata = createMetadata(metadataPairs);
            const opt_startTime = metadata.get('startTime');
            const maps = createMaps(mapsJson);
            const groups = createGroups(groupsJson, opt_startTime);
            return new ProfilingDictionaryReader(metadata, maps, groups, this);
        }

        expandEvent(event) {
            return this.expandData(event.args.data);
        }
    }

    return {ProfilingDictionaryReader, singularize, deferenceStringsForTest: deferenceStrings,};
});
'use strict';
tr.exportTo('tr.model.source_info', function () {
    function SourceInfo(file, opt_line, opt_column) {
        this.file_ = file;
        this.line_ = opt_line || -1;
        this.column_ = opt_column || -1;
    }

    SourceInfo.prototype = {
        get file() {
            return this.file_;
        }, get line() {
            return this.line_;
        }, get column() {
            return this.column_;
        }, get domain() {
            if (!this.file_) return undefined;
            const domain = this.file_.match(/(.*:\/\/[^:\/]*)/i);
            return domain ? domain[1] : undefined;
        }, toString() {
            let str = '';
            if (this.file_) {
                str += this.file_;
            }
            if (this.line_ > 0) {
                str += ':' + this.line_;
            }
            if (this.column_ > 0) {
                str += ':' + this.column_;
            }
            return str;
        }
    };
    return {SourceInfo,};
});
'use strict';
tr.exportTo('tr.model.source_info', function () {
    function JSSourceInfo(file, line, column, isNative, scriptId, state) {
        tr.model.source_info.SourceInfo.call(this, file, line, column);
        this.isNative_ = isNative;
        this.scriptId_ = scriptId;
        this.state_ = state;
    }

    JSSourceInfo.prototype = {
        __proto__: tr.model.source_info.SourceInfo.prototype, get state() {
            return this.state_;
        }, get isNative() {
            return this.isNative_;
        }, get scriptId() {
            return this.scriptId_;
        }, toString() {
            const str = this.isNative_ ? '[native v8] ' : '';
            return str +
                tr.model.source_info.SourceInfo.prototype.toString.call(this);
        }
    };
    const JSSourceState = {
        COMPILED: 'compiled',
        OPTIMIZABLE: 'optimizable',
        OPTIMIZED: 'optimized',
        UNKNOWN: 'unknown',
    };
    return {JSSourceInfo, JSSourceState,};
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    function TraceCodeEntry(address, size, name, scriptId) {
        this.id_ = tr.b.GUID.allocateSimple();
        this.address_ = address;
        this.size_ = size;
        const rePrefix = /^(\w*:)?([*~]?)(.*)$/m;
        const tokens = rePrefix.exec(name);
        const prefix = tokens[1];
        let state = tokens[2];
        const body = tokens[3];
        if (state === '*') {
            state = tr.model.source_info.JSSourceState.OPTIMIZED;
        } else if (state === '~') {
            state = tr.model.source_info.JSSourceState.OPTIMIZABLE;
        } else if (state === '') {
            state = tr.model.source_info.JSSourceState.COMPILED;
        } else {
            state = tr.model.source_info.JSSourceState.UNKNOWN;
        }
        let rawName;
        let rawUrl;
        if (prefix === 'Script:') {
            rawName = '';
            rawUrl = body;
        } else {
            const spacePos = body.lastIndexOf(' ');
            rawName = spacePos !== -1 ? body.substr(0, spacePos) : body;
            rawUrl = spacePos !== -1 ? body.substr(spacePos + 1) : '';
        }

        function splitLineAndColumn(url) {
            const lineColumnRegEx = /(?::(\d+))?(?::(\d+))?$/;
            const lineColumnMatch = lineColumnRegEx.exec(url);
            let lineNumber;
            let columnNumber;
            if (typeof (lineColumnMatch[1]) === 'string') {
                lineNumber = parseInt(lineColumnMatch[1], 10);
                lineNumber = isNaN(lineNumber) ? undefined : lineNumber - 1;
            }
            if (typeof (lineColumnMatch[2]) === 'string') {
                columnNumber = parseInt(lineColumnMatch[2], 10);
                columnNumber = isNaN(columnNumber) ? undefined : columnNumber - 1;
            }
            return {url: url.substring(0, url.length - lineColumnMatch[0].length), lineNumber, columnNumber};
        }

        const nativeSuffix = ' native';
        const isNative = rawName.endsWith(nativeSuffix);
        this.name_ = isNative ? rawName.slice(0, -nativeSuffix.length) : rawName;
        const urlData = splitLineAndColumn(rawUrl);
        const url = urlData.url || '';
        const line = urlData.lineNumber || 0;
        const column = urlData.columnNumber || 0;
        this.sourceInfo_ = new tr.model.source_info.JSSourceInfo(url, line, column, isNative, scriptId, state);
    }

    TraceCodeEntry.prototype = {
        get id() {
            return this.id_;
        }, get sourceInfo() {
            return this.sourceInfo_;
        }, get name() {
            return this.name_;
        }, set address(address) {
            this.address_ = address;
        }, get address() {
            return this.address_;
        }, set size(size) {
            this.size_ = size;
        }, get size() {
            return this.size_;
        }
    };
    return {TraceCodeEntry,};
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    function TraceCodeMap() {
        this.banks_ = new Map();
    }

    TraceCodeMap.prototype = {
        addEntry(addressHex, size, name, scriptId) {
            const entry = new tr.e.importer.TraceCodeEntry(this.getAddress_(addressHex), size, name, scriptId);
            this.addEntry_(addressHex, entry);
        }, moveEntry(oldAddressHex, newAddressHex, size) {
            const entry = this.getBank_(oldAddressHex).removeEntry(this.getAddress_(oldAddressHex));
            if (!entry) return;
            entry.address = this.getAddress_(newAddressHex);
            entry.size = size;
            this.addEntry_(newAddressHex, entry);
        }, lookupEntry(addressHex) {
            return this.getBank_(addressHex).lookupEntry(this.getAddress_(addressHex));
        }, addEntry_(addressHex, entry) {
            this.getBank_(addressHex).addEntry(entry);
        }, getAddress_(addressHex) {
            const bankSizeHexDigits = 13;
            addressHex = addressHex.slice(2);
            return parseInt(addressHex.slice(-bankSizeHexDigits), 16);
        }, getBank_(addressHex) {
            addressHex = addressHex.slice(2);
            const bankSizeHexDigits = 13;
            const maxHexDigits = 16;
            const bankName = addressHex.slice(-maxHexDigits, -bankSizeHexDigits);
            let bank = this.banks_.get(bankName);
            if (!bank) {
                bank = new TraceCodeBank();
                this.banks_.set(bankName, bank);
            }
            return bank;
        }
    };

    function TraceCodeBank() {
        this.entries_ = [];
    }

    TraceCodeBank.prototype = {
        removeEntry(address) {
            if (this.entries_.length === 0) return undefined;
            const index = tr.b.findLowIndexInSortedArray(this.entries_, function (entry) {
                return entry.address;
            }, address);
            const entry = this.entries_[index];
            if (!entry || entry.address !== address) return undefined;
            this.entries_.splice(index, 1);
            return entry;
        }, lookupEntry(address) {
            const index = tr.b.findFirstTrueIndexInSortedArray(this.entries_, e => (address < e.address)) - 1;
            const entry = this.entries_[index];
            return entry && address < entry.address + entry.size ? entry : undefined;
        }, addEntry(newEntry) {
            if (this.entries_.length === 0) {
                this.entries_.push(newEntry);
            }
            const endAddress = newEntry.address + newEntry.size;
            const lastIndex = tr.b.findLowIndexInSortedArray(this.entries_, function (entry) {
                return entry.address;
            }, endAddress);
            let index;
            for (index = lastIndex - 1; index >= 0; --index) {
                const entry = this.entries_[index];
                const entryEndAddress = entry.address + entry.size;
                if (entryEndAddress <= newEntry.address) break;
            }
            ++index;
            this.entries_.splice(index, lastIndex - index, newEntry);
        }
    };
    return {TraceCodeMap,};
});
'use strict';
tr.exportTo('tr.e.measure', function () {
    const AsyncSlice = tr.model.AsyncSlice;
    const MEASURE_NAME_REGEX = /([^\/:]+):(.*?)(?:\/([A-Za-z0-9+/]+=?=?))?$/;

    function MeasureAsyncSlice() {
        this.groupTitle_ = 'Ungrouped Measure';
        const matched = MEASURE_NAME_REGEX.exec(arguments[1]);
        if (matched !== null) {
            arguments[1] = matched[2];
            this.groupTitle_ = matched[1];
        }
        AsyncSlice.apply(this, arguments);
    }

    MeasureAsyncSlice.prototype = {
        __proto__: AsyncSlice.prototype, get viewSubGroupTitle() {
            return this.groupTitle_;
        }, get title() {
            return this.title_;
        }, set title(title) {
            this.title_ = title;
        }
    };
    AsyncSlice.subTypes.register(MeasureAsyncSlice, {categoryParts: ['blink.user_timing']});
    return {MEASURE_NAME_REGEX, MeasureAsyncSlice,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    function ContextProcessor(model) {
        this.model_ = model;
        this.activeContexts_ = [];
        this.stackPerType_ = {};
        this.contextCache_ = {};
        this.contextSetCache_ = {};
        this.cachedEntryForActiveContexts_ = undefined;
        this.seenSnapshots_ = {};
    }

    ContextProcessor.prototype = {
        enterContext(contextType, scopedId) {
            const newActiveContexts = [this.getOrCreateContext_(contextType, scopedId),];
            for (const oldContext of this.activeContexts_) {
                if (oldContext.type === contextType) {
                    this.pushContext_(oldContext);
                } else {
                    newActiveContexts.push(oldContext);
                }
            }
            this.activeContexts_ = newActiveContexts;
            this.cachedEntryForActiveContexts_ = undefined;
        }, leaveContext(contextType, scopedId) {
            this.leaveContextImpl_(context => context.type === contextType && context.snapshot.scope === scopedId.scope && context.snapshot.idRef === scopedId.id);
        }, destroyContext(scopedId) {
            for (const stack of Object.values(this.stackPerType_)) {
                let newLength = 0;
                for (let i = 0; i < stack.length; ++i) {
                    if (stack[i].snapshot.scope !== scopedId.scope || stack[i].snapshot.idRef !== scopedId.id) {
                        stack[newLength++] = stack[i];
                    }
                }
                stack.length = newLength;
            }
            this.leaveContextImpl_(context => context.snapshot.scope === scopedId.scope && context.snapshot.idRef === scopedId.id);
        }, leaveContextImpl_(predicate) {
            const newActiveContexts = [];
            for (const oldContext of this.activeContexts_) {
                if (predicate(oldContext)) {
                    const previousContext = this.popContext_(oldContext.type);
                    if (previousContext) {
                        newActiveContexts.push(previousContext);
                    }
                } else {
                    newActiveContexts.push(oldContext);
                }
            }
            this.activeContexts_ = newActiveContexts;
            this.cachedEntryForActiveContexts_ = undefined;
        }, getOrCreateContext_(contextType, scopedId) {
            const context = {type: contextType, snapshot: {scope: scopedId.scope, idRef: scopedId.id}};
            const key = this.getContextKey_(context);
            if (key in this.contextCache_) {
                return this.contextCache_[key];
            }
            this.contextCache_[key] = context;
            const snapshotKey = this.getSnapshotKey_(scopedId);
            this.seenSnapshots_[snapshotKey] = true;
            return context;
        }, pushContext_(context) {
            if (!(context.type in this.stackPerType_)) {
                this.stackPerType_[context.type] = [];
            }
            this.stackPerType_[context.type].push(context);
        }, popContext_(contextType) {
            if (!(contextType in this.stackPerType_)) {
                return undefined;
            }
            return this.stackPerType_[contextType].pop();
        }, getContextKey_(context) {
            return [context.type, context.snapshot.scope, context.snapshot.idRef].join('\x00');
        }, getSnapshotKey_(scopedId) {
            return [scopedId.scope, scopedId.idRef].join('\x00');
        }, get activeContexts() {
            if (this.cachedEntryForActiveContexts_ === undefined) {
                let key = [];
                for (const context of this.activeContexts_) {
                    key.push(this.getContextKey_(context));
                }
                key.sort();
                key = key.join('\x00');
                if (key in this.contextSetCache_) {
                    this.cachedEntryForActiveContexts_ = this.contextSetCache_[key];
                } else {
                    this.activeContexts_.sort(function (a, b) {
                        const keyA = this.getContextKey_(a);
                        const keyB = this.getContextKey_(b);
                        if (keyA < keyB) {
                            return -1;
                        }
                        if (keyA > keyB) {
                            return 1;
                        }
                        return 0;
                    }.bind(this));
                    this.contextSetCache_[key] = Object.freeze(this.activeContexts_);
                    this.cachedEntryForActiveContexts_ = this.contextSetCache_[key];
                }
            }
            return this.cachedEntryForActiveContexts_;
        }, invalidateContextCacheForSnapshot(scopedId) {
            const snapshotKey = this.getSnapshotKey_(scopedId);
            if (!(snapshotKey in this.seenSnapshots_)) return;
            this.contextCache_ = {};
            this.contextSetCache_ = {};
            this.cachedEntryForActiveContexts_ = undefined;
            this.activeContexts_ = this.activeContexts_.map(function (context) {
                if (context.snapshot.scope !== scopedId.scope || context.snapshot.idRef !== scopedId.id) {
                    return context;
                }
                return {
                    type: context.type,
                    snapshot: {scope: context.snapshot.scope, idRef: context.snapshot.idRef}
                };
            });
            this.seenSnapshots_ = {};
        },
    };
    return {ContextProcessor,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function Annotation() {
        this.guid_ = tr.b.GUID.allocateSimple();
        this.view_ = undefined;
    }

    Annotation.fromDictIfPossible = function (args) {
        if (args.typeName === undefined) {
            throw new Error('Missing typeName argument');
        }
        const typeInfo = Annotation.findTypeInfoMatching(function (typeInfo) {
            return typeInfo.metadata.typeName === args.typeName;
        });
        if (typeInfo === undefined) return undefined;
        return typeInfo.constructor.fromDict(args);
    };
    Annotation.fromDict = function () {
        throw new Error('Not implemented');
    };
    Annotation.prototype = {
        get guid() {
            return this.guid_;
        }, onRemove() {
        }, toDict() {
            throw new Error('Not implemented');
        }, getOrCreateView(viewport) {
            if (!this.view_) {
                this.view_ = this.createView_(viewport);
            }
            return this.view_;
        }, createView_() {
            throw new Error('Not implemented');
        }
    };
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    tr.b.decorateExtensionRegistry(Annotation, options);
    Annotation.addEventListener('will-register', function (e) {
        if (!e.typeInfo.constructor.hasOwnProperty('fromDict')) {
            throw new Error('Must have fromDict method');
        }
        if (!e.typeInfo.metadata.typeName) {
            throw new Error('Registered Annotations must provide typeName');
        }
    });
    return {Annotation,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function YComponent(stableId, yPercentOffset) {
        this.stableId = stableId;
        this.yPercentOffset = yPercentOffset;
    }

    YComponent.prototype = {
        toDict() {
            return {stableId: this.stableId, yPercentOffset: this.yPercentOffset};
        }
    };

    function Location(xWorld, yComponents) {
        this.xWorld_ = xWorld;
        this.yComponents_ = yComponents;
    }

    Location.fromViewCoordinates = function (viewport, viewX, viewY) {
        const dt = viewport.currentDisplayTransform;
        const xWorld = dt.xViewToWorld(viewX);
        const yComponents = [];
        let elem = document.elementFromPoint(viewX + viewport.modelTrackContainer.canvas.offsetLeft, viewY + viewport.modelTrackContainer.canvas.offsetTop);
        while (elem instanceof tr.ui.tracks.Track) {
            if (elem.eventContainer) {
                const boundRect = elem.getBoundingClientRect();
                const yPercentOffset = (viewY - boundRect.top) / boundRect.height;
                yComponents.push(new YComponent(elem.eventContainer.stableId, yPercentOffset));
            }
            elem = elem.parentElement;
        }
        if (yComponents.length === 0) return;
        return new Location(xWorld, yComponents);
    };
    Location.fromStableIdAndTimestamp = function (viewport, stableId, ts) {
        const xWorld = ts;
        const yComponents = [];
        const containerToTrack = viewport.containerToTrackMap;
        let elem = containerToTrack.getTrackByStableId(stableId);
        if (!elem) return;
        const firstY = elem.getBoundingClientRect().top;
        while (elem instanceof tr.ui.tracks.Track) {
            if (elem.eventContainer) {
                const boundRect = elem.getBoundingClientRect();
                const yPercentOffset = (firstY - boundRect.top) / boundRect.height;
                yComponents.push(new YComponent(elem.eventContainer.stableId, yPercentOffset));
            }
            elem = elem.parentElement;
        }
        if (yComponents.length === 0) return;
        return new Location(xWorld, yComponents);
    };
    Location.prototype = {
        get xWorld() {
            return this.xWorld_;
        }, getContainingTrack(viewport) {
            const containerToTrack = viewport.containerToTrackMap;
            for (const i in this.yComponents_) {
                const yComponent = this.yComponents_[i];
                const track = containerToTrack.getTrackByStableId(yComponent.stableId);
                if (track !== undefined) return track;
            }
        }, toViewCoordinates(viewport) {
            const dt = viewport.currentDisplayTransform;
            const containerToTrack = viewport.containerToTrackMap;
            const viewX = dt.xWorldToView(this.xWorld_);
            let viewY = -1;
            for (const index in this.yComponents_) {
                const yComponent = this.yComponents_[index];
                const track = containerToTrack.getTrackByStableId(yComponent.stableId);
                if (track !== undefined) {
                    const boundRect = track.getBoundingClientRect();
                    viewY = yComponent.yPercentOffset * boundRect.height + boundRect.top;
                    break;
                }
            }
            return {viewX, viewY};
        }, toDict() {
            return {xWorld: this.xWorld_, yComponents: this.yComponents_};
        }
    };
    return {Location,};
});
'use strict';
tr.exportTo('tr.ui.annotations', function () {
    function AnnotationView(viewport, annotation) {
    }

    AnnotationView.prototype = {
        draw(ctx) {
            throw new Error('Not implemented');
        }
    };
    return {AnnotationView,};
});
'use strict';
tr.exportTo('tr.ui.annotations', function () {
    function RectAnnotationView(viewport, annotation) {
        this.viewport_ = viewport;
        this.annotation_ = annotation;
    }

    RectAnnotationView.prototype = {
        __proto__: tr.ui.annotations.AnnotationView.prototype, draw(ctx) {
            const dt = this.viewport_.currentDisplayTransform;
            const startCoords = this.annotation_.startLocation.toViewCoordinates(this.viewport_);
            const endCoords = this.annotation_.endLocation.toViewCoordinates(this.viewport_);
            let startY = startCoords.viewY - ctx.canvas.getBoundingClientRect().top;
            const sizeY = endCoords.viewY - startCoords.viewY;
            if (startY + sizeY < 0) {
                startY = sizeY;
            } else if (startY < 0) {
                startY = 0;
            }
            ctx.fillStyle = this.annotation_.fillStyle;
            ctx.fillRect(startCoords.viewX, startY, endCoords.viewX - startCoords.viewX, sizeY);
        }
    };
    return {RectAnnotationView,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function RectAnnotation(start, end) {
        tr.model.Annotation.apply(this, arguments);
        this.startLocation_ = start;
        this.endLocation_ = end;
        this.fillStyle = 'rgba(255, 180, 0, 0.3)';
    }

    RectAnnotation.fromDict = function (dict) {
        const args = dict.args;
        const startLoc = new tr.model.Location(args.start.xWorld, args.start.yComponents);
        const endLoc = new tr.model.Location(args.end.xWorld, args.end.yComponents);
        return new tr.model.RectAnnotation(startLoc, endLoc);
    };
    RectAnnotation.prototype = {
        __proto__: tr.model.Annotation.prototype, get startLocation() {
            return this.startLocation_;
        }, get endLocation() {
            return this.endLocation_;
        }, toDict() {
            return {typeName: 'rect', args: {start: this.startLocation.toDict(), end: this.endLocation.toDict()}};
        }, createView_(viewport) {
            return new tr.ui.annotations.RectAnnotationView(viewport, this);
        }
    };
    tr.model.Annotation.register(RectAnnotation, {typeName: 'rect'});
    return {RectAnnotation,};
});
'use strict';
tr.exportTo('tr.ui.annotations', function () {
    function CommentBoxAnnotationView(viewport, annotation) {
        this.viewport_ = viewport;
        this.annotation_ = annotation;
        this.textArea_ = undefined;
        this.styleWidth = 250;
        this.styleHeight = 50;
        this.fontSize = 10;
        this.rightOffset = 50;
        this.topOffset = 25;
    }

    CommentBoxAnnotationView.prototype = {
        __proto__: tr.ui.annotations.AnnotationView.prototype, removeTextArea() {
            Polymer.dom(Polymer.dom(this.textArea_).parentNode).removeChild(this.textArea_);
        }, draw(ctx) {
            const coords = this.annotation_.location.toViewCoordinates(this.viewport_);
            if (coords.viewX < 0) {
                if (this.textArea_) {
                    this.textArea_.style.visibility = 'hidden';
                }
                return;
            }
            if (!this.textArea_) {
                this.textArea_ = document.createElement('textarea');
                this.textArea_.style.position = 'absolute';
                this.textArea_.readOnly = true;
                this.textArea_.value = this.annotation_.text;
                this.textArea_.style.zIndex = 1;
                Polymer.dom(Polymer.dom(ctx.canvas).parentNode).appendChild(this.textArea_);
            }
            this.textArea_.style.width = this.styleWidth + 'px';
            this.textArea_.style.height = this.styleHeight + 'px';
            this.textArea_.style.fontSize = this.fontSize + 'px';
            this.textArea_.style.visibility = 'visible';
            this.textArea_.style.left = coords.viewX + ctx.canvas.getBoundingClientRect().left +
                this.rightOffset + 'px';
            this.textArea_.style.top = coords.viewY - ctx.canvas.getBoundingClientRect().top -
                this.topOffset + 'px';
            ctx.strokeStyle = 'rgb(0, 0, 0)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            tr.ui.b.drawLine(ctx, coords.viewX, coords.viewY - ctx.canvas.getBoundingClientRect().top, coords.viewX + this.rightOffset, coords.viewY - this.topOffset -
                ctx.canvas.getBoundingClientRect().top);
            ctx.stroke();
        }
    };
    return {CommentBoxAnnotationView,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function CommentBoxAnnotation(location, text) {
        tr.model.Annotation.apply(this, arguments);
        this.location = location;
        this.text = text;
    }

    CommentBoxAnnotation.fromDict = function (dict) {
        const args = dict.args;
        const location = new tr.model.Location(args.location.xWorld, args.location.yComponents);
        return new tr.model.CommentBoxAnnotation(location, args.text);
    };
    CommentBoxAnnotation.prototype = {
        __proto__: tr.model.Annotation.prototype, onRemove() {
            this.view_.removeTextArea();
        }, toDict() {
            return {typeName: 'comment_box', args: {text: this.text, location: this.location.toDict()}};
        }, createView_(viewport) {
            return new tr.ui.annotations.CommentBoxAnnotationView(viewport, this);
        }
    };
    tr.model.Annotation.register(CommentBoxAnnotation, {typeName: 'comment_box'});
    return {CommentBoxAnnotation,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function ScopedId(scope, id, pid) {
        if (scope === undefined) {
            throw new Error('Scope should be defined. Use \'' +
                tr.model.OBJECT_DEFAULT_SCOPE + '\' as the default scope.');
        }
        this.scope = scope;
        this.id = id;
        this.pid = pid;
    }

    ScopedId.prototype = {
        toString() {
            const pidStr = this.pid === undefined ? '' : 'pid: ' + this.pid + ', ';
            return '{' + pidStr + 'scope: ' + this.scope + ', id: ' + this.id + '}';
        }, toStringWithDelimiter(delim) {
            return (this.pid === undefined ? '' : this.pid) + delim +
                this.scope + delim + this.id;
        }
    };
    return {ScopedId,};
});
'use strict';
tr.exportTo('tr.ui.annotations', function () {
    function XMarkerAnnotationView(viewport, annotation) {
        this.viewport_ = viewport;
        this.annotation_ = annotation;
    }

    XMarkerAnnotationView.prototype = {
        __proto__: tr.ui.annotations.AnnotationView.prototype, draw(ctx) {
            const dt = this.viewport_.currentDisplayTransform;
            const viewX = dt.xWorldToView(this.annotation_.timestamp);
            ctx.beginPath();
            tr.ui.b.drawLine(ctx, viewX, 0, viewX, ctx.canvas.height);
            ctx.strokeStyle = this.annotation_.strokeStyle;
            ctx.stroke();
        }
    };
    return {XMarkerAnnotationView,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function XMarkerAnnotation(timestamp) {
        tr.model.Annotation.apply(this, arguments);
        this.timestamp = timestamp;
        this.strokeStyle = 'rgba(0, 0, 255, 0.5)';
    }

    XMarkerAnnotation.fromDict = function (dict) {
        return new XMarkerAnnotation(dict.args.timestamp);
    };
    XMarkerAnnotation.prototype = {
        __proto__: tr.model.Annotation.prototype, toDict() {
            return {typeName: 'xmarker', args: {timestamp: this.timestamp}};
        }, createView_(viewport) {
            return new tr.ui.annotations.XMarkerAnnotationView(viewport, this);
        }
    };
    tr.model.Annotation.register(XMarkerAnnotation, {typeName: 'xmarker'});
    return {XMarkerAnnotation,};
});
'use strict';
tr.exportTo('tr.e.importer', function () {
    const Base64 = tr.b.Base64;
    const deepCopy = tr.b.deepCopy;
    const ColorScheme = tr.b.ColorScheme;
    const HeapDumpTraceEventImporter = tr.e.importer.HeapDumpTraceEventImporter;
    const LegacyHeapDumpTraceEventImporter = tr.e.importer.LegacyHeapDumpTraceEventImporter;
    const StreamingEventExpander = tr.e.importer.StreamingEventExpander;
    const ProfilingDictionaryReader = tr.e.importer.ProfilingDictionaryReader;
    const MEASURE_NAME_REGEX = tr.e.measure.MEASURE_NAME_REGEX;

    function getEventColor(event, opt_customName) {
        if (event.cname) {
            return ColorScheme.getColorIdForReservedName(event.cname);
        } else if (opt_customName || event.name) {
            return ColorScheme.getColorIdForGeneralPurposeString(opt_customName || event.name);
        }
    }

    function isLegacyChromeClockSyncEvent(event) {
        return event.name !== undefined && event.name.startsWith(LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX) && ((event.ph === 'S') || (event.ph === 'F'));
    }

    const PRODUCER = 'producer';
    const CONSUMER = 'consumer';
    const STEP = 'step';
    const BACKGROUND = tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;
    const LIGHT = tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;
    const DETAILED = tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;
    const MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER = [undefined, BACKGROUND, LIGHT, DETAILED];
    const GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX = 'global/';
    const LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX = 'ClockSyncEvent.';
    const BYTE_STAT_NAME_MAP = {
        'pc': 'privateCleanResident',
        'pd': 'privateDirtyResident',
        'sc': 'sharedCleanResident',
        'sd': 'sharedDirtyResident',
        'pss': 'proportionalResident',
        'sw': 'swapped'
    };
    const WEAK_MEMORY_ALLOCATOR_DUMP_FLAG = 1 << 0;
    const OBJECT_TYPE_NAME_PATTERNS = [{
        prefix: 'const char *WTF::getStringWithTypeName() [T = ',
        suffix: ']'
    }, {
        prefix: 'const char* WTF::getStringWithTypeName() [with T = ',
        suffix: ']'
    }, {prefix: 'const char *__cdecl WTF::getStringWithTypeName<', suffix: '>(void)'}];
    const SUBTRACE_FIELDS = new Set(['powerTraceAsString', 'systemTraceEvents', 'androidProcessDump',]);
    const NON_METADATA_FIELDS = new Set(['displayTimeUnit', 'samples', 'stackFrames', 'traceAnnotations', 'traceEvents', ...SUBTRACE_FIELDS]);

    function TraceEventImporter(model, eventData) {
        this.hasEvents_ = undefined;
        this.importPriority = 1;
        this.model_ = model;
        this.events_ = undefined;
        this.sampleEvents_ = undefined;
        this.stackFrameEvents_ = undefined;
        this.stackFrameTree_ = new tr.model.ProfileTree();
        this.subtraces_ = [];
        this.eventsWereFromString_ = false;
        this.softwareMeasuredCpuCount_ = undefined;
        this.allAsyncEvents_ = [];
        this.allFlowEvents_ = [];
        this.allObjectEvents_ = [];
        this.contextProcessorPerThread = {};
        this.traceEventSampleStackFramesByName_ = {};
        this.v8ProcessCodeMaps_ = {};
        this.v8ProcessRootStackFrame_ = {};
        this.v8SamplingData_ = [];
        this.profileTrees_ = new Map();
        this.profileInfo_ = new Map();
        this.legacyChromeClockSyncStartEvent_ = undefined;
        this.legacyChromeClockSyncFinishEvent_ = undefined;
        this.allMemoryDumpEvents_ = {};
        this.heapProfileExpander = new ProfilingDictionaryReader();
        this.objectTypeNameMap_ = {};
        this.clockDomainId_ = tr.model.ClockDomainId.UNKNOWN_CHROME_LEGACY;
        this.toModelTime_ = undefined;
        if (typeof (eventData) === 'string' || eventData instanceof String) {
            eventData = eventData.trim();
            if (eventData[0] === '[') {
                eventData = eventData.replace(/\s*,\s*$/, '');
                if (eventData[eventData.length - 1] !== ']') {
                    eventData = eventData + ']';
                }
            }
            this.events_ = JSON.parse(eventData);
            this.eventsWereFromString_ = true;
        } else {
            this.events_ = eventData;
        }
        if (this.events_.traceEvents) {
            const container = this.events_;
            this.events_ = this.events_.traceEvents;
            for (const subtraceField of SUBTRACE_FIELDS) {
                if (container[subtraceField]) {
                    this.storeSubtrace_(container[subtraceField]);
                }
            }
            this.storeSamples_(container.samples);
            this.storeStackFrames_(container.stackFrames);
            this.storeDisplayTimeUnit_(container.displayTimeUnit);
            this.storeTraceAnnotations_(container.traceAnnotations);
            this.storeMetadata_(container);
        } else if (this.events_ instanceof tr.b.TraceStream) {
            const parser = oboe().node('{cat ph}', function (e) {
                return oboe.drop;
            }).node('!.powerTraceAsString', this.storeSubtrace_.bind(this)).node('!.systemTraceEvents', this.storeSubtrace_.bind(this)).node('!.samples', this.storeSamples_.bind(this)).node('!.stackFrames', this.storeStackFrames_.bind(this)).node('!.displayTimeUnit', this.storeDisplayTimeUnit_.bind(this)).node('!.traceAnnotations', this.storeTraceAnnotations_.bind(this)).done(this.storeMetadata_.bind(this));
            this.events_.rewind();
            while (this.events_.hasData) {
                parser.write(this.events_.readNumBytes());
            }
            parser.finish();
        }
    }

    TraceEventImporter.canImport = function (eventData) {
        if (eventData instanceof tr.b.TraceStream) {
            if (eventData.isBinary) return false;
            eventData = eventData.header;
        }
        if (typeof (eventData) === 'string' || eventData instanceof String) {
            eventData = eventData.trim();
            return eventData[0] === '{' || eventData[0] === '[';
        }
        if (eventData instanceof Array && eventData.length && eventData[0].ph) {
            return true;
        }
        if (eventData.traceEvents) {
            if (eventData.traceEvents instanceof Array) {
                if (eventData.traceEvents.length && eventData.traceEvents[0].ph) {
                    return true;
                }
                if (eventData.samples && eventData.samples.length && eventData.stackFrames !== undefined) {
                    return true;
                }
            }
        }
        return false;
    };
    TraceEventImporter.scopedIdForEvent_ = function (event) {
        const scope = event.scope || tr.model.OBJECT_DEFAULT_SCOPE;
        let pid = undefined;
        if (event.id !== undefined) {
            if (event.id2 !== undefined) {
                throw new Error('Event has both id and id2');
            }
            pid = tr.model.LOCAL_ID_PHASES.has(event.ph) ? event.pid : undefined;
            return new tr.model.ScopedId(scope, event.id, pid);
        } else if (event.id2 !== undefined) {
            if (event.id2.global !== undefined) {
                return new tr.model.ScopedId(scope, event.id2.global);
            } else if (event.id2.local !== undefined) {
                return new tr.model.ScopedId(scope, event.id2.local, event.pid);
            }
            throw new Error('Event that uses id2 must have either a global or local ID');
        }
        return undefined;
    };
    TraceEventImporter.prototype = {
        __proto__: tr.importer.Importer.prototype,
        get importerName() {
            return 'TraceEventImporter';
        },
        extractSubtraces() {
            const subtraces = this.subtraces_;
            this.subtraces_ = [];
            return subtraces;
        },
        deepCopyIfNeeded_(obj) {
            if (obj === undefined) obj = {};
            if (this.eventsWereFromString_) return obj;
            return deepCopy(obj);
        },
        deepCopyAlways_(obj) {
            if (obj === undefined) obj = {};
            return deepCopy(obj);
        },
        processAsyncEvent(event) {
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            this.allAsyncEvents_.push({sequenceNumber: this.allAsyncEvents_.length, event, thread});
        },
        processFlowEvent(event, opt_slice) {
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            this.allFlowEvents_.push({
                refGuid: tr.b.GUID.getLastSimpleGuid(),
                sequenceNumber: this.allFlowEvents_.length,
                event,
                slice: opt_slice,
                thread
            });
        },
        processCounterEvent(event) {
            let ctrName;
            if (event.id !== undefined) {
                ctrName = event.name + '[' + event.id + ']';
            } else {
                ctrName = event.name;
            }
            const ctr = this.model_.getOrCreateProcess(event.pid).getOrCreateCounter(event.cat, ctrName);
            const reservedColorId = event.cname ? getEventColor(event) : undefined;
            if (ctr.numSeries === 0) {
                for (const seriesName in event.args) {
                    const colorId = reservedColorId || getEventColor(event, ctr.name + '.' + seriesName);
                    ctr.addSeries(new tr.model.CounterSeries(seriesName, colorId));
                }
                if (ctr.numSeries === 0) {
                    this.model_.importWarning({
                        type: 'counter_parse_error',
                        message: 'Expected counter ' + event.name + ' to have at least one argument to use as a value.'
                    });
                    delete ctr.parent.counters[ctr.name];
                    return;
                }
            }
            const ts = this.toModelTimeFromUs_(event.ts);
            ctr.series.forEach(function (series) {
                const val = event.args[series.name] ? event.args[series.name] : 0;
                series.addCounterSample(ts, val);
            });
        },
        processObjectEvent(event) {
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            this.allObjectEvents_.push({sequenceNumber: this.allObjectEvents_.length, event, thread});
            if (thread.guid in this.contextProcessorPerThread) {
                const processor = this.contextProcessorPerThread[thread.guid];
                const scopedId = TraceEventImporter.scopedIdForEvent_(event);
                if (event.ph === 'D') {
                    processor.destroyContext(scopedId);
                }
                processor.invalidateContextCacheForSnapshot(scopedId);
            }
        },
        processContextEvent(event) {
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            if (!(thread.guid in this.contextProcessorPerThread)) {
                this.contextProcessorPerThread[thread.guid] = new tr.importer.ContextProcessor(this.model_);
            }
            const scopedId = TraceEventImporter.scopedIdForEvent_(event);
            const contextType = event.name;
            const processor = this.contextProcessorPerThread[thread.guid];
            if (event.ph === '(') {
                processor.enterContext(contextType, scopedId);
            } else if (event.ph === ')') {
                processor.leaveContext(contextType, scopedId);
            } else {
                this.model_.importWarning({
                    type: 'unknown_context_phase',
                    message: 'Unknown context event phase: ' + event.ph + '.'
                });
            }
        },
        setContextsFromThread_(thread, slice) {
            if (thread.guid in this.contextProcessorPerThread) {
                slice.contexts = this.contextProcessorPerThread[thread.guid].activeContexts;
            }
        },
        processDurationEvent(event) {
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            const ts = this.toModelTimeFromUs_(event.ts);
            if (event.dur === 0 && !thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
                this.model_.importWarning({
                    type: 'duration_parse_error',
                    message: 'Timestamps are moving backward.'
                });
                return;
            }
            if (event.ph === 'B') {
                const slice = thread.sliceGroup.beginSlice(event.cat, event.name, this.toModelTimeFromUs_(event.ts), this.deepCopyIfNeeded_(event.args), this.toModelTimeFromUs_(event.tts), event.argsStripped, getEventColor(event), event.bind_id);
                slice.startStackFrame = this.getStackFrameForEvent_(event);
                this.setContextsFromThread_(thread, slice);
            } else if (event.ph === 'I' || event.ph === 'i' || event.ph === 'R') {
                if (event.s !== undefined && event.s !== 't') {
                    throw new Error('This should never happen');
                }
                thread.sliceGroup.beginSlice(event.cat, event.name, this.toModelTimeFromUs_(event.ts), this.deepCopyIfNeeded_(event.args), this.toModelTimeFromUs_(event.tts), event.argsStripped, getEventColor(event), event.bind_id);
                const slice = thread.sliceGroup.endSlice(this.toModelTimeFromUs_(event.ts), this.toModelTimeFromUs_(event.tts));
                slice.startStackFrame = this.getStackFrameForEvent_(event);
                slice.endStackFrame = undefined;
            } else {
                if (!thread.sliceGroup.openSliceCount) {
                    this.model_.importWarning({
                        type: 'duration_parse_error',
                        message: 'E phase event without a matching B phase event.'
                    });
                    return;
                }
                const slice = thread.sliceGroup.endSlice(this.toModelTimeFromUs_(event.ts), this.toModelTimeFromUs_(event.tts), getEventColor(event));
                if (event.name && slice.title !== event.name) {
                    this.model_.importWarning({
                        type: 'title_match_error', message: 'Titles do not match. Title is ' +
                            slice.title + ' in openSlice, and is ' +
                            event.name + ' in endSlice'
                    });
                }
                slice.endStackFrame = this.getStackFrameForEvent_(event);
                this.mergeArgsInto_(slice.args, event.args, slice.title);
            }
        },
        mergeArgsInto_(dstArgs, srcArgs, eventName) {
            for (const arg in srcArgs) {
                if (dstArgs[arg] !== undefined) {
                    this.model_.importWarning({
                        type: 'arg_merge_error',
                        message: 'Different phases of ' + eventName + ' provided values for argument ' + arg + '.' + ' The last provided value will be used.'
                    });
                }
                dstArgs[arg] = this.deepCopyIfNeeded_(srcArgs[arg]);
            }
        },
        processCompleteEvent(event) {
            if (event.cat !== undefined && event.cat.indexOf('trace_event_overhead') > -1) {
                return undefined;
            }
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            if (event.flow_out) {
                if (event.flow_in) {
                    event.flowPhase = STEP;
                } else {
                    event.flowPhase = PRODUCER;
                }
            } else if (event.flow_in) {
                event.flowPhase = CONSUMER;
            }
            const slice = thread.sliceGroup.pushCompleteSlice(event.cat, event.name, this.toModelTimeFromUs_(event.ts), this.maybeToModelTimeFromUs_(event.dur), this.maybeToModelTimeFromUs_(event.tts), this.maybeToModelTimeFromUs_(event.tdur), this.deepCopyIfNeeded_(event.args), event.argsStripped, getEventColor(event), event.bind_id);
            slice.startStackFrame = this.getStackFrameForEvent_(event);
            slice.endStackFrame = this.getStackFrameForEvent_(event, true);
            this.setContextsFromThread_(thread, slice);
            return slice;
        },
        processJitCodeEvent(event) {
            if (this.v8ProcessCodeMaps_[event.pid] === undefined) {
                this.v8ProcessCodeMaps_[event.pid] = new tr.e.importer.TraceCodeMap();
            }
            const map = this.v8ProcessCodeMaps_[event.pid];
            const data = event.args.data;
            if (event.name === 'JitCodeMoved') {
                map.moveEntry(data.code_start, data.new_code_start, data.code_len);
            } else {
                map.addEntry(data.code_start, data.code_len, data.name, data.script_id);
            }
        },
        processMetadataEvent(event) {
            if (event.name === 'JitCodeAdded' || event.name === 'JitCodeMoved') {
                this.v8SamplingData_.push(event);
                return;
            }
            if (event.argsStripped) return;
            if (event.name === 'process_name') {
                const process = this.model_.getOrCreateProcess(event.pid);
                process.name = event.args.name;
            } else if (event.name === 'process_labels') {
                const process = this.model_.getOrCreateProcess(event.pid);
                const labels = event.args.labels.split(',');
                for (let i = 0; i < labels.length; i++) {
                    process.addLabelIfNeeded(labels[i]);
                }
            } else if (event.name === 'process_uptime_seconds') {
                const process = this.model_.getOrCreateProcess(event.pid);
                process.uptime_seconds = event.args.uptime;
            } else if (event.name === 'process_sort_index') {
                const process = this.model_.getOrCreateProcess(event.pid);
                process.sortIndex = event.args.sort_index;
            } else if (event.name === 'thread_name') {
                const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
                thread.name = event.args.name;
            } else if (event.name === 'thread_sort_index') {
                const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
                thread.sortIndex = event.args.sort_index;
            } else if (event.name === 'num_cpus') {
                let n = event.args.number;
                if (this.softwareMeasuredCpuCount_ !== undefined) {
                    n = Math.max(n, this.softwareMeasuredCpuCount_);
                }
                this.softwareMeasuredCpuCount_ = n;
            } else if (event.name === 'stackFrames') {
                const stackFrames = event.args.stackFrames;
                if (stackFrames === undefined) {
                    this.model_.importWarning({
                        type: 'metadata_parse_error',
                        message: 'No stack frames found in a \'' + event.name + '\' metadata event'
                    });
                } else {
                    this.importStackFrames_(stackFrames, 'p' + event.pid + ':');
                }
            } else if (event.name === 'typeNames') {
                const objectTypeNameMap = event.args.typeNames;
                if (objectTypeNameMap === undefined) {
                    this.model_.importWarning({
                        type: 'metadata_parse_error',
                        message: 'No mapping from object type IDs to names found in a \'' +
                            event.name + '\' metadata event'
                    });
                } else {
                    this.importObjectTypeNameMap_(objectTypeNameMap, event.pid);
                }
            } else if (event.name === 'TraceConfig') {
                this.model_.metadata.push({name: 'TraceConfig', value: event.args.value});
            } else {
                this.model_.importWarning({
                    type: 'metadata_parse_error',
                    message: 'Unrecognized metadata name: ' + event.name
                });
            }
        },
        processInstantEvent(event) {
            if (event.name === 'JitCodeAdded' || event.name === 'JitCodeMoved') {
                this.v8SamplingData_.push(event);
                return;
            }
            if (event.s === 't' || event.s === undefined) {
                this.processDurationEvent(event);
                return;
            }
            let constructor;
            let parent;
            switch (event.s) {
                case'g':
                    constructor = tr.model.GlobalInstantEvent;
                    parent = this.model_;
                    break;
                case'p':
                    constructor = tr.model.ProcessInstantEvent;
                    parent = this.model_.getOrCreateProcess(event.pid);
                    break;
                default:
                    this.model_.importWarning({
                        type: 'instant_parse_error',
                        message: 'I phase event with unknown "s" field value.'
                    });
                    return;
            }
            const instantEvent = new constructor(event.cat, event.name, getEventColor(event), this.toModelTimeFromUs_(event.ts), this.deepCopyIfNeeded_(event.args), parent);
            parent.instantEvents.push(instantEvent);
        },
        getOrCreateProfileTree_(sampleType, id) {
            if (!this.profileTrees_.has(sampleType)) {
                this.profileTrees_.set(sampleType, new Map());
            }
            const profileTreeMap = this.profileTrees_.get(sampleType);
            if (profileTreeMap.has(id)) {
                return profileTreeMap.get(id);
            }
            const profileTree = new tr.model.ProfileTree();
            profileTreeMap.set(id, profileTree);
            const info = this.profileInfo_.get(id);
            if (info !== undefined) {
                profileTree.startTime = info.startTime;
                profileTree.pid = info.pid;
                profileTree.tid = info.tid;
            }
            return profileTree;
        },
        processSample(event) {
            if (event.args === undefined || event.args.data === undefined) {
                return;
            }
            if (event.id === undefined) {
                throw new Error('No event ID in sample');
            }
            const data = event.args.data;
            if (data.startTime !== undefined) {
                this.profileInfo_.set(event.id, {startTime: data.startTime, pid: event.pid, tid: event.tid});
            }
            const timeDeltas = data.timeDeltas;
            for (const sampleType in data) {
                if (sampleType === 'timeDeltas' || sampleType === 'startTime') {
                    continue;
                }
                if (data[sampleType].samples && timeDeltas && data[sampleType].samples.length !== timeDeltas.length) {
                    throw new Error('samples and timeDeltas array should have same length');
                }
                const profileTree = this.getOrCreateProfileTree_(sampleType, event.id);
                const nodes = data[sampleType].nodes;
                const samples = data[sampleType].samples;
                if (nodes !== undefined) {
                    for (const node of nodes) {
                        const ProfileNodeType = tr.model.ProfileNode.subTypes.getConstructor(undefined, sampleType);
                        const profileNode = ProfileNodeType.constructFromObject(profileTree, node);
                        if (profileNode === undefined) {
                            continue;
                        }
                        profileTree.add(profileNode);
                    }
                }
                if (samples !== undefined) {
                    const thread = this.model_.getOrCreateProcess(profileTree.pid).getOrCreateThread(profileTree.tid);
                    for (let i = 0, len = samples.length; i < len; ++i) {
                        const node = profileTree.getNode(samples[i]);
                        profileTree.endTime += timeDeltas[i];
                        if (node === undefined) continue;
                        const start = this.toModelTimeFromUs_(profileTree.endTime);
                        this.model_.samples.push(new tr.model.Sample(start, node.sampleTitle, node, thread));
                    }
                }
            }
        },
        processLegacyV8Sample(event) {
            const data = event.args.data;
            const sampleType = 'legacySample';
            const ProfileNodeType = tr.model.ProfileNode.subTypes.getConstructor(undefined, sampleType);
            if (data.vm_state === 'js' && !data.stack.length) return;
            const profileTree = this.getOrCreateProfileTree_(sampleType, event.pid);
            if (profileTree.getNode(-1) === undefined) {
                profileTree.add(new ProfileNodeType(-1, {
                    url: '',
                    scriptId: -1,
                    functionName: 'unknown'
                }, undefined));
            }
            let node = undefined;
            if (data.stack.length > 0 && this.v8ProcessCodeMaps_[event.pid]) {
                const map = this.v8ProcessCodeMaps_[event.pid];
                data.stack.reverse();
                let parentNode = undefined;
                for (let i = 0; i < data.stack.length; i++) {
                    const entry = map.lookupEntry(data.stack[i]);
                    if (entry === undefined) {
                        node = profileTree.getNode(-1);
                    } else {
                        node = profileTree.getNode(entry.id);
                        if (node === undefined) {
                            const sourceInfo = entry.sourceInfo;
                            node = new ProfileNodeType(entry.id, {
                                functionName: entry.name,
                                url: entry.sourceInfo.file,
                                lineNumber: sourceInfo.line !== -1 ? sourceInfo.line : undefined,
                                columnNumber: sourceInfo.column !== -1 ? sourceInfo.column : undefined,
                                scriptid: entry.sourceInfo.scriptId
                            }, parentNode);
                            profileTree.add(node);
                        }
                    }
                    parentNode = node;
                }
            } else {
                node = profileTree.getNode(data.vm_state);
                if (node === undefined) {
                    node = new ProfileNodeType(data.vm_state, {url: '', functionName: data.vm_state}, undefined);
                    profileTree.add(node);
                }
            }
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            this.model_.samples.push(new tr.model.Sample(this.toModelTimeFromUs_(event.ts), node.sampleTitle, node, thread));
        },
        processTraceSampleEvent(event) {
            if (event.name === 'V8Sample' || event.name.startsWith('Profile')) {
                this.v8SamplingData_.push(event);
                return;
            }
            let node = this.stackFrameTree_.getNode(event.name);
            if (node === undefined && event.sf !== undefined) {
                node = this.stackFrameTree_.getNode('g' + event.sf);
            }
            if (node === undefined) {
                let id = event.name;
                if (event.sf) {
                    id = 'g' + event.sf;
                }
                const ProfileNodeType = tr.model.ProfileNode.subTypes.getConstructor(undefined, 'legacySample');
                node = this.stackFrameTree_.add(new ProfileNodeType(id, {functionName: event.name}, undefined));
            }
            const thread = this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);
            const sample = new tr.model.Sample(this.toModelTimeFromUs_(event.ts), 'Trace Event Sample', node, thread, undefined, 1, this.deepCopyIfNeeded_(event.args));
            this.setContextsFromThread_(thread, sample);
            this.model_.samples.push(sample);
        },
        processMemoryDumpEvent(event) {
            if (event.ph !== 'v') {
                throw new Error('Invalid memory dump event phase "' + event.ph + '".');
            }
            const dumpId = event.id;
            if (dumpId === undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Memory dump event (phase \'' + event.ph + '\') without a dump ID.'
                });
                return;
            }
            const pid = event.pid;
            if (pid === undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Memory dump event (phase\'' + event.ph + '\', dump ID \'' +
                        dumpId + '\') without a PID.'
                });
                return;
            }
            const allEvents = this.allMemoryDumpEvents_;
            let dumpIdEvents = allEvents[dumpId];
            if (dumpIdEvents === undefined) {
                allEvents[dumpId] = dumpIdEvents = {};
            }
            let processEvents = dumpIdEvents[pid];
            if (processEvents === undefined) {
                dumpIdEvents[pid] = processEvents = [];
            }
            processEvents.push(event);
        },
        processClockSyncEvent(event) {
            if (event.ph !== 'c') {
                throw new Error('Invalid clock sync event phase "' + event.ph + '".');
            }
            const syncId = event.args.sync_id;
            if (syncId === undefined) {
                this.model_.importWarning({
                    type: 'clock_sync_parse_error',
                    message: 'Clock sync at time ' + event.ts + ' without an ID.'
                });
                return;
            }
            if (event.args && event.args.issue_ts !== undefined) {
                this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_, syncId, tr.b.Unit.timestampFromUs(event.args.issue_ts), tr.b.Unit.timestampFromUs(event.ts));
            } else {
                this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_, syncId, tr.b.Unit.timestampFromUs(event.ts));
            }
        },
        processLegacyChromeClockSyncEvent(event) {
            if (event.ph === 'S') {
                this.legacyChromeClockSyncStartEvent_ = event;
            } else if (event.ph === 'F') {
                this.legacyChromeClockSyncFinishEvent_ = event;
            }
            if (this.legacyChromeClockSyncStartEvent_ === undefined || this.legacyChromeClockSyncFinishEvent_ === undefined) {
                return;
            }
            const startSyncId = this.legacyChromeClockSyncStartEvent_.name.substring(LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX.length);
            const finishSyncId = this.legacyChromeClockSyncFinishEvent_.name.substring(LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX.length);
            if (startSyncId !== finishSyncId) {
                throw new Error('Inconsistent clock sync ID of legacy Chrome clock sync events');
            }
            this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_, startSyncId, tr.b.Unit.timestampFromUs(this.legacyChromeClockSyncStartEvent_.ts), tr.b.Unit.timestampFromUs(this.legacyChromeClockSyncFinishEvent_.ts));
        },
        processV8Events() {
            this.v8SamplingData_.sort(function (a, b) {
                if (a.ts !== b.ts) return a.ts - b.ts;
                if (a.ph === 'M' || a.ph === 'I') {
                    return -1;
                } else if (b.ph === 'M' || b.ph === 'I') {
                    return 1;
                }
                return 0;
            });
            const length = this.v8SamplingData_.length;
            for (let i = 0; i < length; ++i) {
                const event = this.v8SamplingData_[i];
                if (event.ph === 'M' || event.ph === 'I') {
                    this.processJitCodeEvent(event);
                } else if (event.ph === 'P') {
                    if (event.name.startsWith('Profile')) {
                        this.processSample(event);
                    } else {
                        this.processLegacyV8Sample(event);
                    }
                }
            }
        },
        importClockSyncMarkers() {
            if (this.events_ instanceof tr.b.TraceStream) {
                const parser = oboe().node('{cat ph}', this.importClockSyncMarker_.bind(this));
                this.events_.rewind();
                while (this.events_.hasData) {
                    parser.write(this.events_.readNumBytes());
                }
                parser.finish();
            } else {
                for (let i = 0; i < this.events_.length; i++) {
                    this.importClockSyncMarker_(this.events_[i]);
                }
            }
        },
        importClockSyncMarker_(event) {
            const isLegacyChromeClockSync = isLegacyChromeClockSyncEvent(event);
            if (event.ph !== 'c' && !isLegacyChromeClockSync) return;
            const eventSizeInBytes = this.model_.importOptions.trackDetailedModelStats ? JSON.stringify(event).length : undefined;
            this.model_.stats.willProcessBasicTraceEvent('clock_sync', event.cat, event.name, event.ts, eventSizeInBytes);
            if (isLegacyChromeClockSync) {
                this.processLegacyChromeClockSyncEvent(event);
            } else {
                this.processClockSyncEvent(event);
            }
        },
        importEvents() {
            this.hasEvents_ = false;
            if (this.stackFrameEvents_) {
                this.importStackFrames_(this.stackFrameEvents_, 'g');
            }
            if (this.traceAnnotations_) this.importAnnotations_();
            if (this.events_ instanceof tr.b.TraceStream) {
                const parser = oboe().node('{cat ph}', this.processEvent_.bind(this));
                this.events_.rewind();
                while (this.events_.hasData) {
                    parser.write(this.events_.readNumBytes());
                }
                parser.finish();
            } else {
                for (let eI = 0; eI < this.events_.length; eI++) {
                    this.processEvent_(this.events_[eI]);
                }
            }
            this.createAsyncSlices_();
            this.processV8Events();
            for (const frame of Object.values(this.v8ProcessRootStackFrame_)) {
                frame.removeAllChildren();
            }
        },
        storeSubtrace_(subtrace) {
            this.subtraces_.push(subtrace);
            return oboe.drop;
        },
        storeSamples_(samples) {
            this.sampleEvents_ = samples;
            return oboe.drop;
        },
        storeStackFrames_(stackFrames) {
            this.stackFrameEvents_ = stackFrames;
            return oboe.drop;
        },
        storeDisplayTimeUnit_(unitName) {
            if (!unitName) return;
            const unit = tr.b.TimeDisplayModes[unitName];
            if (unit === undefined) {
                throw new Error('Unit ' + unitName + ' is not supported.');
            }
            this.model_.intrinsicTimeUnit = unit;
            return oboe.drop;
        },
        storeTraceAnnotations_(traceAnnotations) {
            this.traceAnnotations_ = traceAnnotations;
            return oboe.drop;
        },
        storeMetadata_(container) {
            for (const fieldName of Object.keys(container)) {
                if (NON_METADATA_FIELDS.has(fieldName)) continue;
                this.model_.metadata.push({name: fieldName, value: container[fieldName]});
                if (fieldName !== 'metadata') continue;
                const metadata = container[fieldName];
                if (metadata['highres-ticks']) {
                    this.model_.isTimeHighResolution = metadata['highres-ticks'];
                }
                if (metadata['clock-domain']) {
                    this.clockDomainId_ = metadata['clock-domain'];
                }
            }
            return oboe.drop;
        },
        processEvent_(event) {
            this.hasEvents_ = true;
            const importOptions = this.model_.importOptions;
            const trackDetailedModelStats = importOptions.trackDetailedModelStats;
            const modelStats = this.model_.stats;
            if (event.args === '__stripped__') {
                event.argsStripped = true;
                event.args = undefined;
            }
            let eventSizeInBytes = undefined;
            if (trackDetailedModelStats) {
                eventSizeInBytes = JSON.stringify(event).length;
            }
            switch (event.ph) {
                case'B':
                case'E':
                    modelStats.willProcessBasicTraceEvent('begin_end (non-compact)', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processDurationEvent(event);
                    break;
                case'X': {
                    modelStats.willProcessBasicTraceEvent('begin_end (compact)', event.cat, event.name, event.ts, eventSizeInBytes);
                    const slice = this.processCompleteEvent(event);
                    if (slice !== undefined && event.bind_id !== undefined) {
                        this.processFlowEvent(event, slice);
                    }
                    break;
                }
                case'b':
                case'e':
                case'n':
                case'S':
                case'F':
                case'T':
                case'p':
                    modelStats.willProcessBasicTraceEvent('async', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processAsyncEvent(event);
                    break;
                case'I':
                case'i':
                case'R':
                    modelStats.willProcessBasicTraceEvent('instant', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processInstantEvent(event);
                    break;
                case'P':
                    modelStats.willProcessBasicTraceEvent('samples', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processTraceSampleEvent(event);
                    break;
                case'C':
                    modelStats.willProcessBasicTraceEvent('counters', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processCounterEvent(event);
                    break;
                case'M':
                    modelStats.willProcessBasicTraceEvent('metadata', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processMetadataEvent(event);
                    break;
                case'N':
                case'D':
                case'O':
                    modelStats.willProcessBasicTraceEvent('objects', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processObjectEvent(event);
                    break;
                case's':
                case't':
                case'f':
                    modelStats.willProcessBasicTraceEvent('flows', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processFlowEvent(event);
                    break;
                case'v':
                    modelStats.willProcessBasicTraceEvent('memory_dumps', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.processMemoryDumpEvent(event);
                    break;
                case'(':
                case')':
                    this.processContextEvent(event);
                    break;
                case'c':
                    break;
                default:
                    modelStats.willProcessBasicTraceEvent('unknown', event.cat, event.name, event.ts, eventSizeInBytes);
                    this.model_.importWarning({
                        type: 'parse_error', message: 'Unrecognized event phase: ' +
                            event.ph + ' (' + event.name + ')'
                    });
            }
            return oboe.drop;
        },
        importStackFrames_(rawStackFrames, idPrefix) {
            const model = this.model_;
            for (const id in rawStackFrames) {
                const rawStackFrame = rawStackFrames[id];
                const fullId = idPrefix + id;
                const textForColor = rawStackFrame.category ? rawStackFrame.category : rawStackFrame.name;
                const stackFrame = new tr.model.StackFrame(undefined, fullId, rawStackFrame.name, ColorScheme.getColorIdForGeneralPurposeString(textForColor));
                model.addStackFrame(stackFrame);
            }
            for (const id in rawStackFrames) {
                const fullId = idPrefix + id;
                const stackFrame = model.stackFrames[fullId];
                if (stackFrame === undefined) {
                    throw new Error('Internal error');
                }
                const rawStackFrame = rawStackFrames[id];
                const parentId = rawStackFrame.parent;
                let parentStackFrame;
                if (parentId === undefined) {
                    parentStackFrame = undefined;
                } else {
                    const parentFullId = idPrefix + parentId;
                    parentStackFrame = model.stackFrames[parentFullId];
                    if (parentStackFrame === undefined) {
                        this.model_.importWarning({
                            type: 'metadata_parse_error',
                            message: 'Missing parent frame with ID ' + parentFullId + ' for stack frame \'' + stackFrame.name + '\' (ID ' + fullId + ').'
                        });
                    }
                }
                stackFrame.parentFrame = parentStackFrame;
            }
            const ProfileNodeType = tr.model.ProfileNode.subTypes.getConstructor(undefined, 'legacySample');
            if (idPrefix === 'g') {
                for (const id in rawStackFrames) {
                    const rawStackFrame = rawStackFrames[id];
                    const textForColor = rawStackFrame.category ? rawStackFrame.category : rawStackFrame.name;
                    const node = this.stackFrameTree_.add(new ProfileNodeType('g' + id, {functionName: rawStackFrame.name}, undefined));
                    node.colorId = ColorScheme.getColorIdForGeneralPurposeString(textForColor);
                    node.parentId = rawStackFrame.parent;
                }
                for (const id in rawStackFrames) {
                    const node = this.stackFrameTree_.getNode('g' + id);
                    const parentId = node.parentId;
                    let parentNode = undefined;
                    if (parentId !== undefined) {
                        parentNode = this.stackFrameTree_.getNode('g' + parentId);
                        if (parentNode === undefined) {
                            this.model_.importWarning({
                                type: 'metadata_parse_error',
                                message: 'Missing parent frame with ID ' + parentId + ' for stack frame \'' + node.name + '\' (ID ' + node.id + ').'
                            });
                        }
                        node.parentNode = parentNode;
                    }
                }
            }
        },
        importObjectTypeNameMap_(rawObjectTypeNameMap, pid) {
            if (pid in this.objectTypeNameMap_) {
                this.model_.importWarning({
                    type: 'metadata_parse_error',
                    message: 'Mapping from object type IDs to names provided for pid=' +
                        pid + ' multiple times.'
                });
                return;
            }
            let objectTypeNamePrefix = undefined;
            let objectTypeNameSuffix = undefined;
            const objectTypeNameMap = {};
            for (const objectTypeId in rawObjectTypeNameMap) {
                const rawObjectTypeName = rawObjectTypeNameMap[objectTypeId];
                if (objectTypeNamePrefix === undefined) {
                    for (let i = 0; i < OBJECT_TYPE_NAME_PATTERNS.length; i++) {
                        const pattern = OBJECT_TYPE_NAME_PATTERNS[i];
                        if (rawObjectTypeName.startsWith(pattern.prefix) && rawObjectTypeName.endsWith(pattern.suffix)) {
                            objectTypeNamePrefix = pattern.prefix;
                            objectTypeNameSuffix = pattern.suffix;
                            break;
                        }
                    }
                }
                if (objectTypeNamePrefix !== undefined && rawObjectTypeName.startsWith(objectTypeNamePrefix) && rawObjectTypeName.endsWith(objectTypeNameSuffix)) {
                    objectTypeNameMap[objectTypeId] = rawObjectTypeName.substring(objectTypeNamePrefix.length, rawObjectTypeName.length - objectTypeNameSuffix.length);
                } else {
                    objectTypeNameMap[objectTypeId] = rawObjectTypeName;
                }
            }
            this.objectTypeNameMap_[pid] = objectTypeNameMap;
        },
        importAnnotations_() {
            for (const id in this.traceAnnotations_) {
                const annotation = tr.model.Annotation.fromDictIfPossible(this.traceAnnotations_[id]);
                if (!annotation) {
                    this.model_.importWarning({
                        type: 'annotation_warning', message: 'Unrecognized traceAnnotation typeName \"' +
                            this.traceAnnotations_[id].typeName + '\"'
                    });
                    continue;
                }
                this.model_.addAnnotation(annotation);
            }
        },
        finalizeImport() {
            if (this.softwareMeasuredCpuCount_ !== undefined) {
                this.model_.kernel.softwareMeasuredCpuCount = this.softwareMeasuredCpuCount_;
            }
            this.createFlowSlices_();
            this.createExplicitObjects_();
            this.createImplicitObjects_();
            this.createMemoryDumps_();
        },
        getStackFrameForEvent_(event, opt_lookForEndEvent) {
            let sf;
            let stack;
            if (opt_lookForEndEvent) {
                sf = event.esf;
                stack = event.estack;
            } else {
                sf = event.sf;
                stack = event.stack;
            }
            if (stack !== undefined && sf !== undefined) {
                this.model_.importWarning({
                    type: 'stack_frame_and_stack_error',
                    message: 'Event at ' + event.ts + ' cannot have both a stack and a stackframe.'
                });
                return undefined;
            }
            if (stack !== undefined) {
                return this.model_.resolveStackToStackFrame_(event.pid, stack);
            }
            if (sf === undefined) return undefined;
            const stackFrame = this.model_.stackFrames['g' + sf];
            if (stackFrame === undefined) {
                this.model_.importWarning({type: 'sample_import_error', message: 'No frame for ' + sf});
                return;
            }
            return stackFrame;
        },
        resolveStackToStackFrame_(pid, stack) {
            return undefined;
        },
        importSampleData() {
            if (!this.sampleEvents_) return;
            const m = this.model_;
            const events = this.sampleEvents_;
            if (this.hasEvents_ === undefined) {
                throw new Error('importEvents is not run before importSampleData');
            } else if (!this.hasEvents_) {
                for (let i = 0; i < events.length; i++) {
                    const event = events[i];
                    m.getOrCreateProcess(event.tid).getOrCreateThread(event.tid);
                }
            }
            const threadsByTid = {};
            m.getAllThreads().forEach(function (t) {
                threadsByTid[t.tid] = t;
            });
            for (let i = 0; i < events.length; i++) {
                const event = events[i];
                const thread = threadsByTid[event.tid];
                if (thread === undefined) {
                    m.importWarning({type: 'sample_import_error', message: 'Thread ' + events.tid + 'not found'});
                    continue;
                }
                let cpu;
                if (event.cpu !== undefined) {
                    cpu = m.kernel.getOrCreateCpu(event.cpu);
                }
                const leafNode = this.stackFrameTree_.getNode('g' + event.sf);
                const sample = new tr.model.Sample(this.toModelTimeFromUs_(event.ts), event.name, leafNode, thread, cpu, event.weight);
                m.samples.push(sample);
            }
        },
        createAsyncSlices_() {
            if (this.allAsyncEvents_.length === 0) return;
            this.allAsyncEvents_.sort(function (x, y) {
                const d = x.event.ts - y.event.ts;
                if (d !== 0) return d;
                return x.sequenceNumber - y.sequenceNumber;
            });
            const legacyEvents = [];
            const nestableAsyncEventsByKey = {};
            const nestableMeasureAsyncEventsByKey = {};
            for (let i = 0; i < this.allAsyncEvents_.length; i++) {
                const asyncEventState = this.allAsyncEvents_[i];
                const event = asyncEventState.event;
                if (event.ph === 'S' || event.ph === 'F' || event.ph === 'T' || event.ph === 'p') {
                    legacyEvents.push(asyncEventState);
                    continue;
                }
                if (event.cat === undefined) {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error',
                        message: 'Nestable async events (ph: b, e, or n) require a ' + 'cat parameter.'
                    });
                    continue;
                }
                if (event.name === undefined) {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error',
                        message: 'Nestable async events (ph: b, e, or n) require a ' + 'name parameter.'
                    });
                    continue;
                }
                const id = TraceEventImporter.scopedIdForEvent_(event);
                if (id === undefined) {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error',
                        message: 'Nestable async events (ph: b, e, or n) require an ' + 'id parameter.'
                    });
                    continue;
                }
                if (event.cat === 'blink.user_timing') {
                    const matched = MEASURE_NAME_REGEX.exec(event.name);
                    if (matched !== null) {
                        const key = matched[1] + ':' + event.cat;
                        try {
                            event.args = JSON.parse(Base64.atob(matched[3]) || '{}');
                        } catch (e) {
                        }
                        if (nestableMeasureAsyncEventsByKey[key] === undefined) {
                            nestableMeasureAsyncEventsByKey[key] = [];
                        }
                        nestableMeasureAsyncEventsByKey[key].push(asyncEventState);
                        continue;
                    }
                }
                const key = event.cat + ':' + id.toStringWithDelimiter(':');
                if (nestableAsyncEventsByKey[key] === undefined) {
                    nestableAsyncEventsByKey[key] = [];
                }
                nestableAsyncEventsByKey[key].push(asyncEventState);
            }
            this.createLegacyAsyncSlices_(legacyEvents);
            this.createNestableAsyncSlices_(nestableMeasureAsyncEventsByKey);
            this.createNestableAsyncSlices_(nestableAsyncEventsByKey);
        },
        createLegacyAsyncSlice_(events) {
            const asyncEventState = events[events.length - 1];
            const event = asyncEventState.event;
            const name = event.name;
            const id = TraceEventImporter.scopedIdForEvent_(event);
            const key = id.toStringWithDelimiter(':');
            const asyncSliceConstructor = tr.model.AsyncSlice.subTypes.getConstructor(events[0].event.cat, name);
            let duration;
            if (event.ts !== undefined) {
                duration = this.toModelTimeFromUs_(event.ts - events[0].event.ts);
            }
            const slice = new asyncSliceConstructor(events[0].event.cat, name, getEventColor(events[0].event), this.toModelTimeFromUs_(events[0].event.ts), Object.assign({}, events[0].event.args, event.args), duration || 0, true, undefined, undefined, events[0].event.argsStripped);
            if (duration === undefined) {
                slice.didNotFinish = true;
                slice.error = 'Slice has no matching END. End time has been adjusted.';
                this.model_.importWarning({
                    type: 'async_slice_parse_error', message: 'Legacy async BEGIN event at ' +
                        events[0].event.ts + ' with name="' +
                        name + '" and id=' + key + ' was unmatched.'
                });
            }
            slice.startThread = events[0].thread;
            slice.endThread = asyncEventState.thread;
            slice.id = key;
            const stepType = events[1].event.ph;
            let isValid = true;
            for (let j = 1; j < events.length - 1; ++j) {
                if (events[j].event.ph === 'T' || events[j].event.ph === 'p') {
                    isValid = this.assertStepTypeMatches_(stepType, events[j]);
                    if (!isValid) break;
                }
                if (events[j].event.ph === 'S') {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error', message: 'At ' + events[j].event.ts + ', a slice named "' +
                            name + '" with id=' + id + ' had a step before the start event.'
                    });
                    continue;
                }
                if (events[j].event.ph === 'F') {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error', message: 'At ' + events[j].event.ts + ', a slice named ' +
                            name + ' with id=' + id + ' had a step after the finish event.'
                    });
                    continue;
                }
                const startIndex = j + (stepType === 'T' ? 0 : -1);
                const endIndex = startIndex + 1;
                let subName = name;
                if (!events[j].event.argsStripped && (events[j].event.ph === 'T' || events[j].event.ph === 'p')) {
                    subName = events[j].event.args.step;
                }
                const asyncSliceConstructor = tr.model.AsyncSlice.subTypes.getConstructor(events[0].event.cat, subName);
                let duration;
                if (events[endIndex].event.ts !== undefined) {
                    duration = this.toModelTimeFromUs_(events[endIndex].event.ts - events[startIndex].event.ts);
                }
                const subSlice = new asyncSliceConstructor(events[0].event.cat, subName, getEventColor(events[0].event, subName + j), this.toModelTimeFromUs_(events[startIndex].event.ts), this.deepCopyIfNeeded_(events[j].event.args), duration || 0, undefined, undefined, events[startIndex].event.argsStripped);
                if (duration === undefined) {
                    subSlice.didNotFinish = true;
                    subSlice.error = 'Slice has no matching END. End time has been adjusted.';
                }
                subSlice.startThread = events[startIndex].thread;
                subSlice.endThread = events[endIndex].thread;
                subSlice.id = key;
                slice.subSlices.push(subSlice);
            }
            if (isValid) {
                slice.startThread.asyncSliceGroup.push(slice);
            }
        },
        createLegacyAsyncSlices_(legacyEvents) {
            if (legacyEvents.length === 0) return;
            legacyEvents.sort(function (x, y) {
                const d = x.event.ts - y.event.ts;
                if (d !== 0) return d;
                return x.sequenceNumber - y.sequenceNumber;
            });
            const asyncEventStatesByNameThenID = {};
            for (let i = 0; i < legacyEvents.length; i++) {
                const asyncEventState = legacyEvents[i];
                const event = asyncEventState.event;
                const name = event.name;
                if (name === undefined) {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error',
                        message: 'Async events (ph: S, T, p, or F) require a name ' + ' parameter.'
                    });
                    continue;
                }
                const id = TraceEventImporter.scopedIdForEvent_(event);
                if (id === undefined) {
                    this.model_.importWarning({
                        type: 'async_slice_parse_error',
                        message: 'Async events (ph: S, T, p, or F) require an id parameter.'
                    });
                    continue;
                }
                const key = id.toStringWithDelimiter(':');
                if (event.ph === 'S') {
                    if (asyncEventStatesByNameThenID[name] === undefined) {
                        asyncEventStatesByNameThenID[name] = {};
                    }
                    if (asyncEventStatesByNameThenID[name][key]) {
                        this.model_.importWarning({
                            type: 'async_slice_parse_error',
                            message: 'At ' + event.ts + ', a slice of the same id ' + id + ' was alrady open.'
                        });
                        continue;
                    }
                    asyncEventStatesByNameThenID[name][key] = [];
                    asyncEventStatesByNameThenID[name][key].push(asyncEventState);
                } else {
                    if (asyncEventStatesByNameThenID[name] === undefined) {
                        this.model_.importWarning({
                            type: 'async_slice_parse_error',
                            message: `At ${event.ts}, no slice named "${name}" was open.`,
                        });
                        continue;
                    }
                    if (asyncEventStatesByNameThenID[name][key] === undefined) {
                        this.model_.importWarning({
                            type: 'async_slice_parse_error',
                            message: `At ${event.ts}, no slice named "${name}" with id=${id} was ` + 'open.',
                        });
                        continue;
                    }
                    const events = asyncEventStatesByNameThenID[name][key];
                    events.push(asyncEventState);
                    if (event.ph === 'F') {
                        this.createLegacyAsyncSlice_(events);
                        delete asyncEventStatesByNameThenID[name][key];
                    }
                }
            }
            for (const [name, statesByID] of
                Object.entries(asyncEventStatesByNameThenID)) {
                for (const [id, states] of Object.entries(statesByID)) {
                    const startEvent = states[0].event;
                    states.push({
                        sequenceNumber: 1 + states[states.length - 1].sequenceNumber,
                        event: {
                            ph: 'F',
                            name,
                            id: startEvent.id,
                            id2: startEvent.id2,
                            scope: startEvent.scope,
                            pid: startEvent.pid,
                            tid: startEvent.tid,
                            cat: startEvent.cat,
                            args: {},
                        },
                        thread: this.model_.getOrCreateProcess(startEvent.pid).getOrCreateThread(startEvent.tid),
                    });
                    this.createLegacyAsyncSlice_(states);
                }
            }
        },
        createNestableAsyncSlices_(nestableEventsByKey) {
            for (const key in nestableEventsByKey) {
                const eventStateEntries = nestableEventsByKey[key];
                const parentStack = [];
                for (let i = 0; i < eventStateEntries.length; ++i) {
                    const eventStateEntry = eventStateEntries[i];
                    if (eventStateEntry.event.ph === 'e') {
                        let parentIndex = -1;
                        for (let k = parentStack.length - 1; k >= 0; --k) {
                            if (parentStack[k].event.name === eventStateEntry.event.name) {
                                parentIndex = k;
                                break;
                            }
                        }
                        if (parentIndex === -1) {
                            eventStateEntry.finished = false;
                        } else {
                            parentStack[parentIndex].end = eventStateEntry;
                            while (parentIndex < parentStack.length) {
                                parentStack.pop();
                            }
                        }
                    }
                    if (parentStack.length > 0) {
                        eventStateEntry.parentEntry = parentStack[parentStack.length - 1];
                    }
                    if (eventStateEntry.event.ph === 'b') {
                        parentStack.push(eventStateEntry);
                    }
                }
                const topLevelSlices = [];
                for (let i = 0; i < eventStateEntries.length; ++i) {
                    const eventStateEntry = eventStateEntries[i];
                    if (eventStateEntry.event.ph === 'e' && eventStateEntry.finished === undefined) {
                        continue;
                    }
                    let startState = undefined;
                    let endState = undefined;
                    let sliceArgs = eventStateEntry.event.args || {};
                    let sliceError = undefined;
                    const id = TraceEventImporter.scopedIdForEvent_(eventStateEntry.event);
                    if (eventStateEntry.event.ph === 'n') {
                        startState = eventStateEntry;
                        endState = eventStateEntry;
                    } else if (eventStateEntry.event.ph === 'b') {
                        if (eventStateEntry.end === undefined) {
                            eventStateEntry.end = eventStateEntries[eventStateEntries.length - 1];
                            sliceError = 'Slice has no matching END. End time has been adjusted.';
                            this.model_.importWarning({
                                type: 'async_slice_parse_error', message: 'Nestable async BEGIN event at ' +
                                    eventStateEntry.event.ts + ' with name="' +
                                    eventStateEntry.event.name + '" and id=' + id + ' was unmatched.'
                            });
                        } else {
                            function concatenateArguments(args1, args2) {
                                if (args1.params === undefined || args2.params === undefined) {
                                    return Object.assign({}, args1, args2);
                                }
                                const args3 = {};
                                args3.params = Object.assign({}, args1.params, args2.params);
                                return Object.assign({}, args1, args2, args3);
                            }

                            const endArgs = eventStateEntry.end.event.args || {};
                            sliceArgs = concatenateArguments(sliceArgs, endArgs);
                        }
                        startState = eventStateEntry;
                        endState = eventStateEntry.end;
                    } else {
                        sliceError = 'Slice has no matching BEGIN. Start time has been adjusted.';
                        this.model_.importWarning({
                            type: 'async_slice_parse_error', message: 'Nestable async END event at ' +
                                eventStateEntry.event.ts + ' with name=' +
                                eventStateEntry.event.name + ' and id=' + id + ' was unmatched.'
                        });
                        startState = eventStateEntries[0];
                        endState = eventStateEntry;
                    }
                    const isTopLevel = (eventStateEntry.parentEntry === undefined);
                    const asyncSliceConstructor = tr.model.AsyncSlice.subTypes.getConstructor(eventStateEntry.event.cat, eventStateEntry.event.name);
                    let threadStart = undefined;
                    let threadDuration = undefined;
                    if (startState.event.tts && startState.event.use_async_tts) {
                        threadStart = this.toModelTimeFromUs_(startState.event.tts);
                        if (endState.event.tts) {
                            const threadEnd = this.toModelTimeFromUs_(endState.event.tts);
                            threadDuration = threadEnd - threadStart;
                        }
                    }
                    const slice = new asyncSliceConstructor(eventStateEntry.event.cat, eventStateEntry.event.name, getEventColor(endState.event), this.toModelTimeFromUs_(startState.event.ts), sliceArgs, this.toModelTimeFromUs_(endState.event.ts - startState.event.ts), isTopLevel, threadStart, threadDuration, startState.event.argsStripped);
                    slice.startThread = startState.thread;
                    slice.endThread = endState.thread;
                    slice.startStackFrame = this.getStackFrameForEvent_(startState.event);
                    slice.endStackFrame = this.getStackFrameForEvent_(endState.event);
                    slice.id = key;
                    if (sliceError !== undefined) {
                        slice.error = sliceError;
                    }
                    eventStateEntry.slice = slice;
                    if (isTopLevel) {
                        topLevelSlices.push(slice);
                    } else if (eventStateEntry.parentEntry.slice !== undefined) {
                        eventStateEntry.parentEntry.slice.subSlices.push(slice);
                    }
                }
                for (let si = 0; si < topLevelSlices.length; si++) {
                    topLevelSlices[si].startThread.asyncSliceGroup.push(topLevelSlices[si]);
                }
            }
        },
        assertStepTypeMatches_(stepType, event) {
            if (stepType !== event.event.ph) {
                this.model_.importWarning({
                    type: 'async_slice_parse_error', message: 'At ' + event.event.ts + ', a slice named ' +
                        event.event.name + ' with id=' +
                        TraceEventImporter.scopedIdForEvent_(event.event) + ' had both begin and end steps, which is not allowed.'
                });
                return false;
            }
            return true;
        },
        validateFlowEvent_(event) {
            if (event.name === undefined) {
                this.model_.importWarning({
                    type: 'flow_slice_parse_error',
                    message: 'Flow events (ph: s, t or f) require a name parameter.'
                });
                return false;
            }
            if (event.ph === 's' || event.ph === 'f' || event.ph === 't') {
                if (event.id === undefined) {
                    this.model_.importWarning({
                        type: 'flow_slice_parse_error',
                        message: 'Flow events (ph: s, t or f) require an id parameter.'
                    });
                    return false;
                }
                return true;
            }
            if (event.bind_id) {
                if (event.flow_in === undefined && event.flow_out === undefined) {
                    this.model_.importWarning({
                        type: 'flow_slice_parse_error',
                        message: 'Flow producer or consumer require flow_in or flow_out.'
                    });
                    return false;
                }
                return true;
            }
            return false;
        },
        createFlowSlices_() {
            if (this.allFlowEvents_.length === 0) return;
            const createFlowEvent = function (thread, event, opt_slice) {
                let startSlice;
                let flowId;
                let flowStartTs;
                if (event.bind_id) {
                    startSlice = opt_slice;
                    flowId = event.bind_id;
                    flowStartTs = this.toModelTimeFromUs_(event.ts + event.dur);
                } else {
                    const ts = this.toModelTimeFromUs_(event.ts);
                    startSlice = thread.sliceGroup.findSliceAtTs(ts);
                    if (startSlice === undefined) return undefined;
                    flowId = event.id;
                    flowStartTs = ts;
                }
                const flowEvent = new tr.model.FlowEvent(event.cat, flowId, event.name, getEventColor(event), flowStartTs, this.deepCopyAlways_(event.args));
                flowEvent.startSlice = startSlice;
                flowEvent.startStackFrame = this.getStackFrameForEvent_(event);
                flowEvent.endStackFrame = undefined;
                startSlice.outFlowEvents.push(flowEvent);
                return flowEvent;
            }.bind(this);
            const finishFlowEventWith = function (flowEvent, thread, event, refGuid, bindToParent, opt_slice) {
                let endSlice;
                if (event.bind_id) {
                    endSlice = opt_slice;
                } else {
                    const ts = this.toModelTimeFromUs_(event.ts);
                    if (bindToParent) {
                        endSlice = thread.sliceGroup.findSliceAtTs(ts);
                    } else {
                        endSlice = thread.sliceGroup.findNextSliceAfter(ts, refGuid);
                    }
                    if (endSlice === undefined) return false;
                }
                endSlice.inFlowEvents.push(flowEvent);
                flowEvent.endSlice = endSlice;
                flowEvent.duration = this.toModelTimeFromUs_(event.ts) - flowEvent.start;
                flowEvent.endStackFrame = this.getStackFrameForEvent_(event);
                this.mergeArgsInto_(flowEvent.args, event.args, flowEvent.title);
                return true;
            }.bind(this);
            const processFlowConsumer = function (flowIdToEvent, sliceGuidToEvent, event, slice) {
                let flowEvent = flowIdToEvent[event.bind_id];
                if (flowEvent === undefined) {
                    this.model_.importWarning({
                        type: 'flow_slice_ordering_error',
                        message: 'Flow consumer ' + event.bind_id + ' does not have ' + 'a flow producer'
                    });
                    return false;
                } else if (flowEvent.endSlice) {
                    const flowProducer = flowEvent.startSlice;
                    flowEvent = createFlowEvent(undefined, sliceGuidToEvent[flowProducer.guid], flowProducer);
                }
                const refGuid = undefined;
                const ok = finishFlowEventWith(flowEvent, undefined, event, refGuid, undefined, slice);
                if (ok) {
                    this.model_.flowEvents.push(flowEvent);
                } else {
                    this.model_.importWarning({
                        type: 'flow_slice_end_error',
                        message: 'Flow consumer ' + event.bind_id + ' does not end ' + 'at an actual slice, so cannot be created.'
                    });
                    return false;
                }
                return true;
            }.bind(this);
            const processFlowProducer = function (flowIdToEvent, flowStatus, event, slice) {
                if (flowIdToEvent[event.bind_id] && flowStatus[event.bind_id]) {
                    this.model_.importWarning({
                        type: 'flow_slice_start_error',
                        message: 'Flow producer ' + event.bind_id + ' already seen'
                    });
                    return false;
                }
                const flowEvent = createFlowEvent(undefined, event, slice);
                if (!flowEvent) {
                    this.model_.importWarning({
                        type: 'flow_slice_start_error',
                        message: 'Flow producer ' + event.bind_id + ' does not start' + 'a flow'
                    });
                    return false;
                }
                flowIdToEvent[event.bind_id] = flowEvent;
            }.bind(this);
            this.allFlowEvents_.sort(function (x, y) {
                const d = x.event.ts - y.event.ts;
                if (d !== 0) return d;
                return x.sequenceNumber - y.sequenceNumber;
            });
            const flowIdToEvent = {};
            const sliceGuidToEvent = {};
            const flowStatus = {};
            for (let i = 0; i < this.allFlowEvents_.length; ++i) {
                const data = this.allFlowEvents_[i];
                const refGuid = data.refGuid;
                const event = data.event;
                const thread = data.thread;
                if (!this.validateFlowEvent_(event)) continue;
                if (event.bind_id) {
                    const slice = data.slice;
                    sliceGuidToEvent[slice.guid] = event;
                    if (event.flowPhase === PRODUCER) {
                        if (!processFlowProducer(flowIdToEvent, flowStatus, event, slice)) {
                            continue;
                        }
                        flowStatus[event.bind_id] = true;
                    } else {
                        if (!processFlowConsumer(flowIdToEvent, sliceGuidToEvent, event, slice)) {
                            continue;
                        }
                        flowStatus[event.bind_id] = false;
                        if (event.flowPhase === STEP) {
                            if (!processFlowProducer(flowIdToEvent, flowStatus, event, slice)) {
                                continue;
                            }
                            flowStatus[event.bind_id] = true;
                        }
                    }
                    continue;
                }
                const fullFlowId = JSON.stringify({id: event.id, cat: event.cat, name: event.name});
                let flowEvent;
                if (event.ph === 's') {
                    if (flowIdToEvent[fullFlowId]) {
                        this.model_.importWarning({
                            type: 'flow_slice_start_error',
                            message: 'event id ' + event.id + ' already seen when ' + 'encountering start of flow event.'
                        });
                        continue;
                    }
                    flowEvent = createFlowEvent(thread, event);
                    if (!flowEvent) {
                        this.model_.importWarning({
                            type: 'flow_slice_start_error',
                            message: 'event id ' + event.id + ' does not start ' + 'at an actual slice, so cannot be created.'
                        });
                        continue;
                    }
                    flowIdToEvent[fullFlowId] = flowEvent;
                } else if (event.ph === 't' || event.ph === 'f') {
                    flowEvent = flowIdToEvent[fullFlowId];
                    if (flowEvent === undefined) {
                        this.model_.importWarning({
                            type: 'flow_slice_ordering_error',
                            message: 'Found flow phase ' + event.ph + ' for id: ' + event.id + ' but no flow start found.'
                        });
                        continue;
                    }
                    let bindToParent = event.ph === 't';
                    if (event.ph === 'f') {
                        if (event.bp === undefined) {
                            if (event.cat.indexOf('input') > -1) {
                                bindToParent = true;
                            } else if (event.cat.indexOf('ipc.flow') > -1) {
                                bindToParent = true;
                            }
                        } else {
                            if (event.bp !== 'e') {
                                this.model_.importWarning({
                                    type: 'flow_slice_bind_point_error',
                                    message: 'Flow event with invalid binding point (event.bp).'
                                });
                                continue;
                            }
                            bindToParent = true;
                        }
                    }
                    const ok = finishFlowEventWith(flowEvent, thread, event, refGuid, bindToParent);
                    if (ok) {
                        this.model_.flowEvents.push(flowEvent);
                    } else {
                        this.model_.importWarning({
                            type: 'flow_slice_end_error',
                            message: 'event id ' + event.id + ' does not end ' + 'at an actual slice, so cannot be created.'
                        });
                    }
                    flowIdToEvent[fullFlowId] = undefined;
                    if (ok && event.ph === 't') {
                        flowEvent = createFlowEvent(thread, event);
                        flowIdToEvent[fullFlowId] = flowEvent;
                    }
                }
            }
        },
        createExplicitObjects_() {
            if (this.allObjectEvents_.length === 0) return;
            const processEvent = function (objectEventState) {
                const event = objectEventState.event;
                const scopedId = TraceEventImporter.scopedIdForEvent_(event);
                const thread = objectEventState.thread;
                if (event.name === undefined) {
                    this.model_.importWarning({
                        type: 'object_parse_error',
                        message: 'While processing ' + JSON.stringify(event) + ': ' + 'Object events require an name parameter.'
                    });
                }
                if (scopedId === undefined || scopedId.id === undefined) {
                    this.model_.importWarning({
                        type: 'object_parse_error',
                        message: 'While processing ' + JSON.stringify(event) + ': ' + 'Object events require an id parameter.'
                    });
                }
                const process = thread.parent;
                const ts = this.toModelTimeFromUs_(event.ts);
                let instance;
                if (event.ph === 'N') {
                    try {
                        instance = process.objects.idWasCreated(scopedId, event.cat, event.name, ts);
                    } catch (e) {
                        this.model_.importWarning({
                            type: 'object_parse_error', message: 'While processing create of ' +
                                scopedId + ' at ts=' + ts + ': ' + e
                        });
                        return;
                    }
                } else if (event.ph === 'O') {
                    if (event.args.snapshot === undefined) {
                        this.model_.importWarning({
                            type: 'object_parse_error',
                            message: 'While processing ' + scopedId + ' at ts=' + ts + ': ' + 'Snapshots must have args: {snapshot: ...}'
                        });
                        return;
                    }
                    let snapshot;
                    try {
                        const args = this.deepCopyIfNeeded_(event.args.snapshot);
                        let cat;
                        if (args.cat) {
                            cat = args.cat;
                            delete args.cat;
                        } else {
                            cat = event.cat;
                        }
                        let baseTypename;
                        if (args.base_type) {
                            baseTypename = args.base_type;
                            delete args.base_type;
                        } else {
                            baseTypename = undefined;
                        }
                        snapshot = process.objects.addSnapshot(scopedId, cat, event.name, ts, args, baseTypename);
                        snapshot.snapshottedOnThread = thread;
                    } catch (e) {
                        this.model_.importWarning({
                            type: 'object_parse_error', message: 'While processing snapshot of ' +
                                scopedId + ' at ts=' + ts + ': ' + e
                        });
                        return;
                    }
                    instance = snapshot.objectInstance;
                } else if (event.ph === 'D') {
                    try {
                        process.objects.idWasDeleted(scopedId, event.cat, event.name, ts);
                        const instanceMap = process.objects.getOrCreateInstanceMap_(scopedId);
                        instance = instanceMap.lastInstance;
                    } catch (e) {
                        this.model_.importWarning({
                            type: 'object_parse_error', message: 'While processing delete of ' +
                                scopedId + ' at ts=' + ts + ': ' + e
                        });
                        return;
                    }
                }
                if (instance) {
                    instance.colorId = getEventColor(event, instance.typeName);
                }
            }.bind(this);
            this.allObjectEvents_.sort(function (x, y) {
                const d = x.event.ts - y.event.ts;
                if (d !== 0) return d;
                return x.sequenceNumber - y.sequenceNumber;
            });
            const allObjectEvents = this.allObjectEvents_;
            for (let i = 0; i < allObjectEvents.length; i++) {
                const objectEventState = allObjectEvents[i];
                try {
                    processEvent.call(this, objectEventState);
                } catch (e) {
                    this.model_.importWarning({type: 'object_parse_error', message: e.message});
                }
            }
        },
        createImplicitObjects_() {
            for (const proc of Object.values(this.model_.processes)) {
                this.createImplicitObjectsForProcess_(proc);
            }
        },
        createImplicitObjectsForProcess_(process) {
            function processField(referencingObject, referencingObjectFieldName, referencingObjectFieldValue, containingSnapshot) {
                if (!referencingObjectFieldValue) return;
                if (referencingObjectFieldValue instanceof
                    tr.model.ObjectSnapshot) {
                    return null;
                }
                if (referencingObjectFieldValue.id === undefined) return;
                const implicitSnapshot = referencingObjectFieldValue;
                const rawId = implicitSnapshot.id;
                const m = /(.+)\/(.+)/.exec(rawId);
                if (!m) {
                    throw new Error('Implicit snapshots must have names.');
                }
                delete implicitSnapshot.id;
                const name = m[1];
                const id = m[2];
                let res;
                let cat;
                if (implicitSnapshot.cat !== undefined) {
                    cat = implicitSnapshot.cat;
                } else {
                    cat = containingSnapshot.objectInstance.category;
                }
                let baseTypename;
                if (implicitSnapshot.base_type) {
                    baseTypename = implicitSnapshot.base_type;
                } else {
                    baseTypename = undefined;
                }
                const scope = containingSnapshot.objectInstance.scopedId.scope;
                try {
                    res = process.objects.addSnapshot(new tr.model.ScopedId(scope, id), cat, name, containingSnapshot.ts, implicitSnapshot, baseTypename);
                } catch (e) {
                    this.model_.importWarning({
                        type: 'object_snapshot_parse_error', message: 'While processing implicit snapshot of ' +
                            rawId + ' at ts=' + containingSnapshot.ts + ': ' + e
                    });
                    return;
                }
                res.objectInstance.hasImplicitSnapshots = true;
                res.containingSnapshot = containingSnapshot;
                res.snapshottedOnThread = containingSnapshot.snapshottedOnThread;
                referencingObject[referencingObjectFieldName] = res;
                if (!(res instanceof tr.model.ObjectSnapshot)) {
                    throw new Error('Created object must be instanceof snapshot');
                }
                return res.args;
            }

            function iterObject(object, func, containingSnapshot, thisArg) {
                if (!(object instanceof Object)) return;
                if (object instanceof Array) {
                    for (let i = 0; i < object.length; i++) {
                        const res = func.call(thisArg, object, i, object[i], containingSnapshot);
                        if (res === null) continue;
                        if (res) {
                            iterObject(res, func, containingSnapshot, thisArg);
                        } else {
                            iterObject(object[i], func, containingSnapshot, thisArg);
                        }
                    }
                    return;
                }
                for (const key in object) {
                    const res = func.call(thisArg, object, key, object[key], containingSnapshot);
                    if (res === null) continue;
                    if (res) {
                        iterObject(res, func, containingSnapshot, thisArg);
                    } else {
                        iterObject(object[key], func, containingSnapshot, thisArg);
                    }
                }
            }

            process.objects.iterObjectInstances(function (instance) {
                instance.snapshots.forEach(function (snapshot) {
                    if (snapshot.args.id !== undefined) {
                        throw new Error('args cannot have an id field inside it');
                    }
                    iterObject(snapshot.args, processField, snapshot, this);
                }, this);
            }, this);
        },
        minimalTimestampInPidToEvents_(pidToEvents) {
            let smallestTs = Infinity;
            for (const events of Object.values(pidToEvents)) {
                for (const event of events) {
                    if (event.ts < smallestTs) {
                        smallestTs = event.ts;
                    }
                }
            }
            return smallestTs;
        },
        createMemoryDumps_() {
            const pairs = Object.entries(this.allMemoryDumpEvents_);
            const key = x => this.minimalTimestampInPidToEvents_(x);
            pairs.sort((x, y) => key(x[1]) - key(y[1]));
            for (const [dumpId, pidToEvents] of pairs) {
                this.createGlobalMemoryDump_(pidToEvents, dumpId);
            }
        },
        createGlobalMemoryDump_(dumpIdEvents, dumpId) {
            const globalRange = new tr.b.math.Range();
            for (const pid in dumpIdEvents) {
                const processEvents = dumpIdEvents[pid];
                for (let i = 0; i < processEvents.length; i++) {
                    globalRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));
                }
            }
            if (globalRange.isEmpty) {
                throw new Error('Internal error: Global memory dump without events');
            }
            const globalMemoryDump = new tr.model.GlobalMemoryDump(this.model_, globalRange.min);
            globalMemoryDump.duration = globalRange.range;
            this.model_.globalMemoryDumps.push(globalMemoryDump);
            const globalMemoryAllocatorDumpsByFullName = {};
            const levelsOfDetail = {};
            const allMemoryAllocatorDumpsByGuid = {};
            for (const pid in dumpIdEvents) {
                this.createProcessMemoryDump_(globalMemoryDump, globalMemoryAllocatorDumpsByFullName, levelsOfDetail, allMemoryAllocatorDumpsByGuid, dumpIdEvents[pid], pid, dumpId);
            }
            globalMemoryDump.levelOfDetail = levelsOfDetail.global;
            globalMemoryDump.memoryAllocatorDumps = this.inferMemoryAllocatorDumpTree_(globalMemoryAllocatorDumpsByFullName);
            this.parseMemoryDumpAllocatorEdges_(allMemoryAllocatorDumpsByGuid, dumpIdEvents, dumpId);
        },
        createProcessMemoryDump_(globalMemoryDump, globalMemoryAllocatorDumpsByFullName, levelsOfDetail, allMemoryAllocatorDumpsByGuid, processEvents, pid, dumpId) {
            const processRange = new tr.b.math.Range();
            for (let i = 0; i < processEvents.length; i++) {
                processRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));
            }
            if (processRange.isEmpty) {
                throw new Error('Internal error: Process memory dump without events');
            }
            const process = this.model_.getOrCreateProcess(pid);
            const processMemoryDump = new tr.model.ProcessMemoryDump(globalMemoryDump, process, processRange.min);
            processMemoryDump.duration = processRange.range;
            process.memoryDumps.push(processMemoryDump);
            globalMemoryDump.processMemoryDumps[pid] = processMemoryDump;
            const processMemoryAllocatorDumpsByFullName = {};
            for (let i = 0; i < processEvents.length; i++) {
                const processEvent = processEvents[i];
                const dumps = processEvent.args.dumps;
                if (dumps === undefined) {
                    this.model_.importWarning({
                        type: 'memory_dump_parse_error',
                        message: '\'dumps\' field not found in a process memory dump' + ' event for PID=' + pid + ' and dump ID=' + dumpId + '.'
                    });
                    continue;
                }
                this.parseMemoryDumpTotals_(processMemoryDump, dumps, pid, dumpId);
                this.parseMemoryDumpVmRegions_(processMemoryDump, dumps, pid, dumpId);
                this.parseMemoryDumpHeapDumps_(processMemoryDump, dumps, pid, dumpId);
                this.parseMemoryDumpLevelOfDetail_(levelsOfDetail, dumps, pid, dumpId);
                this.parseMemoryDumpAllocatorDumps_(processMemoryDump, globalMemoryDump, processMemoryAllocatorDumpsByFullName, globalMemoryAllocatorDumpsByFullName, allMemoryAllocatorDumpsByGuid, dumps, pid, dumpId);
            }
            if (levelsOfDetail.process === undefined) {
                levelsOfDetail.process = processMemoryDump.vmRegions ? DETAILED : LIGHT;
            }
            if (!this.updateMemoryDumpLevelOfDetail_(levelsOfDetail, 'global', levelsOfDetail.process)) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'diffent levels of detail provided for global memory' + ' dump (dump ID=' + dumpId + ').'
                });
            }
            processMemoryDump.levelOfDetail = levelsOfDetail.process;
            delete levelsOfDetail.process;
            processMemoryDump.memoryAllocatorDumps = this.inferMemoryAllocatorDumpTree_(processMemoryAllocatorDumpsByFullName);
        },
        parseMemoryDumpTotals_(processMemoryDump, dumps, pid, dumpId) {
            const rawTotals = dumps.process_totals;
            if (rawTotals === undefined) return;
            if (processMemoryDump.totals !== undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Process totals provided multiple times for' + ' process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                });
                return;
            }
            const totals = {};
            let platformSpecificTotals = undefined;
            for (const rawTotalName in rawTotals) {
                const rawTotalValue = rawTotals[rawTotalName];
                if (rawTotalValue === undefined) continue;
                if (rawTotalName === 'resident_set_bytes') {
                    totals.residentBytes = parseInt(rawTotalValue, 16);
                    continue;
                }
                if (rawTotalName === 'peak_resident_set_bytes') {
                    totals.peakResidentBytes = parseInt(rawTotalValue, 16);
                    continue;
                }
                if (rawTotalName === 'is_peak_rss_resetable') {
                    totals.arePeakResidentBytesResettable = !!rawTotalValue;
                    continue;
                }
                if (rawTotalName === 'private_footprint_bytes') {
                    totals.privateFootprintBytes = parseInt(rawTotalValue, 16);
                    continue;
                }
                if (platformSpecificTotals === undefined) {
                    platformSpecificTotals = {};
                    totals.platformSpecific = platformSpecificTotals;
                }
                platformSpecificTotals[rawTotalName] = parseInt(rawTotalValue, 16);
            }
            if (totals.peakResidentBytes === undefined && totals.arePeakResidentBytesResettable !== undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Optional field peak_resident_set_bytes found' + ' but is_peak_rss_resetable not found in' + ' process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                });
            }
            if (totals.arePeakResidentBytesResettable !== undefined && totals.peakResidentBytes === undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Optional field is_peak_rss_resetable found' + ' but peak_resident_set_bytes not found in' + ' process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                });
            }
            processMemoryDump.totals = totals;
        },
        parseMemoryDumpVmRegions_(processMemoryDump, dumps, pid, dumpId) {
            const rawProcessMmaps = dumps.process_mmaps;
            if (rawProcessMmaps === undefined) return;
            const rawVmRegions = rawProcessMmaps.vm_regions;
            if (rawVmRegions === undefined) return;
            if (processMemoryDump.vmRegions !== undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'VM regions provided multiple times for' + ' process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                });
                return;
            }
            const vmRegions = new Array(rawVmRegions.length);
            for (let i = 0; i < rawVmRegions.length; i++) {
                const rawVmRegion = rawVmRegions[i];
                const byteStats = {};
                const rawByteStats = rawVmRegion.bs;
                for (const rawByteStatName in rawByteStats) {
                    const rawByteStatValue = rawByteStats[rawByteStatName];
                    if (rawByteStatValue === undefined) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Byte stat \'' + rawByteStatName + '\' of VM region ' +
                                i + ' (' + rawVmRegion.mf + ') in process memory dump for ' + 'PID=' + pid + ' and dump ID=' + dumpId + ' does not have a value.'
                        });
                        continue;
                    }
                    const byteStatName = BYTE_STAT_NAME_MAP[rawByteStatName];
                    if (byteStatName === undefined) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Unknown byte stat name \'' + rawByteStatName + '\' (' +
                                rawByteStatValue + ') of VM region ' + i + ' (' +
                                rawVmRegion.mf + ') in process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                        });
                        continue;
                    }
                    byteStats[byteStatName] = parseInt(rawByteStatValue, 16);
                    if (byteStatName === 'proportionalResident' && byteStats[byteStatName] === 0) {
                        byteStats[byteStatName] = undefined;
                    }
                }
                vmRegions[i] = new tr.model.VMRegion(parseInt(rawVmRegion.sa, 16), parseInt(rawVmRegion.sz, 16), rawVmRegion.pf, rawVmRegion.mf, byteStats);
            }
            processMemoryDump.vmRegions = tr.model.VMRegionClassificationNode.fromRegions(vmRegions);
        },
        parseMemoryDumpHeapDumps_(processMemoryDump, dumps, pid, dumpId) {
            const idPrefix = 'p' + pid + ':';
            let importer;
            if (dumps.heaps) {
                const processTypeMap = this.objectTypeNameMap_[pid];
                if (processTypeMap === undefined) {
                    this.model_.importWarning({
                        type: 'memory_dump_parse_error',
                        message: 'Missing mapping from object type IDs to names.'
                    });
                }
                importer = new LegacyHeapDumpTraceEventImporter(this.model_, processMemoryDump, processTypeMap, idPrefix, dumpId, dumps.heaps);
            } else if (dumps.heaps_v2) {
                const data = dumps.heaps_v2;
                this.heapProfileExpander = this.heapProfileExpander.expandData(data);
                this.addNewStackFramesFromExpander_(this.heapProfileExpander, idPrefix);
                importer = new HeapDumpTraceEventImporter(this.heapProfileExpander, this.model_.stackFrames, processMemoryDump, idPrefix, this.model_);
            }
            if (!importer) return;
            const heapDumps = importer.parse();
            if (!heapDumps) return;
            if (processMemoryDump.heapDumps !== undefined) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Heap dumps provided multiple times for' + ' process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                });
                return;
            }
            if (Object.keys(heapDumps).length > 0) {
                processMemoryDump.heapDumps = heapDumps;
            }
        },
        addNewStackFramesFromExpander_(expander, idPrefix) {
            const nodeMap = expander.getNewMap('nodes');
            const newStackFrames = {};
            for (const [id, stackFrame] of nodeMap.entries()) {
                if (!this.model_.stackFrames[idPrefix + id]) {
                    newStackFrames[id] = {id, name: expander.getString(stackFrame.name_sid),};
                    if (stackFrame.parent) newStackFrames[id].parent = stackFrame.parent;
                }
            }
            this.importStackFrames_(newStackFrames, idPrefix);
        },
        parseMemoryDumpLevelOfDetail_(levelsOfDetail, dumps, pid, dumpId) {
            const rawLevelOfDetail = dumps.level_of_detail;
            let level;
            switch (rawLevelOfDetail) {
                case'background':
                    level = BACKGROUND;
                    break;
                case'light':
                    level = LIGHT;
                    break;
                case'detailed':
                    level = DETAILED;
                    break;
                case undefined:
                    level = undefined;
                    break;
                default:
                    this.model_.importWarning({
                        type: 'memory_dump_parse_error',
                        message: 'unknown raw level of detail \'' + rawLevelOfDetail + '\' of process memory dump for PID=' + pid + ' and dump ID=' + dumpId + '.'
                    });
                    return;
            }
            if (!this.updateMemoryDumpLevelOfDetail_(levelsOfDetail, 'process', level)) {
                this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'diffent levels of detail provided for process memory' + ' dump for PID=' + pid + ' (dump ID=' + dumpId + ').'
                });
            }
        },
        updateMemoryDumpLevelOfDetail_(levelsOfDetail, scope, level) {
            if (!(scope in levelsOfDetail) || level === levelsOfDetail[scope]) {
                levelsOfDetail[scope] = level;
                return true;
            }
            if (MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(level) > MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(levelsOfDetail[scope])) {
                levelsOfDetail[scope] = level;
            }
            return false;
        },
        parseMemoryDumpAllocatorDumps_(processMemoryDump, globalMemoryDump, processMemoryAllocatorDumpsByFullName, globalMemoryAllocatorDumpsByFullName, allMemoryAllocatorDumpsByGuid, dumps, pid, dumpId) {
            const rawAllocatorDumps = dumps.allocators;
            if (rawAllocatorDumps === undefined) return;
            for (let fullName in rawAllocatorDumps) {
                const rawAllocatorDump = rawAllocatorDumps[fullName];
                const guid = rawAllocatorDump.guid;
                if (guid === undefined) {
                    this.model_.importWarning({
                        type: 'memory_dump_parse_error',
                        message: 'Memory allocator dump ' + fullName + ' for PID=' + pid + ' and dump ID=' + dumpId + ' does not have a GUID.'
                    });
                }
                const flags = rawAllocatorDump.flags || 0;
                const isWeakDump = !!(flags & WEAK_MEMORY_ALLOCATOR_DUMP_FLAG);
                let containerMemoryDump;
                let dstIndex;
                if (fullName.startsWith(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX)) {
                    fullName = fullName.substring(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX.length);
                    containerMemoryDump = globalMemoryDump;
                    dstIndex = globalMemoryAllocatorDumpsByFullName;
                } else {
                    containerMemoryDump = processMemoryDump;
                    dstIndex = processMemoryAllocatorDumpsByFullName;
                }
                let allocatorDump = allMemoryAllocatorDumpsByGuid[guid];
                if (allocatorDump === undefined) {
                    if (fullName in dstIndex) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Multiple GUIDs provided for' + ' memory allocator dump ' + fullName + ': ' +
                                dstIndex[fullName].guid + ', ' + guid + ' (ignored) for' + ' PID=' + pid + ' and dump ID=' + dumpId + '.'
                        });
                        continue;
                    }
                    allocatorDump = new tr.model.MemoryAllocatorDump(containerMemoryDump, fullName, guid);
                    allocatorDump.weak = isWeakDump;
                    dstIndex[fullName] = allocatorDump;
                    if (guid !== undefined) {
                        allMemoryAllocatorDumpsByGuid[guid] = allocatorDump;
                    }
                } else {
                    if (allocatorDump.containerMemoryDump !== containerMemoryDump) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Memory allocator dump ' + fullName + ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' +
                                dumpId + ' dumped in different contexts.'
                        });
                        continue;
                    }
                    if (allocatorDump.fullName !== fullName) {
                        this.model_.importWarning({
                            type: 'memory_dump_parse_error',
                            message: 'Memory allocator dump with GUID=' + guid + ' for PID=' +
                                pid + ' and dump ID=' + dumpId + ' has multiple names: ' +
                                allocatorDump.fullName + ', ' + fullName + ' (ignored).'
                        });
                        continue;
                    }
                    if (!isWeakDump) {
                        allocatorDump.weak = false;
                    }
                }
                let attributes = rawAllocatorDump.attrs;
                if (attributes === undefined) {
                    this.model_.importWarning({
                        type: 'memory_dump_parse_error',
                        message: 'Memory allocator dump ' + fullName + ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' + dumpId + ' does not have attributes.'
                    });
                    attributes = {};
                }
                for (const attrName in attributes) {
                    const attrArgs = attributes[attrName];
                    const attrType = attrArgs.type;
                    const attrValue = attrArgs.value;
                    switch (attrType) {
                        case'scalar': {
                            if (attrName in allocatorDump.numerics) {
                                this.model_.importWarning({
                                    type: 'memory_dump_parse_error',
                                    message: 'Multiple values provided for scalar attribute ' +
                                        attrName + ' of memory allocator dump ' + fullName + ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' +
                                        dumpId + '.'
                                });
                                break;
                            }
                            const unit = attrArgs.units === 'bytes' ? tr.b.Unit.byName.sizeInBytes_smallerIsBetter : tr.b.Unit.byName.unitlessNumber_smallerIsBetter;
                            const value = parseInt(attrValue, 16);
                            allocatorDump.addNumeric(attrName, new tr.b.Scalar(unit, value));
                            break;
                        }
                        case'string':
                            if (attrName in allocatorDump.diagnostics) {
                                this.model_.importWarning({
                                    type: 'memory_dump_parse_error',
                                    message: 'Multiple values provided for string attribute ' +
                                        attrName + ' of memory allocator dump ' + fullName + ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' +
                                        dumpId + '.'
                                });
                                break;
                            }
                            allocatorDump.addDiagnostic(attrName, attrValue);
                            break;
                        default:
                            this.model_.importWarning({
                                type: 'memory_dump_parse_error',
                                message: 'Unknown type provided for attribute ' + attrName + ' of memory allocator dump ' + fullName + ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' + dumpId + ': ' +
                                    attrType
                            });
                            break;
                    }
                }
            }
        },
        inferMemoryAllocatorDumpTree_(memoryAllocatorDumpsByFullName) {
            const rootAllocatorDumps = [];
            const fullNames = Object.keys(memoryAllocatorDumpsByFullName);
            fullNames.sort();
            for (let i = 0; i < fullNames.length; i++) {
                let fullName = fullNames[i];
                let allocatorDump = memoryAllocatorDumpsByFullName[fullName];
                while (true) {
                    const lastSlashIndex = fullName.lastIndexOf('/');
                    if (lastSlashIndex === -1) {
                        rootAllocatorDumps.push(allocatorDump);
                        break;
                    }
                    const parentFullName = fullName.substring(0, lastSlashIndex);
                    let parentAllocatorDump = memoryAllocatorDumpsByFullName[parentFullName];
                    let parentAlreadyExisted = true;
                    if (parentAllocatorDump === undefined) {
                        parentAlreadyExisted = false;
                        parentAllocatorDump = new tr.model.MemoryAllocatorDump(allocatorDump.containerMemoryDump, parentFullName);
                        if (allocatorDump.weak !== false) {
                            parentAllocatorDump.weak = undefined;
                        }
                        memoryAllocatorDumpsByFullName[parentFullName] = parentAllocatorDump;
                    }
                    allocatorDump.parent = parentAllocatorDump;
                    parentAllocatorDump.children.push(allocatorDump);
                    if (parentAlreadyExisted) {
                        if (!allocatorDump.weak) {
                            while (parentAllocatorDump !== undefined && parentAllocatorDump.weak === undefined) {
                                parentAllocatorDump.weak = false;
                                parentAllocatorDump = parentAllocatorDump.parent;
                            }
                        }
                        break;
                    }
                    fullName = parentFullName;
                    allocatorDump = parentAllocatorDump;
                }
            }
            for (const fullName in memoryAllocatorDumpsByFullName) {
                const allocatorDump = memoryAllocatorDumpsByFullName[fullName];
                if (allocatorDump.weak === undefined) {
                    allocatorDump.weak = true;
                }
            }
            return rootAllocatorDumps;
        },
        parseMemoryDumpAllocatorEdges_(allMemoryAllocatorDumpsByGuid, dumpIdEvents, dumpId) {
            for (const pid in dumpIdEvents) {
                const processEvents = dumpIdEvents[pid];
                for (let i = 0; i < processEvents.length; i++) {
                    const processEvent = processEvents[i];
                    const dumps = processEvent.args.dumps;
                    if (dumps === undefined) continue;
                    const rawEdges = dumps.allocators_graph;
                    if (rawEdges === undefined) continue;
                    for (let j = 0; j < rawEdges.length; j++) {
                        const rawEdge = rawEdges[j];
                        const sourceGuid = rawEdge.source;
                        const sourceDump = allMemoryAllocatorDumpsByGuid[sourceGuid];
                        if (sourceDump === undefined) {
                            this.model_.importWarning({
                                type: 'memory_dump_parse_error',
                                message: 'Edge for PID=' + pid + ' and dump ID=' + dumpId + ' is missing source memory allocator dump (GUID=' +
                                    sourceGuid + ').'
                            });
                            continue;
                        }
                        const targetGuid = rawEdge.target;
                        const targetDump = allMemoryAllocatorDumpsByGuid[targetGuid];
                        if (targetDump === undefined) {
                            this.model_.importWarning({
                                type: 'memory_dump_parse_error',
                                message: 'Edge for PID=' + pid + ' and dump ID=' + dumpId + ' is missing target memory allocator dump (GUID=' +
                                    targetGuid + ').'
                            });
                            continue;
                        }
                        const importance = rawEdge.importance;
                        const edge = new tr.model.MemoryAllocatorDumpLink(sourceDump, targetDump, importance);
                        switch (rawEdge.type) {
                            case'ownership':
                                if (sourceDump.owns !== undefined) {
                                    this.model_.importWarning({
                                        type: 'memory_dump_parse_error',
                                        message: 'Memory allocator dump ' + sourceDump.fullName + ' (GUID=' + sourceGuid + ') already owns a memory' + ' allocator dump (' +
                                            sourceDump.owns.target.fullName + ').'
                                    });
                                } else {
                                    sourceDump.owns = edge;
                                    targetDump.ownedBy.push(edge);
                                }
                                break;
                            case'retention':
                                sourceDump.retains.push(edge);
                                targetDump.retainedBy.push(edge);
                                break;
                            default:
                                this.model_.importWarning({
                                    type: 'memory_dump_parse_error',
                                    message: 'Invalid edge type: ' + rawEdge.type + ' (PID=' + pid + ', dump ID=' + dumpId + ', source=' + sourceGuid + ', target=' + targetGuid + ', importance=' + importance + ').'
                                });
                        }
                    }
                }
            }
        },
        toModelTimeFromUs_(ts) {
            if (!this.toModelTime_) {
                this.toModelTime_ = this.model_.clockSyncManager.getModelTimeTransformer(this.clockDomainId_);
            }
            return this.toModelTime_(tr.b.Unit.timestampFromUs(ts));
        },
        maybeToModelTimeFromUs_(ts) {
            if (ts === undefined) {
                return undefined;
            }
            return this.toModelTimeFromUs_(ts);
        }
    };
    tr.importer.Importer.register(TraceEventImporter);
    return {TraceEventImporter,};
});
'use strict';
tr.exportTo('tr.e.net', function () {
    const AsyncSlice = tr.model.AsyncSlice;

    function NetAsyncSlice() {
        AsyncSlice.apply(this, arguments);
        this.url_ = undefined;
        this.byteCount_ = undefined;
        this.isTitleComputed_ = false;
        this.isUrlComputed_ = false;
    }

    NetAsyncSlice.prototype = {
        __proto__: AsyncSlice.prototype, get viewSubGroupTitle() {
            return 'NetLog';
        }, get title() {
            if (this.isTitleComputed_ || !this.isTopLevel) {
                return this.title_;
            }
            if (this.url !== undefined && this.url.length > 0) {
                this.title_ = this.url;
            } else if (this.args !== undefined && this.args.source_type !== undefined) {
                this.title_ = this.args.source_type;
            }
            this.isTitleComputed_ = true;
            return this.title_;
        }, set title(title) {
            this.title_ = title;
        }, get url() {
            if (this.isUrlComputed_) {
                return this.url_;
            }
            if (this.args !== undefined && this.args.params !== undefined && this.args.params.url !== undefined) {
                this.url_ = this.args.params.url;
            } else if (this.subSlices !== undefined && this.subSlices.length > 0) {
                for (let i = 0; i < this.subSlices.length && !this.url_; i++) {
                    if (this.subSlices[i].url !== undefined) {
                        this.url_ = this.subSlices[i].url;
                    }
                }
            }
            this.isUrlComputed_ = true;
            return this.url_;
        }, get byteCount() {
            if (this.byteCount_ !== undefined) {
                return this.byteCount_;
            }
            this.byteCount_ = 0;
            if ((this.originalTitle === 'URL_REQUEST_JOB_FILTERED_BYTES_READ' || this.originalTitle === 'URL_REQUEST_JOB_BYTES_READ') && this.args !== undefined && this.args.params !== undefined && this.args.params.byte_count !== undefined) {
                this.byteCount_ = this.args.params.byte_count;
            }
            for (let i = 0; i < this.subSlices.length; i++) {
                this.byteCount_ += this.subSlices[i].byteCount;
            }
            return this.byteCount_;
        }
    };
    AsyncSlice.subTypes.register(NetAsyncSlice, {categoryParts: ['netlog', 'disabled-by-default-netlog']});
    return {NetAsyncSlice,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    function Parser(importer) {
        this.importer = importer;
        this.model = importer.model;
    }

    Parser.prototype = {__proto__: Object.prototype};
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    options.mandatoryBaseClass = Parser;
    tr.b.decorateExtensionRegistry(Parser, options);
    return {Parser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function AndroidParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('tracing_mark_write:android', AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));
        importer.registerEventHandler('0:android', AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));
        this.model_ = importer.model_;
        this.ppids_ = {};
    }

    function parseArgs(argsString) {
        const args = {};
        if (argsString) {
            const argsArray = argsString.split(';');
            for (let i = 0; i < argsArray.length; ++i) {
                const parts = argsArray[i].split('=');
                if (parts[0]) {
                    args[parts.shift()] = parts.join('=');
                }
            }
        }
        return args;
    }

    AndroidParser.prototype = {
        __proto__: Parser.prototype, openAsyncSlice(thread, category, name, cookie, ts, args) {
            const asyncSliceConstructor = tr.model.AsyncSlice.subTypes.getConstructor(category, name);
            const slice = new asyncSliceConstructor(category, name, ColorScheme.getColorIdForGeneralPurposeString(name), ts, args);
            const key = category + ':' + name + ':' + cookie;
            slice.id = cookie;
            slice.startThread = thread;
            if (!this.openAsyncSlices) {
                this.openAsyncSlices = {};
            }
            this.openAsyncSlices[key] = slice;
        }, closeAsyncSlice(thread, category, name, cookie, ts, args) {
            if (!this.openAsyncSlices) {
                return;
            }
            const key = category + ':' + name + ':' + cookie;
            const slice = this.openAsyncSlices[key];
            if (!slice) {
                return;
            }
            for (const arg in args) {
                if (slice.args[arg] !== undefined) {
                    this.model_.importWarning({
                        type: 'parse_error',
                        message: 'Both the S and F events of ' + slice.title + ' provided values for argument ' + arg + '.' + ' The value of the F event will be used.'
                    });
                }
                slice.args[arg] = args[arg];
            }
            slice.endThread = thread;
            slice.duration = ts - slice.start;
            slice.startThread.asyncSliceGroup.push(slice);
            delete this.openAsyncSlices[key];
        }, traceMarkWriteAndroidEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const eventData = eventBase.details.split('|');
            switch (eventData[0]) {
                case'B': {
                    const ppid = parseInt(eventData[1]);
                    const title = eventData[2];
                    const args = parseArgs(eventData[3]);
                    let category = eventData[4];
                    if (category === undefined) category = 'android';
                    const thread = this.model_.getOrCreateProcess(ppid).getOrCreateThread(pid);
                    thread.name = eventBase.threadName;
                    if (!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
                        this.model_.importWarning({
                            type: 'parse_error',
                            message: 'Timestamps are moving backward.'
                        });
                        return false;
                    }
                    this.ppids_[pid] = ppid;
                    thread.sliceGroup.beginSlice(category, title, ts, args);
                    break;
                }
                case'E': {
                    const ppid = this.ppids_[pid];
                    if (ppid === undefined) {
                        break;
                    }
                    const thread = this.model_.getOrCreateProcess(ppid).getOrCreateThread(pid);
                    if (!thread.sliceGroup.openSliceCount) {
                        break;
                    }
                    const slice = thread.sliceGroup.endSlice(ts);
                    const args = parseArgs(eventData[3]);
                    for (const arg in args) {
                        if (slice.args[arg] !== undefined) {
                            this.model_.importWarning({
                                type: 'parse_error',
                                message: 'Both the B and E events of ' + slice.title + ' provided values for argument ' + arg + '.' + ' The value of the E event will be used.'
                            });
                        }
                        slice.args[arg] = args[arg];
                    }
                    break;
                }
                case'C': {
                    const ppid = parseInt(eventData[1]);
                    const name = eventData[2];
                    const value = parseInt(eventData[3]);
                    let category = eventData[4];
                    if (category === undefined) category = 'android';
                    const ctr = this.model_.getOrCreateProcess(ppid).getOrCreateCounter(category, name);
                    if (ctr.numSeries === 0) {
                        ctr.addSeries(new tr.model.CounterSeries(value, ColorScheme.getColorIdForGeneralPurposeString(ctr.name + '.' + 'value')));
                    }
                    ctr.series.forEach(function (series) {
                        series.addCounterSample(ts, value);
                    });
                    break;
                }
                case'S': {
                    const ppid = parseInt(eventData[1]);
                    const name = eventData[2];
                    const cookie = parseInt(eventData[3]);
                    const args = parseArgs(eventData[4]);
                    let category = eventData[5];
                    if (category === undefined) category = 'android';
                    const thread = this.model_.getOrCreateProcess(ppid).getOrCreateThread(pid);
                    thread.name = eventBase.threadName;
                    this.ppids_[pid] = ppid;
                    this.openAsyncSlice(thread, category, name, cookie, ts, args);
                    break;
                }
                case'F': {
                    const ppid = parseInt(eventData[1]);
                    const name = eventData[2];
                    const cookie = parseInt(eventData[3]);
                    const args = parseArgs(eventData[4]);
                    let category = eventData[5];
                    if (category === undefined) category = 'android';
                    const thread = this.model_.getOrCreateProcess(ppid).getOrCreateThread(pid);
                    thread.name = eventBase.threadName;
                    this.ppids_[pid] = ppid;
                    this.closeAsyncSlice(thread, category, name, cookie, ts, args);
                    break;
                }
                default:
                    return false;
            }
            return true;
        }
    };
    Parser.register(AndroidParser);
    return {AndroidParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;
    const binderTransRE = new RegExp('transaction=(\\d+) dest_node=(\\d+) ' + 'dest_proc=(\\d+) dest_thread=(\\d+) ' + 'reply=(\\d+) flags=(0x[0-9a-fA-F]+) ' + 'code=(0x[0-9a-fA-F]+)');
    const binderAllocRE = new RegExp('transaction=(\\d+) data_size=(\\d+) ' + 'offsets_size=(\\d+)');
    const binderTransReceivedRE = /transaction=(\d+)/;

    function isBinderThread(name) {
        return (name.indexOf('Binder') > -1);
    }

    const TF_ONE_WAY = 0x01;
    const TF_ROOT_OBJECT = 0x04;
    const TF_STATUS_CODE = 0x08;
    const TF_ACCEPT_FDS = 0x10;
    const NO_FLAGS = 0;

    function binderFlagsToHuman(num) {
        const flag = parseInt(num, 16);
        let str = '';
        if (flag & TF_ONE_WAY) {
            str += 'this is a one-way call: async, no return; ';
        }
        if (flag & TF_ROOT_OBJECT) {
            str += 'contents are the components root object; ';
        }
        if (flag & TF_STATUS_CODE) {
            str += 'contents are a 32-bit status code; ';
        }
        if (flag & TF_ACCEPT_FDS) {
            str += 'allow replies with file descriptors; ';
        }
        if (flag === NO_FLAGS) {
            str += 'No Flags Set';
        }
        return str;
    }

    function isReplyToOrigin(calling, called) {
        return (called.dest_proc === calling.calling_pid || called.dest_thread === calling.calling_pid);
    }

    function binderCodeToHuman(code) {
        return 'Java Layer Dependent';
    }

    function doInternalSlice(trans, slice, ts) {
        if (slice.subSlices.length !== 0) {
            slice.subSlices[0].start = ts;
            return slice.subSlices[0];
        }
        const kthread = trans.calling_kthread.thread;
        const internalSlice = kthread.sliceGroup.pushCompleteSlice('binder', slice.title, ts, .001, 0, 0, slice.args);
        internalSlice.title = slice.title;
        internalSlice.id = slice.id;
        internalSlice.colorId = slice.colorId;
        slice.subSlices.push(internalSlice);
        return internalSlice;
    }

    function generateBinderArgsForSlice(trans, cThreadName) {
        return {
            'Transaction Id': trans.transaction_key,
            'Destination Node': trans.dest_node,
            'Destination Process': trans.dest_proc,
            'Destination Thread': trans.dest_thread,
            'Destination Name': cThreadName,
            'Reply transaction?': trans.is_reply_transaction,
            'Flags': trans.flags + ' ' +
                binderFlagsToHuman(trans.flags),
            'Code': trans.code + ' ' +
                binderCodeToHuman(trans.code),
            'Calling PID': trans.calling_pid,
            'Calling tgid': trans.calling_kthread.thread.parent.pid
        };
    }

    function BinderTransaction(events, callingPid, callingTs, callingKthread) {
        this.transaction_key = parseInt(events[1]);
        this.dest_node = parseInt(events[2]);
        this.dest_proc = parseInt(events[3]);
        this.dest_thread = parseInt(events[4]);
        this.is_reply_transaction = parseInt(events[5]) === 1 ? true : false;
        this.expect_reply = ((this.is_reply_transaction === false) && (parseInt(events[6], 16) & TF_ONE_WAY) === 0);
        this.flags = events[6];
        this.code = events[7];
        this.calling_pid = callingPid;
        this.calling_ts = callingTs;
        this.calling_kthread = callingKthread;
    }

    function BinderParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('binder_locked', BinderParser.prototype.binderLocked.bind(this));
        importer.registerEventHandler('binder_unlock', BinderParser.prototype.binderUnlock.bind(this));
        importer.registerEventHandler('binder_lock', BinderParser.prototype.binderLock.bind(this));
        importer.registerEventHandler('binder_transaction', BinderParser.prototype.binderTransaction.bind(this));
        importer.registerEventHandler('binder_transaction_received', BinderParser.prototype.binderTransactionReceived.bind(this));
        importer.registerEventHandler('binder_transaction_alloc_buf', BinderParser.prototype.binderTransactionAllocBuf.bind(this));
        this.model_ = importer.model;
        this.kthreadlookup = {};
        this.importer_ = importer;
        this.transWaitingRecv = {};
        this.syncTransWaitingCompletion = {};
        this.recursiveSyncTransWaitingCompletion_ByPID = {};
        this.receivedTransWaitingConversion = {};
    }

    BinderParser.prototype = {
        __proto__: Parser.prototype, binderLock(eventName, cpuNumber, pid, ts, eventBase) {
            const tgid = parseInt(eventBase.tgid);
            if (isNaN(tgid)) return false;
            this.doNameMappings(pid, tgid, eventName.threadName);
            const kthread = this.importer_.getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);
            kthread.binderAttemptLockTS = ts;
            kthread.binderOpenTsA = ts;
            return true;
        }, binderLocked(eventName, cpuNumber, pid, ts, eventBase) {
            const tgid = parseInt(eventBase.tgid);
            if (isNaN(tgid)) return false;
            const binderThread = isBinderThread(eventBase.threadName);
            const name = eventBase.threadName;
            const kthread = this.importer_.getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);
            this.doNameMappings(pid, tgid, name);
            const rthread = kthread.thread;
            kthread.binderLockAquiredTS = ts;
            if (kthread.binderAttemptLockTS === undefined) return false;
            const args = this.generateArgsForSlice(tgid, pid, name, kthread);
            rthread.sliceGroup.pushCompleteSlice('binder', 'binder lock waiting', kthread.binderAttemptLockTS, ts - kthread.binderAttemptLockTS, 0, 0, args);
            kthread.binderAttemptLockTS = undefined;
            return true;
        }, binderUnlock(eventName, cpuNumber, pid, ts, eventBase) {
            const tgid = parseInt(eventBase.tgid);
            if (isNaN(tgid)) return false;
            const kthread = this.importer_.getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);
            if (kthread.binderLockAquiredTS === undefined) return false;
            const args = this.generateArgsForSlice(tgid, pid, eventBase.threadName, kthread);
            kthread.thread.sliceGroup.pushCompleteSlice('binder', 'binder lock held', kthread.binderLockAquiredTS, ts - kthread.binderLockAquiredTS, 0, 0, args);
            kthread.binderLockAquiredTS = undefined;
            return true;
        }, binderTransaction(eventName, cpuNumber, pid, ts, eventBase) {
            const event = binderTransRE.exec(eventBase.details);
            if (event === undefined) return false;
            const tgid = parseInt(eventBase.tgid);
            if (isNaN(tgid)) return false;
            this.doNameMappings(pid, tgid, eventBase.threadName);
            const kthread = this.importer_.getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);
            const trans = new BinderTransaction(event, pid, ts, kthread);
            const args = generateBinderArgsForSlice(trans, eventBase.threadName);
            const priorReceive = this.getPriorReceiveOnPID(pid);
            if (priorReceive !== false) {
                return this.modelPriorReceive(priorReceive, ts, pid, tgid, kthread, trans, args, event);
            }
            const recursiveTrans = this.getRecursiveTransactionNeedingCompletion(pid);
            if (recursiveTrans !== false) {
                return this.modelRecursiveTransactions(recursiveTrans, ts, pid, kthread, trans, args);
            }
            const slice = kthread.thread.sliceGroup.pushCompleteSlice('binder', '', ts, .03, 0, 0, args);
            slice.colorId = ColorScheme.getColorIdForGeneralPurposeString(ts.toString());
            trans.slice = slice;
            if (trans.expect_reply) {
                slice.title = 'binder transaction';
            } else {
                slice.title = 'binder transaction async';
            }
            this.addTransactionWaitingForRecv(trans.transaction_key, trans);
            return true;
        }, binderTransactionReceived(eventName, cpuNumber, pid, ts, eventBase) {
            const event = binderTransReceivedRE.exec(eventBase.details);
            if (event === undefined) return false;
            const tgid = parseInt(eventBase.tgid);
            if (isNaN(tgid)) return false;
            const transactionkey = parseInt(event[1]);
            const kthread = this.importer_.getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);
            const syncComplete = this.getSyncTransNeedsCompletion(transactionkey);
            if (syncComplete !== false) {
                const syncTrans = syncComplete[0];
                const syncSlice = syncTrans.slice;
                const responseTrans = syncComplete[1];
                const responseSlice = responseTrans.slice;
                syncSlice.duration = ts - syncSlice.start;
                const syncInternal = doInternalSlice(syncTrans, syncSlice, ts);
                const responseTs = responseSlice.start + responseSlice.duration;
                const responseInternal = doInternalSlice(responseTrans, responseSlice, responseTs);
                if (responseSlice.outFlowEvents.length === 0 || syncSlice.inFlowEvents.length === 0) {
                    const flow = this.generateFlow(responseInternal, syncInternal, responseTrans, syncTrans);
                    syncSlice.inFlowEvents.push(flow);
                    responseSlice.outFlowEvents.push(flow);
                    this.model_.flowEvents.push(flow);
                }
                for (let i = 1; i < syncSlice.inFlowEvents.length; i++) {
                    syncSlice.inFlowEvents[i].duration = ts - syncSlice.inFlowEvents[i].start;
                }
                return true;
            }
            const trForRecv = this.getTransactionWaitingForRecv(transactionkey);
            if (trForRecv !== false) {
                if (!trForRecv.expect_reply) {
                    const args = generateBinderArgsForSlice(trForRecv, eventBase.threadName);
                    const slice = kthread.thread.sliceGroup.pushCompleteSlice('binder', 'binder Async recv', ts, .03, 0, 0, args);
                    const fakeEvent = [0, 0, 0, 0, 0, 0, 0];
                    const fakeTrans = new BinderTransaction(fakeEvent, pid, ts, kthread);
                    const flow = this.generateFlow(trForRecv.slice, slice, trForRecv, fakeTrans);
                    this.model_.flowEvents.push(flow);
                    trForRecv.slice.title = 'binder transaction async';
                    trForRecv.slice.duration = .03;
                    return true;
                }
                trForRecv.slice.title = 'binder transaction';
                this.setCurrentReceiveOnPID(pid, [ts, trForRecv]);
                return true;
            }
            return false;
        }, binderTransactionAllocBuf(eventName, cpuNumber, pid, ts, eventBase) {
            const event = binderAllocRE.exec(eventBase.details);
            if (event === null) return false;
            const tgid = parseInt(eventBase.tgid);
            if (isNaN(tgid)) return false;
            const transactionkey = parseInt(event[1]);
            const kthread = this.importer_.getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);
            const trans = this.peekTransactionWaitingForRecv(transactionkey);
            if (trans && trans.slice) {
                trans.slice.args['Data Size'] = parseInt(event[2]);
                trans.slice.args['Offsets Size'] = parseInt(event[3]);
                return true;
            }
            return false;
        }, modelRecursiveTransactions(recursiveTrans, ts, pid, kthread, trans, args) {
            const recursiveSlice = recursiveTrans[1].slice;
            const origSlice = recursiveTrans[0].slice;
            recursiveSlice.duration = ts - recursiveSlice.start;
            recursiveSlice.args = args;
            trans.slice = recursiveSlice;
            if (trans.is_reply_transaction) {
                origSlice.duration = ts - origSlice.start;
                this.addSyncTransNeedingCompletion(trans.transaction_key, recursiveTrans);
                if (isReplyToOrigin(recursiveTrans[0], trans)) {
                    this.removeRecursiveTransaction(pid);
                }
            } else {
                const slice = kthread.thread.sliceGroup.pushCompleteSlice('binder', '', ts, .03, 0, 0, args);
                trans.slice = slice;
                this.addTransactionWaitingForRecv(trans.transaction_key, trans);
            }
            return true;
        }, modelPriorReceive(priorReceive, ts, pid, tgid, kthread, trans, args, event) {
            const calleeSlice = priorReceive[1].slice;
            const calleeTrans = priorReceive[1];
            const recvTs = priorReceive[0];
            let slice = kthread.thread.sliceGroup.pushCompleteSlice('binder', '', recvTs, ts - recvTs, 0, 0);
            const flow = this.generateFlow(calleeSlice, slice, calleeTrans, trans);
            this.model_.flowEvents.push(flow);
            trans.slice = slice;
            if (trans.is_reply_transaction) {
                slice.title = 'binder reply';
                slice.args = args;
                this.addSyncTransNeedingCompletion(trans.transaction_key, [calleeTrans, trans]);
            } else {
                slice.title = 'binder reply';
                const trans1 = new BinderTransaction(event, pid, ts, kthread);
                slice = kthread.thread.sliceGroup.pushCompleteSlice('binder', 'binder transaction', recvTs, (ts - recvTs), 0, 0, args);
                if (!trans.expect_reply) {
                    slice.title = 'binder transaction async';
                    slice.duration = .03;
                } else {
                }
                trans1.slice = slice;
                this.addRecursiveSyncTransNeedingCompletion(pid, [calleeTrans, trans]);
                this.addTransactionWaitingForRecv(trans.transaction_key, trans1);
            }
            return true;
        }, getRecursiveTransactionNeedingCompletion(pid) {
            if (this.recursiveSyncTransWaitingCompletion_ByPID[pid] === undefined) {
                return false;
            }
            const len = this.recursiveSyncTransWaitingCompletion_ByPID[pid].length;
            if (len === 0) return false;
            return this.recursiveSyncTransWaitingCompletion_ByPID[pid][len - 1];
        }, addRecursiveSyncTransNeedingCompletion(pid, tuple) {
            if (this.recursiveSyncTransWaitingCompletion_ByPID[pid] === undefined) {
                this.recursiveSyncTransWaitingCompletion_ByPID[pid] = [];
            }
            this.recursiveSyncTransWaitingCompletion_ByPID[pid].push(tuple);
        }, removeRecursiveTransaction(pid) {
            const len = this.recursiveSyncTransWaitingCompletion_ByPID[pid].length;
            if (len === 0) {
                delete this.recursiveSyncTransWaitingCompletion_ByPID[pid];
                return;
            }
            this.recursiveSyncTransWaitingCompletion_ByPID[pid].splice(len - 1, 1);
        }, setCurrentReceiveOnPID(pid, tuple) {
            if (this.receivedTransWaitingConversion[pid] === undefined) {
                this.receivedTransWaitingConversion[pid] = [];
            }
            this.receivedTransWaitingConversion[pid].push(tuple);
        }, getPriorReceiveOnPID(pid) {
            if (this.receivedTransWaitingConversion[pid] === undefined) {
                return false;
            }
            const len = this.receivedTransWaitingConversion[pid].length;
            if (len === 0) return false;
            return this.receivedTransWaitingConversion[pid].splice(len - 1, 1)[0];
        }, addSyncTransNeedingCompletion(transactionkey, tuple) {
            const dict = this.syncTransWaitingCompletion;
            dict[transactionkey] = tuple;
        }, getSyncTransNeedsCompletion(transactionkey) {
            const ret = this.syncTransWaitingCompletion[transactionkey];
            if (ret === undefined) return false;
            delete this.syncTransWaitingCompletion[transactionkey];
            return ret;
        }, getTransactionWaitingForRecv(transactionkey) {
            const ret = this.transWaitingRecv[transactionkey];
            if (ret === undefined) return false;
            delete this.transWaitingRecv[transactionkey];
            return ret;
        }, peekTransactionWaitingForRecv(transactionkey) {
            const ret = this.transWaitingRecv[transactionkey];
            if (ret === undefined) return false;
            return ret;
        }, addTransactionWaitingForRecv(transactionkey, transaction) {
            this.transWaitingRecv[transactionkey] = transaction;
        }, generateFlow(from, to, fromTrans, toTrans) {
            const title = 'Transaction from : ' +
                this.pid2name(fromTrans.calling_pid) + ' From PID: ' + fromTrans.calling_pid + ' to pid: ' +
                toTrans.calling_pid + ' Thread Name: ' + this.pid2name(toTrans.calling_pid);
            const ts = from.start;
            const flow = new tr.model.FlowEvent('binder', 'binder', title, 1, ts, []);
            flow.startSlice = from;
            flow.endSlice = to;
            flow.start = from.start;
            flow.duration = to.start - ts;
            from.outFlowEvents.push(flow);
            to.inFlowEvents.push(flow);
            return flow;
        }, generateArgsForSlice(tgid, pid, name, kthread) {
            return {'Thread Name': name, pid, 'gid': tgid};
        }, pid2name(pid) {
            return this.kthreadlookup[pid];
        }, doNameMappings(pid, tgid, name) {
            this.registerPidName(pid, name);
            this.registerPidName(tgid, name);
        }, registerPidName(pid, name) {
            if (this.pid2name(pid) === undefined) {
                this.kthreadlookup[pid] = name;
            }
        }
    };
    Parser.register(BinderParser);
    return {BinderParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function BusParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('memory_bus_usage', BusParser.prototype.traceMarkWriteBusEvent.bind(this));
        this.model_ = importer.model_;
        this.ppids_ = {};
    }

    BusParser.prototype = {
        __proto__: Parser.prototype, traceMarkWriteBusEvent(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const re = new RegExp('bus=(\\S+) rw_bytes=(\\d+) r_bytes=(\\d+) ' + 'w_bytes=(\\d+) cycles=(\\d+) ns=(\\d+)');
            const event = re.exec(eventBase.details);
            const name = event[1];
            const rwBytes = parseInt(event[2]);
            const rBytes = parseInt(event[3]);
            const wBytes = parseInt(event[4]);
            const cycles = parseInt(event[5]);
            const ns = parseInt(event[6]);
            const sec = tr.b.convertUnit(ns, tr.b.UnitPrefixScale.METRIC.NANO, tr.b.UnitPrefixScale.METRIC.NONE);
            const readBandwidthInBps = rBytes / sec;
            const readBandwidthInMiBps = tr.b.convertUnit(readBandwidthInBps, tr.b.UnitPrefixScale.BINARY.NONE, tr.b.UnitPrefixScale.BINARY.MEBI);
            const writeBandwidthInBps = wBytes / sec;
            const writeBandwidthInMiBps = tr.b.convertUnit(writeBandwidthInBps, tr.b.UnitPrefixScale.BINARY.NONE, tr.b.UnitPrefixScale.BINARY.MEBI);
            let ctr = this.model_.kernel.getOrCreateCounter(null, 'bus ' + name + ' read');
            if (ctr.numSeries === 0) {
                ctr.addSeries(new tr.model.CounterSeries('value', ColorScheme.getColorIdForGeneralPurposeString(ctr.name + '.' + 'value')));
            }
            ctr.series.forEach(function (series) {
                series.addCounterSample(ts, readBandwidthInMiBps);
            });
            ctr = this.model_.kernel.getOrCreateCounter(null, 'bus ' + name + ' write');
            if (ctr.numSeries === 0) {
                ctr.addSeries(new tr.model.CounterSeries('value', ColorScheme.getColorIdForGeneralPurposeString(ctr.name + '.' + 'value')));
            }
            ctr.series.forEach(function (series) {
                series.addCounterSample(ts, writeBandwidthInMiBps);
            });
            return true;
        }
    };
    Parser.register(BusParser);
    return {BusParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function ClockParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('clock_set_rate', ClockParser.prototype.traceMarkWriteClockEvent.bind(this));
        importer.registerEventHandler('clk_set_rate', ClockParser.prototype.traceMarkWriteClkEvent.bind(this));
        importer.registerEventHandler('clock_enable', ClockParser.prototype.traceMarkWriteClockOnOffEvent.bind(this));
        importer.registerEventHandler('clock_disable', ClockParser.prototype.traceMarkWriteClockOnOffEvent.bind(this));
        importer.registerEventHandler('clk_enable', ClockParser.prototype.traceMarkWriteClkOnEvent.bind(this));
        importer.registerEventHandler('clk_disable', ClockParser.prototype.traceMarkWriteClkOffEvent.bind(this));
        this.model_ = importer.model_;
        this.ppids_ = {};
    }

    ClockParser.prototype = {
        __proto__: Parser.prototype, clockMark(name, subName, value, ts) {
            const ctr = this.model_.kernel.getOrCreateCounter(null, name + ' ' + subName);
            if (ctr.numSeries === 0) {
                ctr.addSeries(new tr.model.CounterSeries('value', ColorScheme.getColorIdForGeneralPurposeString(ctr.name + '.' + 'value')));
            }
            ctr.series.forEach(function (series) {
                series.addCounterSample(ts, value);
            });
        }, traceMarkWriteClockEvent(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = /(\S+) state=(\d+)/.exec(eventBase.details);
            const name = event[1];
            const rate = parseInt(event[2]);
            this.clockMark(name, 'Frequency', rate, ts);
            return true;
        }, traceMarkWriteClkEvent(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = /(\S+) (\d+)/.exec(eventBase.details);
            const name = event[1];
            const rate = parseInt(event[2]);
            this.clockMark(name, 'Frequency', rate, ts);
            return true;
        }, traceMarkWriteClockOnOffEvent(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = /(\S+) state=(\d+)/.exec(eventBase.details);
            const name = event[1];
            const state = parseInt(event[2]);
            this.clockMark(name, 'State', state, ts);
            return true;
        }, traceMarkWriteClkOnEvent(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = /\S+/.exec(eventBase.details);
            const name = event[0];
            this.clockMark(name, 'State', 1, ts);
            return true;
        }, traceMarkWriteClkOffEvent(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = /\S+/.exec(eventBase.details);
            const name = event[0];
            this.clockMark(name, 'State', 0, ts);
            return true;
        }
    };
    Parser.register(ClockParser);
    return {ClockParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function CpufreqParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('cpufreq_interactive_up', CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_down', CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_already', CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_notyet', CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_setspeed', CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_target', CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_boost', CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
        importer.registerEventHandler('cpufreq_interactive_unboost', CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
    }

    function splitData(input) {
        const data = {};
        const args = input.split(/\s+/);
        const len = args.length;
        for (let i = 0; i < len; i++) {
            const item = args[i].split('=');
            data[item[0]] = parseInt(item[1]);
        }
        return data;
    }

    CpufreqParser.prototype = {
        __proto__: Parser.prototype, cpufreqSlice(ts, eventName, cpu, args) {
            const kthread = this.importer.getOrCreatePseudoThread('cpufreq');
            kthread.openSlice = eventName;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, cpufreqBoostSlice(ts, eventName, args) {
            const kthread = this.importer.getOrCreatePseudoThread('cpufreq_boost');
            kthread.openSlice = eventName;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, cpufreqUpDownEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const data = splitData(eventBase.details);
            this.cpufreqSlice(ts, eventName, data.cpu, data);
            return true;
        }, cpufreqTargetEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const data = splitData(eventBase.details);
            this.cpufreqSlice(ts, eventName, data.cpu, data);
            return true;
        }, cpufreqBoostUnboostEvent(eventName, cpuNumber, pid, ts, eventBase) {
            this.cpufreqBoostSlice(ts, eventName, {type: eventBase.details});
            return true;
        }
    };
    Parser.register(CpufreqParser);
    return {CpufreqParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function DiskParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('f2fs_write_begin', DiskParser.prototype.f2fsWriteBeginEvent.bind(this));
        importer.registerEventHandler('f2fs_write_end', DiskParser.prototype.f2fsWriteEndEvent.bind(this));
        importer.registerEventHandler('f2fs_sync_file_enter', DiskParser.prototype.f2fsSyncFileEnterEvent.bind(this));
        importer.registerEventHandler('f2fs_sync_file_exit', DiskParser.prototype.f2fsSyncFileExitEvent.bind(this));
        importer.registerEventHandler('ext4_sync_file_enter', DiskParser.prototype.ext4SyncFileEnterEvent.bind(this));
        importer.registerEventHandler('ext4_sync_file_exit', DiskParser.prototype.ext4SyncFileExitEvent.bind(this));
        importer.registerEventHandler('ext4_da_write_begin', DiskParser.prototype.ext4WriteBeginEvent.bind(this));
        importer.registerEventHandler('ext4_da_write_end', DiskParser.prototype.ext4WriteEndEvent.bind(this));
        importer.registerEventHandler('block_rq_issue', DiskParser.prototype.blockRqIssueEvent.bind(this));
        importer.registerEventHandler('block_rq_complete', DiskParser.prototype.blockRqCompleteEvent.bind(this));
    }

    DiskParser.prototype = {
        __proto__: Parser.prototype, openAsyncSlice(ts, category, threadName, pid, key, name) {
            const kthread = this.importer.getOrCreateKernelThread(category + ':' + threadName, pid);
            const asyncSliceConstructor = tr.model.AsyncSlice.subTypes.getConstructor(category, name);
            const slice = new asyncSliceConstructor(category, name, ColorScheme.getColorIdForGeneralPurposeString(name), ts);
            slice.startThread = kthread.thread;
            if (!kthread.openAsyncSlices) {
                kthread.openAsyncSlices = {};
            }
            kthread.openAsyncSlices[key] = slice;
        }, closeAsyncSlice(ts, category, threadName, pid, key, args) {
            const kthread = this.importer.getOrCreateKernelThread(category + ':' + threadName, pid);
            if (kthread.openAsyncSlices) {
                const slice = kthread.openAsyncSlices[key];
                if (slice) {
                    slice.duration = ts - slice.start;
                    slice.args = args;
                    slice.endThread = kthread.thread;
                    slice.subSlices = [new tr.model.AsyncSlice(category, slice.title, slice.colorId, slice.start, slice.args, slice.duration)];
                    kthread.thread.asyncSliceGroup.push(slice);
                    delete kthread.openAsyncSlices[key];
                }
            }
        }, f2fsWriteBeginEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev = \((\d+,\d+)\), ino = (\d+), pos = (\d+), len = (\d+), flags = (\d+)/.exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const pos = parseInt(event[3]);
            const len = parseInt(event[4]);
            const key = device + '-' + inode + '-' + pos + '-' + len;
            this.openAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid, key, 'f2fs_write');
            return true;
        }, f2fsWriteEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev = \((\d+,\d+)\), ino = (\d+), pos = (\d+), len = (\d+), copied = (\d+)/.exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const pos = parseInt(event[3]);
            const len = parseInt(event[4]);
            const error = parseInt(event[5]) !== len;
            const key = device + '-' + inode + '-' + pos + '-' + len;
            this.closeAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid, key, {device, inode, error});
            return true;
        }, ext4WriteBeginEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev (\d+,\d+) ino (\d+) pos (\d+) len (\d+) flags (\d+)/.exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const pos = parseInt(event[3]);
            const len = parseInt(event[4]);
            const key = device + '-' + inode + '-' + pos + '-' + len;
            this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid, key, 'ext4_write');
            return true;
        }, ext4WriteEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev (\d+,\d+) ino (\d+) pos (\d+) len (\d+) copied (\d+)/.exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const pos = parseInt(event[3]);
            const len = parseInt(event[4]);
            const error = parseInt(event[5]) !== len;
            const key = device + '-' + inode + '-' + pos + '-' + len;
            this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid, key, {device, inode, error});
            return true;
        }, f2fsSyncFileEnterEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = new RegExp('dev = \\((\\d+,\\d+)\\), ino = (\\d+), pino = (\\d+), i_mode = (\\S+), ' + 'i_size = (\\d+), i_nlink = (\\d+), i_blocks = (\\d+), i_advise = (\\d+)').exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const key = device + '-' + inode;
            this.openAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid, key, 'fsync');
            return true;
        }, f2fsSyncFileExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = new RegExp('dev = \\((\\d+,\\d+)\\), ino = (\\d+), checkpoint is (\\S+), ' + 'datasync = (\\d+), ret = (\\d+)').exec(eventBase.details.replace('not needed', 'not_needed'));
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const error = parseInt(event[5]);
            const key = device + '-' + inode;
            this.closeAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid, key, {device, inode, error});
            return true;
        }, ext4SyncFileEnterEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev (\d+,\d+) ino (\d+) parent (\d+) datasync (\d+)/.exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const datasync = (event[4] === '1') || (event[4] === 1);
            const key = device + '-' + inode;
            const action = datasync ? 'fdatasync' : 'fsync';
            this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid, key, action);
            return true;
        }, ext4SyncFileExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev (\d+,\d+) ino (\d+) ret (\d+)/.exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const inode = parseInt(event[2]);
            const error = parseInt(event[3]);
            const key = device + '-' + inode;
            this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid, key, {device, inode, error});
            return true;
        }, blockRqIssueEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' + '\\d+ \\(.*\\) (\\d+) \\+ (\\d+) \\[.*\\]').exec(eventBase.details);
            if (!event) return false;
            let action;
            switch (event[3]) {
                case'D':
                    action = 'discard';
                    break;
                case'W':
                    action = 'write';
                    break;
                case'R':
                    action = 'read';
                    break;
                case'N':
                    action = 'none';
                    break;
                default:
                    action = 'unknown';
                    break;
            }
            if (event[2]) {
                action += ' flush';
            }
            if (event[4] === 'F') {
                action += ' fua';
            }
            if (event[5] === 'A') {
                action += ' ahead';
            }
            if (event[6] === 'S') {
                action += ' sync';
            }
            if (event[7] === 'M') {
                action += ' meta';
            }
            const device = event[1];
            const sector = parseInt(event[8]);
            const numSectors = parseInt(event[9]);
            const key = device + '-' + sector + '-' + numSectors;
            this.openAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid, key, action);
            return true;
        }, blockRqCompleteEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' + '\\(.*\\) (\\d+) \\+ (\\d+) \\[(.*)\\]').exec(eventBase.details);
            if (!event) return false;
            const device = event[1];
            const sector = parseInt(event[8]);
            const numSectors = parseInt(event[9]);
            const error = parseInt(event[10]);
            const key = device + '-' + sector + '-' + numSectors;
            this.closeAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid, key, {
                device,
                sector,
                numSectors,
                error
            });
            return true;
        }
    };
    Parser.register(DiskParser);
    return {DiskParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function DmaFenceParser(importer) {
        Parser.call(this, importer);
        this.model_ = importer.model_;
        importer.registerEventHandler('dma_fence_init', DmaFenceParser.prototype.initEvent.bind(this));
        importer.registerEventHandler('dma_fence_emit', DmaFenceParser.prototype.initEvent.bind(this));
        importer.registerEventHandler('dma_fence_destroy', DmaFenceParser.prototype.fenceDestroyEvent.bind(this));
        importer.registerEventHandler('dma_fence_enable_signal', DmaFenceParser.prototype.fenceEnableSignalEvent.bind(this));
        importer.registerEventHandler('dma_fence_signaled', DmaFenceParser.prototype.fenceSignaledEvent.bind(this));
        importer.registerEventHandler('dma_fence_wait_start', DmaFenceParser.prototype.fenceWaitEvent.bind(this));
        importer.registerEventHandler('dma_fence_wait_end', DmaFenceParser.prototype.fenceWaitEvent.bind(this));
        importer.registerEventHandler('fence_init', DmaFenceParser.prototype.initEvent.bind(this));
        importer.registerEventHandler('fence_emit', DmaFenceParser.prototype.initEvent.bind(this));
        importer.registerEventHandler('fence_destroy', DmaFenceParser.prototype.fenceDestroyEvent.bind(this));
        importer.registerEventHandler('fence_enable_signal', DmaFenceParser.prototype.fenceEnableSignalEvent.bind(this));
        importer.registerEventHandler('fence_signaled', DmaFenceParser.prototype.fenceSignaledEvent.bind(this));
        importer.registerEventHandler('fence_wait_start', DmaFenceParser.prototype.fenceWaitEvent.bind(this));
        importer.registerEventHandler('fence_wait_end', DmaFenceParser.prototype.fenceWaitEvent.bind(this));
        this.model_ = importer.model_;
    }

    const fenceRE = /driver=(\S+) timeline=(\S+) context=(\d+) seqno=(\d+)/;
    DmaFenceParser.prototype = {
        __proto__: Parser.prototype, initEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = fenceRE.exec(eventBase.details);
            if (!event) return false;
            if (eventBase.tgid === undefined) {
                return false;
            }
            const thread = this.importer.getOrCreatePseudoThread(event[2]);
            thread.lastActiveTs = ts;
            return true;
        }, fenceDestroyEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = fenceRE.exec(eventBase.details);
            if (!event) return false;
            if (eventBase.tgid === undefined) {
                return false;
            }
            const thread = this.importer.getOrCreatePseudoThread(event[2]);
            const name = 'fence_destroy(' + event[4] + ')';
            const colorName = 'fence(' + event[4] + ')';
            if (thread.lastActiveTs !== undefined) {
                const duration = ts - thread.lastActiveTs;
                const slice = new tr.model.ThreadSlice('', name, ColorScheme.getColorIdForGeneralPurposeString(colorName), thread.lastActiveTs, {
                    driver: event[1],
                    context: event[3]
                }, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            if (thread.thread.sliceGroup.openSliceCount > 0) {
                thread.thread.sliceGroup.endSlice(ts);
            }
            thread.lastActiveTs = ts;
        }, fenceEnableSignalEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = fenceRE.exec(eventBase.details);
            if (!event) return false;
            if (eventBase.tgid === undefined) {
                return false;
            }
            const thread = this.importer.getOrCreatePseudoThread(event[2]);
            const name = 'fence_enable(' + event[4] + ')';
            const colorName = 'fence(' + event[4] + ')';
            if (thread.lastActiveTs !== undefined) {
                const duration = ts - thread.lastActiveTs;
                const slice = new tr.model.ThreadSlice('', name, ColorScheme.getColorIdForGeneralPurposeString(colorName), thread.lastActiveTs, {
                    driver: event[1],
                    context: event[3]
                }, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            if (thread.thread.sliceGroup.openSliceCount > 0) {
                thread.thread.sliceGroup.endSlice(ts);
            }
            thread.lastActiveTs = ts;
        }, fenceSignaledEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = fenceRE.exec(eventBase.details);
            if (!event) return false;
            if (eventBase.tgid === undefined) {
                return false;
            }
            const thread = this.importer.getOrCreatePseudoThread(event[2]);
            const name = 'fence_signal(' + event[4] + ')';
            const colorName = 'fence(' + event[4] + ')';
            if (thread.lastActiveTs !== undefined) {
                const duration = ts - thread.lastActiveTs;
                const slice = new tr.model.ThreadSlice('', name, ColorScheme.getColorIdForGeneralPurposeString(colorName), thread.lastActiveTs, {
                    driver: event[1],
                    context: event[3]
                }, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            if (thread.thread.sliceGroup.openSliceCount > 0) {
                thread.thread.sliceGroup.endSlice(ts);
            }
            thread.lastActiveTs = ts;
            return true;
        }, fenceWaitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            if (eventBase.tgid === undefined) return false;
            const event = fenceRE.exec(eventBase.details);
            if (!event) return false;
            const tgid = parseInt(eventBase.tgid);
            const thread = this.model_.getOrCreateProcess(tgid).getOrCreateThread(pid);
            thread.name = eventBase.threadName;
            const slices = thread.kernelSliceGroup;
            if (!slices.isTimestampValidForBeginOrEnd(ts)) {
                this.model_.importWarning({type: 'parse_error', message: 'Timestamps are moving backward.'});
                return false;
            }
            const name = 'dma_fence_wait("' + event[2] + '")';
            if (eventName.endsWith('start')) {
                const slice = slices.beginSlice(null, name, ts, {
                    driver: event[1],
                    context: event[3],
                    seqno: event[4],
                });
            } else {
                if (slices.openSliceCount > 0) {
                    slices.endSlice(ts);
                }
            }
            return true;
        },
    };
    Parser.register(DmaFenceParser);
    return {DmaFenceParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function DrmParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('drm_vblank_event', DrmParser.prototype.vblankEvent.bind(this));
    }

    DrmParser.prototype = {
        __proto__: Parser.prototype, drmVblankSlice(ts, eventName, args) {
            const kthread = this.importer.getOrCreatePseudoThread('drm_vblank');
            kthread.openSlice = eventName;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, vblankEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /crtc=(\d+), seq=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const crtc = parseInt(event[1]);
            const seq = parseInt(event[2]);
            this.drmVblankSlice(ts, 'vblank:' + crtc, {crtc, seq});
            return true;
        }
    };
    Parser.register(DrmParser);
    return {DrmParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function ExynosParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('exynos_busfreq_target_int', ExynosParser.prototype.busfreqTargetIntEvent.bind(this));
        importer.registerEventHandler('exynos_busfreq_target_mif', ExynosParser.prototype.busfreqTargetMifEvent.bind(this));
        importer.registerEventHandler('exynos_page_flip_state', ExynosParser.prototype.pageFlipStateEvent.bind(this));
    }

    ExynosParser.prototype = {
        __proto__: Parser.prototype, exynosBusfreqSample(name, ts, frequency) {
            const targetCpu = this.importer.getOrCreateCpu(0);
            const counter = targetCpu.getOrCreateCounter('', name);
            if (counter.numSeries === 0) {
                counter.addSeries(new tr.model.CounterSeries('frequency', ColorScheme.getColorIdForGeneralPurposeString(counter.name + '.' + 'frequency')));
            }
            counter.series.forEach(function (series) {
                series.addCounterSample(ts, frequency);
            });
        }, busfreqTargetIntEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /frequency=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            this.exynosBusfreqSample('INT Frequency', ts, parseInt(event[1]));
            return true;
        }, busfreqTargetMifEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /frequency=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            this.exynosBusfreqSample('MIF Frequency', ts, parseInt(event[1]));
            return true;
        }, exynosPageFlipStateOpenSlice(ts, pipe, fb, state) {
            const kthread = this.importer.getOrCreatePseudoThread('exynos_flip_state (pipe:' + pipe + ', fb:' + fb + ')');
            kthread.openSliceTS = ts;
            kthread.openSlice = state;
        }, exynosPageFlipStateCloseSlice(ts, pipe, fb, args) {
            const kthread = this.importer.getOrCreatePseudoThread('exynos_flip_state (pipe:' + pipe + ', fb:' + fb + ')');
            if (kthread.openSlice) {
                const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), kthread.openSliceTS, args, ts - kthread.openSliceTS);
                kthread.thread.sliceGroup.pushSlice(slice);
            }
            kthread.openSlice = undefined;
        }, pageFlipStateEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /pipe=(\d+), fb=(\d+), state=(.*)/.exec(eventBase.details);
            if (!event) return false;
            const pipe = parseInt(event[1]);
            const fb = parseInt(event[2]);
            const state = event[3];
            this.exynosPageFlipStateCloseSlice(ts, pipe, fb, {pipe, fb});
            if (state !== 'flipped') {
                this.exynosPageFlipStateOpenSlice(ts, pipe, fb, state);
            }
            return true;
        }
    };
    Parser.register(ExynosParser);
    return {ExynosParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const Parser = tr.e.importer.linux_perf.Parser;

    function GestureParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('tracing_mark_write:log', GestureParser.prototype.logEvent.bind(this));
        importer.registerEventHandler('tracing_mark_write:SyncInterpret', GestureParser.prototype.syncEvent.bind(this));
        importer.registerEventHandler('tracing_mark_write:HandleTimer', GestureParser.prototype.timerEvent.bind(this));
    }

    GestureParser.prototype = {
        __proto__: Parser.prototype, gestureOpenSlice(title, ts, opt_args) {
            const thread = this.importer.getOrCreatePseudoThread('gesture').thread;
            thread.sliceGroup.beginSlice('touchpad_gesture', title, ts, opt_args);
        }, gestureCloseSlice(title, ts) {
            const thread = this.importer.getOrCreatePseudoThread('gesture').thread;
            if (thread.sliceGroup.openSliceCount) {
                const slice = thread.sliceGroup.mostRecentlyOpenedPartialSlice;
                if (slice.title !== title) {
                    this.importer.model.importWarning({
                        type: 'title_match_error', message: 'Titles do not match. Title is ' +
                            slice.title + ' in openSlice, and is ' +
                            title + ' in endSlice'
                    });
                } else {
                    thread.sliceGroup.endSlice(ts);
                }
            }
        }, logEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
            switch (innerEvent[1]) {
                case'start':
                    this.gestureOpenSlice('GestureLog', ts, {name: innerEvent[2]});
                    break;
                case'end':
                    this.gestureCloseSlice('GestureLog', ts);
            }
            return true;
        }, syncEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
            switch (innerEvent[1]) {
                case'start':
                    this.gestureOpenSlice('SyncInterpret', ts, {interpreter: innerEvent[2]});
                    break;
                case'end':
                    this.gestureCloseSlice('SyncInterpret', ts);
            }
            return true;
        }, timerEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
            switch (innerEvent[1]) {
                case'start':
                    this.gestureOpenSlice('HandleTimer', ts, {interpreter: innerEvent[2]});
                    break;
                case'end':
                    this.gestureCloseSlice('HandleTimer', ts);
            }
            return true;
        }
    };
    Parser.register(GestureParser);
    return {GestureParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function I2cParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('i2c_write', I2cParser.prototype.i2cWriteEvent.bind(this));
        importer.registerEventHandler('i2c_read', I2cParser.prototype.i2cReadEvent.bind(this));
        importer.registerEventHandler('i2c_reply', I2cParser.prototype.i2cReplyEvent.bind(this));
        importer.registerEventHandler('i2c_result', I2cParser.prototype.i2cResultEvent.bind(this));
    }

    const i2cWriteReplyRE = new RegExp('i2c-(\\d+) #(\\d+) a=([\\da-fA-F]+) f=([\\da-fA-F]+) l=(\\d+) ' + '(\\[[\\da-fA-F\\-]+\\])');
    const i2cReadRE = /i2c-(\d+) #(\d+) a=([\da-fA-F]+) f=([\da-fA-F]+) l=(\d+)/;
    const i2cResultRE = /i2c-(\d+) n=(\d+) ret=(\d+)/;
    I2cParser.prototype = {
        __proto__: Parser.prototype, i2cWriteEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = i2cWriteReplyRE.exec(eventBase.details);
            if (!event) return false;
            const adapterNumber = parseInt(event[1]);
            const messageNumber = event[2];
            const address = event[3];
            const flags = event[4];
            const dataLength = event[5];
            const data = event[6];
            const thread = this.importer.getOrCreatePseudoThread('i2c adapter ' + adapterNumber);
            pushLastSliceIfNeeded(thread, event[1], ts);
            thread.lastEntryTitle = 'i2c write';
            thread.lastEntryTs = ts;
            thread.lastEntryArgs = {
                'Message number': messageNumber,
                'Address': address,
                'Flags': flags,
                'Data Length': dataLength,
                'Data': data
            };
            return true;
        }, i2cReadEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = i2cReadRE.exec(eventBase.details);
            if (!event) return false;
            const adapterNumber = parseInt(event[1]);
            const messageNumber = event[2];
            const address = event[3];
            const flags = event[4];
            const dataLength = event[5];
            const thread = this.importer.getOrCreatePseudoThread('i2c adapter ' + adapterNumber);
            pushLastSliceIfNeeded(thread, event[1], ts);
            thread.lastEntryTitle = 'i2c read';
            thread.lastEntryTs = ts;
            thread.lastEntryArgs = {
                'Message number': messageNumber,
                'Address': address,
                'Flags': flags,
                'Data Length': dataLength
            };
            return true;
        }, i2cReplyEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = i2cWriteReplyRE.exec(eventBase.details);
            if (!event) return false;
            const adapterNumber = parseInt(event[1]);
            const messageNumber = event[2];
            const address = event[3];
            const flags = event[4];
            const dataLength = event[5];
            const data = event[6];
            const thread = this.importer.getOrCreatePseudoThread('i2c adapter ' + adapterNumber);
            pushLastSliceIfNeeded(thread, event[1], ts);
            thread.lastEntryTitle = 'i2c reply';
            thread.lastEntryTs = ts;
            thread.lastEntryArgs = {
                'Message number': messageNumber,
                'Address': address,
                'Flags': flags,
                'Data Length': dataLength,
                'Data': data
            };
            return true;
        }, i2cResultEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = i2cResultRE.exec(eventBase.details);
            if (!event) return false;
            const adapterNumber = parseInt(event[1]);
            const numMessages = event[2];
            const ret = event[3];
            const thread = this.importer.getOrCreatePseudoThread('i2c adapter ' + adapterNumber);
            const args = thread.lastEntryArgs;
            if (args !== undefined) {
                args['Number of messages'] = numMessages;
                args.Return = ret;
            }
            pushLastSliceIfNeeded(thread, event[1], ts);
            thread.lastEntryTitle = undefined;
            thread.lastEntryTs = undefined;
            thread.lastEntryArgs = undefined;
            return true;
        },
    };

    function pushLastSliceIfNeeded(thread, id, currentTs) {
        if (thread.lastEntryTs !== undefined) {
            const duration = currentTs - thread.lastEntryTs;
            const slice = new tr.model.ThreadSlice('', thread.lastEntryTitle, ColorScheme.getColorIdForGeneralPurposeString(id), thread.lastEntryTs, thread.lastEntryArgs, duration);
            thread.thread.sliceGroup.pushSlice(slice);
        }
    }

    Parser.register(I2cParser);
    return {I2cParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function I915Parser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('i915_gem_object_create', I915Parser.prototype.gemObjectCreateEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_bind', I915Parser.prototype.gemObjectBindEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_unbind', I915Parser.prototype.gemObjectBindEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_change_domain', I915Parser.prototype.gemObjectChangeDomainEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_pread', I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_pwrite', I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_fault', I915Parser.prototype.gemObjectFaultEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_clflush', I915Parser.prototype.gemObjectDestroyEvent.bind(this));
        importer.registerEventHandler('i915_gem_object_destroy', I915Parser.prototype.gemObjectDestroyEvent.bind(this));
        importer.registerEventHandler('i915_gem_ring_dispatch', I915Parser.prototype.gemRingDispatchEvent.bind(this));
        importer.registerEventHandler('i915_gem_ring_flush', I915Parser.prototype.gemRingFlushEvent.bind(this));
        importer.registerEventHandler('i915_gem_request', I915Parser.prototype.gemRequestEvent.bind(this));
        importer.registerEventHandler('i915_gem_request_add', I915Parser.prototype.gemRequestEvent.bind(this));
        importer.registerEventHandler('i915_gem_request_complete', I915Parser.prototype.gemRequestEvent.bind(this));
        importer.registerEventHandler('i915_gem_request_retire', I915Parser.prototype.gemRequestEvent.bind(this));
        importer.registerEventHandler('i915_gem_request_wait_begin', I915Parser.prototype.gemRequestEvent.bind(this));
        importer.registerEventHandler('i915_gem_request_wait_end', I915Parser.prototype.gemRequestEvent.bind(this));
        importer.registerEventHandler('i915_gem_ring_wait_begin', I915Parser.prototype.gemRingWaitEvent.bind(this));
        importer.registerEventHandler('i915_gem_ring_wait_end', I915Parser.prototype.gemRingWaitEvent.bind(this));
        importer.registerEventHandler('i915_reg_rw', I915Parser.prototype.regRWEvent.bind(this));
        importer.registerEventHandler('i915_flip_request', I915Parser.prototype.flipEvent.bind(this));
        importer.registerEventHandler('i915_flip_complete', I915Parser.prototype.flipEvent.bind(this));
        importer.registerEventHandler('intel_gpu_freq_change', I915Parser.prototype.gpuFrequency.bind(this));
    }

    I915Parser.prototype = {
        __proto__: Parser.prototype, i915FlipOpenSlice(ts, obj, plane) {
            const kthread = this.importer.getOrCreatePseudoThread('i915_flip');
            kthread.openSliceTS = ts;
            kthread.openSlice = 'flip:' + obj + '/' + plane;
        }, i915FlipCloseSlice(ts, args) {
            const kthread = this.importer.getOrCreatePseudoThread('i915_flip');
            if (kthread.openSlice) {
                const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), kthread.openSliceTS, args, ts - kthread.openSliceTS);
                kthread.thread.sliceGroup.pushSlice(slice);
            }
            kthread.openSlice = undefined;
        }, i915GemObjectSlice(ts, eventName, obj, args) {
            const kthread = this.importer.getOrCreatePseudoThread('i915_gem');
            kthread.openSlice = eventName + ':' + obj;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, i915GemRingSlice(ts, eventName, dev, ring, args) {
            const kthread = this.importer.getOrCreatePseudoThread('i915_gem_ring');
            kthread.openSlice = eventName + ':' + dev + '.' + ring;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, i915RegSlice(ts, eventName, reg, args) {
            const kthread = this.importer.getOrCreatePseudoThread('i915_reg');
            kthread.openSlice = eventName + ':' + reg;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, i915FreqChangeSlice(ts, eventName, args) {
            const kthread = this.importer.getOrCreatePseudoThread('i915_gpu_freq');
            kthread.openSlice = eventName;
            const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), ts, args, 0);
            kthread.thread.sliceGroup.pushSlice(slice);
        }, gemObjectCreateEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /obj=(\w+), size=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const obj = event[1];
            const size = parseInt(event[2]);
            this.i915GemObjectSlice(ts, eventName, obj, {obj, size});
            return true;
        }, gemObjectBindEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /obj=(\w+), offset=(\w+), size=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const obj = event[1];
            const offset = event[2];
            const size = parseInt(event[3]);
            this.i915ObjectGemSlice(ts, eventName + ':' + obj, {obj, offset, size});
            return true;
        }, gemObjectChangeDomainEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /obj=(\w+), read=(\w+=>\w+), write=(\w+=>\w+)/.exec(eventBase.details);
            if (!event) return false;
            const obj = event[1];
            const read = event[2];
            const write = event[3];
            this.i915GemObjectSlice(ts, eventName, obj, {obj, read, write});
            return true;
        }, gemObjectPreadWriteEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /obj=(\w+), offset=(\d+), len=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const obj = event[1];
            const offset = parseInt(event[2]);
            const len = parseInt(event[3]);
            this.i915GemObjectSlice(ts, eventName, obj, {obj, offset, len});
            return true;
        }, gemObjectFaultEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /obj=(\w+), (\w+) index=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const obj = event[1];
            const type = event[2];
            const index = parseInt(event[3]);
            this.i915GemObjectSlice(ts, eventName, obj, {obj, type, index});
            return true;
        }, gemObjectDestroyEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /obj=(\w+)/.exec(eventBase.details);
            if (!event) return false;
            const obj = event[1];
            this.i915GemObjectSlice(ts, eventName, obj, {obj});
            return true;
        }, gemRingDispatchEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const dev = parseInt(event[1]);
            const ring = parseInt(event[2]);
            const seqno = parseInt(event[3]);
            this.i915GemRingSlice(ts, eventName, dev, ring, {dev, ring, seqno});
            return true;
        }, gemRingFlushEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev=(\d+), ring=(\w+), invalidate=(\w+), flush=(\w+)/.exec(eventBase.details);
            if (!event) return false;
            const dev = parseInt(event[1]);
            const ring = parseInt(event[2]);
            const invalidate = event[3];
            const flush = event[4];
            this.i915GemRingSlice(ts, eventName, dev, ring, {dev, ring, invalidate, flush});
            return true;
        }, gemRequestEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const dev = parseInt(event[1]);
            const ring = parseInt(event[2]);
            const seqno = parseInt(event[3]);
            this.i915GemRingSlice(ts, eventName, dev, ring, {dev, ring, seqno});
            return true;
        }, gemRingWaitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /dev=(\d+), ring=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const dev = parseInt(event[1]);
            const ring = parseInt(event[2]);
            this.i915GemRingSlice(ts, eventName, dev, ring, {dev, ring});
            return true;
        }, regRWEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /(\w+) reg=(\w+), len=(\d+), val=(\(\w+, \w+\))/.exec(eventBase.details);
            if (!event) return false;
            const rw = event[1];
            const reg = event[2];
            const len = event[3];
            const data = event[3];
            this.i915RegSlice(ts, rw, reg, {rw, reg, len, data});
            return true;
        }, flipEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /plane=(\d+), obj=(\w+)/.exec(eventBase.details);
            if (!event) return false;
            const plane = parseInt(event[1]);
            const obj = event[2];
            if (eventName === 'i915_flip_request') {
                this.i915FlipOpenSlice(ts, obj, plane);
            } else {
                this.i915FlipCloseSlice(ts, {obj, plane});
            }
            return true;
        }, gpuFrequency(eventName, cpuNumver, pid, ts, eventBase) {
            const event = /new_freq=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const freq = parseInt(event[1]);
            this.i915FreqChangeSlice(ts, eventName, {freq});
            return true;
        }
    };
    Parser.register(I915Parser);
    return {I915Parser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function IonHeapParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('ion_heap_shrink', IonHeapParser.prototype.traceIonHeapShrink.bind(this));
        importer.registerEventHandler('ion_heap_grow', IonHeapParser.prototype.traceIonHeapGrow.bind(this));
        this.model_ = importer.model_;
    }

    const TestExports = {};
    const ionHeapRE = new RegExp('heap_name=(\\S+), len=(\\d+), total_allocated=(\\d+)');
    TestExports.ionHeapRE = ionHeapRE;
    IonHeapParser.prototype = {
        __proto__: Parser.prototype, traceIonHeapShrink(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = ionHeapRE.exec(eventBase.details);
            if (!event) return false;
            const name = event[1];
            const len = parseInt(event[2]);
            const totalAllocated = parseInt(event[3]);
            const ionHeap = totalAllocated + len;
            const ctr = this.model_.kernel.getOrCreateCounter(null, name + ' ion heap');
            if (ctr.numSeries === 0) {
                ctr.addSeries(new tr.model.CounterSeries('value', ColorScheme.getColorIdForGeneralPurposeString(ctr.name + '.' + 'value')));
            }
            ctr.series.forEach(function (series) {
                series.addCounterSample(ts, ionHeap);
            });
            return true;
        }, traceIonHeapGrow(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            const event = ionHeapRE.exec(eventBase.details);
            if (!event) return false;
            const name = event[1];
            const len = parseInt(event[2]);
            const totalAllocated = parseInt(event[3]);
            const ionHeap = totalAllocated + len;
            const ctr = this.model_.kernel.getOrCreateCounter(null, name + ' ion heap');
            if (ctr.numSeries === 0) {
                ctr.addSeries(new tr.model.CounterSeries('value', ColorScheme.getColorIdForGeneralPurposeString(ctr.name + '.' + 'value')));
            }
            ctr.series.forEach(function (series) {
                series.addCounterSample(ts, ionHeap);
            });
            return true;
        }
    };
    Parser.register(IonHeapParser);
    return {IonHeapParser, _IonHeapParserTestExports: TestExports};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function IrqParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('irq_handler_entry', IrqParser.prototype.irqHandlerEntryEvent.bind(this));
        importer.registerEventHandler('irq_handler_exit', IrqParser.prototype.irqHandlerExitEvent.bind(this));
        importer.registerEventHandler('softirq_raise', IrqParser.prototype.softirqRaiseEvent.bind(this));
        importer.registerEventHandler('softirq_entry', IrqParser.prototype.softirqEntryEvent.bind(this));
        importer.registerEventHandler('softirq_exit', IrqParser.prototype.softirqExitEvent.bind(this));
        importer.registerEventHandler('ipi_entry', IrqParser.prototype.ipiEntryEvent.bind(this));
        importer.registerEventHandler('ipi_exit', IrqParser.prototype.ipiExitEvent.bind(this));
        importer.registerEventHandler('preempt_disable', IrqParser.prototype.preemptStartEvent.bind(this));
        importer.registerEventHandler('preempt_enable', IrqParser.prototype.preemptEndEvent.bind(this));
        importer.registerEventHandler('irq_disable', IrqParser.prototype.irqoffStartEvent.bind(this));
        importer.registerEventHandler('irq_enable', IrqParser.prototype.irqoffEndEvent.bind(this));
    }

    const irqHandlerEntryRE = /irq=(\d+) name=(.+)/;
    const irqHandlerExitRE = /irq=(\d+) ret=(.+)/;
    const softirqRE = /vec=(\d+) \[action=(.+)\]/;
    const ipiHandlerExitRE = /\((.+)\)/;
    const preemptirqRE = /caller=(.+) parent=(.+)/;
    IrqParser.prototype = {
        __proto__: Parser.prototype, irqHandlerEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = irqHandlerEntryRE.exec(eventBase.details);
            if (!event) return false;
            const irq = parseInt(event[1]);
            const name = event[2];
            const thread = this.importer.getOrCreatePseudoThread('irqs cpu ' + cpuNumber);
            thread.lastEntryTs = ts;
            thread.irqName = name;
            return true;
        }, irqHandlerExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = irqHandlerExitRE.exec(eventBase.details);
            if (!event) return false;
            const irq = parseInt(event[1]);
            const ret = event[2];
            const thread = this.importer.getOrCreatePseudoThread('irqs cpu ' + cpuNumber);
            if (thread.lastEntryTs !== undefined) {
                const duration = ts - thread.lastEntryTs;
                const slice = new tr.model.ThreadSlice('', 'IRQ (' + thread.irqName + ')', ColorScheme.getColorIdForGeneralPurposeString(event[1]), thread.lastEntryTs, {ret}, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            thread.lastEntryTs = undefined;
            thread.irqName = undefined;
            return true;
        }, softirqRaiseEvent(eventName, cpuNumber, pid, ts, eventBase) {
            return true;
        }, softirqEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = softirqRE.exec(eventBase.details);
            if (!event) return false;
            const action = event[2];
            const thread = this.importer.getOrCreatePseudoThread('softirq cpu ' + cpuNumber);
            thread.lastEntryTs = ts;
            return true;
        }, softirqExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = softirqRE.exec(eventBase.details);
            if (!event) return false;
            const vec = parseInt(event[1]);
            const action = event[2];
            const thread = this.importer.getOrCreatePseudoThread('softirq cpu ' + cpuNumber);
            if (thread.lastEntryTs !== undefined) {
                const duration = ts - thread.lastEntryTs;
                const slice = new tr.model.ThreadSlice('', action, ColorScheme.getColorIdForGeneralPurposeString(event[1]), thread.lastEntryTs, {vec}, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            thread.lastEntryTs = undefined;
            return true;
        }, ipiEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const thread = this.importer.getOrCreatePseudoThread('irqs cpu ' + cpuNumber);
            thread.lastEntryTs = ts;
            return true;
        }, ipiExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = ipiHandlerExitRE.exec(eventBase.details);
            if (!event) return false;
            const ipiName = event[1];
            const thread = this.importer.getOrCreatePseudoThread('irqs cpu ' + cpuNumber);
            if (thread.lastEntryTs !== undefined) {
                const duration = ts - thread.lastEntryTs;
                const slice = new tr.model.ThreadSlice('', 'IPI (' + ipiName + ')', ColorScheme.getColorIdForGeneralPurposeString(ipiName), thread.lastEntryTs, {}, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            thread.lastEntryTs = undefined;
            return true;
        }, preemptStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = preemptirqRE.exec(eventBase.details);
            if (!event) return false;
            const thread = this.importer.getOrCreatePseudoThread('preempt cpu ' + cpuNumber);
            thread.lastEntryTs = ts;
            thread.preemptStartCaller = event[1];
            thread.preemptStartParent = event[2];
            return true;
        }, preemptEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = preemptirqRE.exec(eventBase.details);
            if (!event) return false;
            const thread = this.importer.getOrCreatePseudoThread('preempt cpu ' + cpuNumber);
            thread.preemptEndCaller = event[1];
            thread.preemptEndParent = event[2];
            if (thread.lastEntryTs !== undefined) {
                const duration = ts - thread.lastEntryTs;
                const slice = new tr.model.ThreadSlice('', thread.preemptStartParent + ': ' + thread.preemptStartCaller, ColorScheme.getColorIdForGeneralPurposeString(thread.preemptEndCaller), thread.lastEntryTs, {}, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            thread.lastEntryTs = undefined;
            return true;
        }, irqoffStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = preemptirqRE.exec(eventBase.details);
            if (!event) return false;
            const thread = this.importer.getOrCreatePseudoThread('irqoff cpu ' + cpuNumber);
            thread.lastEntryTs = ts;
            thread.irqoffStartCaller = event[1];
            thread.irqoffStartParent = event[2];
            return true;
        }, irqoffEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = preemptirqRE.exec(eventBase.details);
            if (!event) return false;
            const thread = this.importer.getOrCreatePseudoThread('irqoff cpu ' + cpuNumber);
            thread.irqoffEndCaller = event[1];
            thread.irqoffEndParent = event[2];
            if (thread.lastEntryTs !== undefined) {
                const duration = ts - thread.lastEntryTs;
                const slice = new tr.model.ThreadSlice('', thread.irqoffStartParent + ': ' + thread.irqoffStartCaller, ColorScheme.getColorIdForGeneralPurposeString(thread.irqoffEndCaller), thread.lastEntryTs, {}, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            thread.lastEntryTs = undefined;
            return true;
        }
    };
    Parser.register(IrqParser);
    return {IrqParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const LinuxPerfParser = tr.e.importer.linux_perf.Parser;

    function KernelFuncParser(importer) {
        LinuxPerfParser.call(this, importer);
        importer.registerEventHandler('graph_ent', KernelFuncParser.prototype.traceKernelFuncEnterEvent.bind(this));
        importer.registerEventHandler('graph_ret', KernelFuncParser.prototype.traceKernelFuncReturnEvent.bind(this));
        this.model_ = importer.model_;
        this.ppids_ = {};
    }

    const TestExports = {};
    const funcEnterRE = new RegExp('func=(.+)');
    TestExports.funcEnterRE = funcEnterRE;
    KernelFuncParser.prototype = {
        __proto__: LinuxPerfParser.prototype, traceKernelFuncEnterEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const eventData = funcEnterRE.exec(eventBase.details);
            if (!eventData) return false;
            if (eventBase.tgid === undefined) {
                return false;
            }
            const tgid = parseInt(eventBase.tgid);
            const name = eventData[1];
            const thread = this.model_.getOrCreateProcess(tgid).getOrCreateThread(pid);
            thread.name = eventBase.threadName;
            const slices = thread.kernelSliceGroup;
            if (!slices.isTimestampValidForBeginOrEnd(ts)) {
                this.model_.importWarning({type: 'parse_error', message: 'Timestamps are moving backward.'});
                return false;
            }
            const slice = slices.beginSlice(null, name, ts, {});
            return true;
        }, traceKernelFuncReturnEvent(eventName, cpuNumber, pid, ts, eventBase) {
            if (eventBase.tgid === undefined) {
                return false;
            }
            const tgid = parseInt(eventBase.tgid);
            const thread = this.model_.getOrCreateProcess(tgid).getOrCreateThread(pid);
            thread.name = eventBase.threadName;
            const slices = thread.kernelSliceGroup;
            if (!slices.isTimestampValidForBeginOrEnd(ts)) {
                this.model_.importWarning({type: 'parse_error', message: 'Timestamps are moving backward.'});
                return false;
            }
            if (slices.openSliceCount > 0) {
                slices.endSlice(ts);
            }
            return true;
        }
    };
    LinuxPerfParser.register(KernelFuncParser);
    return {KernelFuncParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function MaliParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('mali_dvfs_event', MaliParser.prototype.dvfsEventEvent.bind(this));
        importer.registerEventHandler('mali_dvfs_set_clock', MaliParser.prototype.dvfsSetClockEvent.bind(this));
        importer.registerEventHandler('mali_dvfs_set_voltage', MaliParser.prototype.dvfsSetVoltageEvent.bind(this));
        this.addJMCounter('mali_hwc_MESSAGES_SENT', 'Messages Sent');
        this.addJMCounter('mali_hwc_MESSAGES_RECEIVED', 'Messages Received');
        this.addJMCycles('mali_hwc_GPU_ACTIVE', 'GPU Active');
        this.addJMCycles('mali_hwc_IRQ_ACTIVE', 'IRQ Active');
        for (let i = 0; i < 7; i++) {
            const jobStr = 'JS' + i;
            const jobHWCStr = 'mali_hwc_' + jobStr;
            this.addJMCounter(jobHWCStr + '_JOBS', jobStr + ' Jobs');
            this.addJMCounter(jobHWCStr + '_TASKS', jobStr + ' Tasks');
            this.addJMCycles(jobHWCStr + '_ACTIVE', jobStr + ' Active');
            this.addJMCycles(jobHWCStr + '_WAIT_READ', jobStr + ' Wait Read');
            this.addJMCycles(jobHWCStr + '_WAIT_ISSUE', jobStr + ' Wait Issue');
            this.addJMCycles(jobHWCStr + '_WAIT_DEPEND', jobStr + ' Wait Depend');
            this.addJMCycles(jobHWCStr + '_WAIT_FINISH', jobStr + ' Wait Finish');
        }
        this.addTilerCounter('mali_hwc_TRIANGLES', 'Triangles');
        this.addTilerCounter('mali_hwc_QUADS', 'Quads');
        this.addTilerCounter('mali_hwc_POLYGONS', 'Polygons');
        this.addTilerCounter('mali_hwc_POINTS', 'Points');
        this.addTilerCounter('mali_hwc_LINES', 'Lines');
        this.addTilerCounter('mali_hwc_VCACHE_HIT', 'VCache Hit');
        this.addTilerCounter('mali_hwc_VCACHE_MISS', 'VCache Miss');
        this.addTilerCounter('mali_hwc_FRONT_FACING', 'Front Facing');
        this.addTilerCounter('mali_hwc_BACK_FACING', 'Back Facing');
        this.addTilerCounter('mali_hwc_PRIM_VISIBLE', 'Prim Visible');
        this.addTilerCounter('mali_hwc_PRIM_CULLED', 'Prim Culled');
        this.addTilerCounter('mali_hwc_PRIM_CLIPPED', 'Prim Clipped');
        this.addTilerCounter('mali_hwc_WRBUF_HIT', 'Wrbuf Hit');
        this.addTilerCounter('mali_hwc_WRBUF_MISS', 'Wrbuf Miss');
        this.addTilerCounter('mali_hwc_WRBUF_LINE', 'Wrbuf Line');
        this.addTilerCounter('mali_hwc_WRBUF_PARTIAL', 'Wrbuf Partial');
        this.addTilerCounter('mali_hwc_WRBUF_STALL', 'Wrbuf Stall');
        this.addTilerCycles('mali_hwc_ACTIVE', 'Tiler Active');
        this.addTilerCycles('mali_hwc_INDEX_WAIT', 'Index Wait');
        this.addTilerCycles('mali_hwc_INDEX_RANGE_WAIT', 'Index Range Wait');
        this.addTilerCycles('mali_hwc_VERTEX_WAIT', 'Vertex Wait');
        this.addTilerCycles('mali_hwc_PCACHE_WAIT', 'Pcache Wait');
        this.addTilerCycles('mali_hwc_WRBUF_WAIT', 'Wrbuf Wait');
        this.addTilerCycles('mali_hwc_BUS_READ', 'Bus Read');
        this.addTilerCycles('mali_hwc_BUS_WRITE', 'Bus Write');
        this.addTilerCycles('mali_hwc_TILER_UTLB_STALL', 'Tiler UTLB Stall');
        this.addTilerCycles('mali_hwc_TILER_UTLB_HIT', 'Tiler UTLB Hit');
        this.addFragCycles('mali_hwc_FRAG_ACTIVE', 'Active');
        this.addFragCounter('mali_hwc_FRAG_PRIMATIVES', 'Primitives');
        this.addFragCounter('mali_hwc_FRAG_PRIMATIVES_DROPPED', 'Primitives Dropped');
        this.addFragCycles('mali_hwc_FRAG_CYCLE_DESC', 'Descriptor Processing');
        this.addFragCycles('mali_hwc_FRAG_CYCLES_PLR', 'PLR Processing??');
        this.addFragCycles('mali_hwc_FRAG_CYCLES_VERT', 'Vertex Processing');
        this.addFragCycles('mali_hwc_FRAG_CYCLES_TRISETUP', 'Triangle Setup');
        this.addFragCycles('mali_hwc_FRAG_CYCLES_RAST', 'Rasterization???');
        this.addFragCounter('mali_hwc_FRAG_THREADS', 'Threads');
        this.addFragCounter('mali_hwc_FRAG_DUMMY_THREADS', 'Dummy Threads');
        this.addFragCounter('mali_hwc_FRAG_QUADS_RAST', 'Quads Rast');
        this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_TEST', 'Quads EZS Test');
        this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_KILLED', 'Quads EZS Killed');
        this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_TEST', 'Quads LZS Test');
        this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_KILLED', 'Quads LZS Killed');
        this.addFragCycles('mali_hwc_FRAG_CYCLE_NO_TILE', 'No Tiles');
        this.addFragCounter('mali_hwc_FRAG_NUM_TILES', 'Tiles');
        this.addFragCounter('mali_hwc_FRAG_TRANS_ELIM', 'Transactions Eliminated');
        this.addComputeCycles('mali_hwc_COMPUTE_ACTIVE', 'Active');
        this.addComputeCounter('mali_hwc_COMPUTE_TASKS', 'Tasks');
        this.addComputeCounter('mali_hwc_COMPUTE_THREADS', 'Threads Started');
        this.addComputeCycles('mali_hwc_COMPUTE_CYCLES_DESC', 'Waiting for Descriptors');
        this.addTripipeCycles('mali_hwc_TRIPIPE_ACTIVE', 'Active');
        this.addArithCounter('mali_hwc_ARITH_WORDS', 'Instructions (/Pipes)');
        this.addArithCycles('mali_hwc_ARITH_CYCLES_REG', 'Reg scheduling stalls (/Pipes)');
        this.addArithCycles('mali_hwc_ARITH_CYCLES_L0', 'L0 cache miss stalls (/Pipes)');
        this.addArithCounter('mali_hwc_ARITH_FRAG_DEPEND', 'Frag dep check failures (/Pipes)');
        this.addLSCounter('mali_hwc_LS_WORDS', 'Instruction Words Completed');
        this.addLSCounter('mali_hwc_LS_ISSUES', 'Full Pipeline Issues');
        this.addLSCounter('mali_hwc_LS_RESTARTS', 'Restarts (unpairable insts)');
        this.addLSCounter('mali_hwc_LS_REISSUES_MISS', 'Pipeline reissue (cache miss/uTLB)');
        this.addLSCounter('mali_hwc_LS_REISSUES_VD', 'Pipeline reissue (varying data)');
        this.addLSCounter('mali_hwc_LS_REISSUE_ATTRIB_MISS', 'Pipeline reissue (attribute cache miss)');
        this.addLSCounter('mali_hwc_LS_REISSUE_NO_WB', 'Writeback not used');
        this.addTexCounter('mali_hwc_TEX_WORDS', 'Words');
        this.addTexCounter('mali_hwc_TEX_BUBBLES', 'Bubbles');
        this.addTexCounter('mali_hwc_TEX_WORDS_L0', 'Words L0');
        this.addTexCounter('mali_hwc_TEX_WORDS_DESC', 'Words Desc');
        this.addTexCounter('mali_hwc_TEX_THREADS', 'Threads');
        this.addTexCounter('mali_hwc_TEX_RECIRC_FMISS', 'Recirc due to Full Miss');
        this.addTexCounter('mali_hwc_TEX_RECIRC_DESC', 'Recirc due to Desc Miss');
        this.addTexCounter('mali_hwc_TEX_RECIRC_MULTI', 'Recirc due to Multipass');
        this.addTexCounter('mali_hwc_TEX_RECIRC_PMISS', 'Recirc due to Partial Cache Miss');
        this.addTexCounter('mali_hwc_TEX_RECIRC_CONF', 'Recirc due to Cache Conflict');
        this.addLSCCounter('mali_hwc_LSC_READ_HITS', 'Read Hits');
        this.addLSCCounter('mali_hwc_LSC_READ_MISSES', 'Read Misses');
        this.addLSCCounter('mali_hwc_LSC_WRITE_HITS', 'Write Hits');
        this.addLSCCounter('mali_hwc_LSC_WRITE_MISSES', 'Write Misses');
        this.addLSCCounter('mali_hwc_LSC_ATOMIC_HITS', 'Atomic Hits');
        this.addLSCCounter('mali_hwc_LSC_ATOMIC_MISSES', 'Atomic Misses');
        this.addLSCCounter('mali_hwc_LSC_LINE_FETCHES', 'Line Fetches');
        this.addLSCCounter('mali_hwc_LSC_DIRTY_LINE', 'Dirty Lines');
        this.addLSCCounter('mali_hwc_LSC_SNOOPS', 'Snoops');
        this.addAXICounter('mali_hwc_AXI_TLB_STALL', 'Address channel stall');
        this.addAXICounter('mali_hwc_AXI_TLB_MISS', 'Cache Miss');
        this.addAXICounter('mali_hwc_AXI_TLB_TRANSACTION', 'Transactions');
        this.addAXICounter('mali_hwc_LS_TLB_MISS', 'LS Cache Miss');
        this.addAXICounter('mali_hwc_LS_TLB_HIT', 'LS Cache Hit');
        this.addAXICounter('mali_hwc_AXI_BEATS_READ', 'Read Beats');
        this.addAXICounter('mali_hwc_AXI_BEATS_WRITE', 'Write Beats');
        this.addMMUCounter('mali_hwc_MMU_TABLE_WALK', 'Page Table Walks');
        this.addMMUCounter('mali_hwc_MMU_REPLAY_MISS', 'Cache Miss from Replay Buffer');
        this.addMMUCounter('mali_hwc_MMU_REPLAY_FULL', 'Replay Buffer Full');
        this.addMMUCounter('mali_hwc_MMU_NEW_MISS', 'Cache Miss on New Request');
        this.addMMUCounter('mali_hwc_MMU_HIT', 'Cache Hit');
        this.addMMUCycles('mali_hwc_UTLB_STALL', 'UTLB Stalled');
        this.addMMUCycles('mali_hwc_UTLB_REPLAY_MISS', 'UTLB Replay Miss');
        this.addMMUCycles('mali_hwc_UTLB_REPLAY_FULL', 'UTLB Replay Full');
        this.addMMUCycles('mali_hwc_UTLB_NEW_MISS', 'UTLB New Miss');
        this.addMMUCycles('mali_hwc_UTLB_HIT', 'UTLB Hit');
        this.addL2Counter('mali_hwc_L2_READ_BEATS', 'Read Beats');
        this.addL2Counter('mali_hwc_L2_WRITE_BEATS', 'Write Beats');
        this.addL2Counter('mali_hwc_L2_ANY_LOOKUP', 'Any Lookup');
        this.addL2Counter('mali_hwc_L2_READ_LOOKUP', 'Read Lookup');
        this.addL2Counter('mali_hwc_L2_SREAD_LOOKUP', 'Shareable Read Lookup');
        this.addL2Counter('mali_hwc_L2_READ_REPLAY', 'Read Replayed');
        this.addL2Counter('mali_hwc_L2_READ_SNOOP', 'Read Snoop');
        this.addL2Counter('mali_hwc_L2_READ_HIT', 'Read Cache Hit');
        this.addL2Counter('mali_hwc_L2_CLEAN_MISS', 'CleanUnique Miss');
        this.addL2Counter('mali_hwc_L2_WRITE_LOOKUP', 'Write Lookup');
        this.addL2Counter('mali_hwc_L2_SWRITE_LOOKUP', 'Shareable Write Lookup');
        this.addL2Counter('mali_hwc_L2_WRITE_REPLAY', 'Write Replayed');
        this.addL2Counter('mali_hwc_L2_WRITE_SNOOP', 'Write Snoop');
        this.addL2Counter('mali_hwc_L2_WRITE_HIT', 'Write Cache Hit');
        this.addL2Counter('mali_hwc_L2_EXT_READ_FULL', 'ExtRD with BIU Full');
        this.addL2Counter('mali_hwc_L2_EXT_READ_HALF', 'ExtRD with BIU >1/2 Full');
        this.addL2Counter('mali_hwc_L2_EXT_WRITE_FULL', 'ExtWR with BIU Full');
        this.addL2Counter('mali_hwc_L2_EXT_WRITE_HALF', 'ExtWR with BIU >1/2 Full');
        this.addL2Counter('mali_hwc_L2_EXT_READ', 'External Read (ExtRD)');
        this.addL2Counter('mali_hwc_L2_EXT_READ_LINE', 'ExtRD (linefill)');
        this.addL2Counter('mali_hwc_L2_EXT_WRITE', 'External Write (ExtWR)');
        this.addL2Counter('mali_hwc_L2_EXT_WRITE_LINE', 'ExtWR (linefill)');
        this.addL2Counter('mali_hwc_L2_EXT_WRITE_SMALL', 'ExtWR (burst size <64B)');
        this.addL2Counter('mali_hwc_L2_EXT_BARRIER', 'External Barrier');
        this.addL2Counter('mali_hwc_L2_EXT_AR_STALL', 'Address Read stalls');
        this.addL2Counter('mali_hwc_L2_EXT_R_BUF_FULL', 'Response Buffer full stalls');
        this.addL2Counter('mali_hwc_L2_EXT_RD_BUF_FULL', 'Read Data Buffer full stalls');
        this.addL2Counter('mali_hwc_L2_EXT_R_RAW', 'RAW hazard stalls');
        this.addL2Counter('mali_hwc_L2_EXT_W_STALL', 'Write Data stalls');
        this.addL2Counter('mali_hwc_L2_EXT_W_BUF_FULL', 'Write Data Buffer full');
        this.addL2Counter('mali_hwc_L2_EXT_R_W_HAZARD', 'WAW or WAR hazard stalls');
        this.addL2Counter('mali_hwc_L2_TAG_HAZARD', 'Tag hazard replays');
        this.addL2Cycles('mali_hwc_L2_SNOOP_FULL', 'Snoop buffer full');
        this.addL2Cycles('mali_hwc_L2_REPLAY_FULL', 'Replay buffer full');
        importer.registerEventHandler('tracing_mark_write:mali_driver', MaliParser.prototype.maliDDKEvent.bind(this));
        importer.registerEventHandler('mali_job_systrace_event_start', MaliParser.prototype.maliJobEvent.bind(this));
        importer.registerEventHandler('mali_job_systrace_event_stop', MaliParser.prototype.maliJobEvent.bind(this));
        this.model_ = importer.model_;
        this.deferredJobs_ = {};
    }

    MaliParser.prototype = {
        __proto__: Parser.prototype, maliDDKOpenSlice(pid, tid, ts, func, blockinfo) {
            const thread = this.importer.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
            const funcArgs = /^([\w\d_]*)(?:\(\))?:?\s*(.*)$/.exec(func);
            thread.sliceGroup.beginSlice('gpu-driver', funcArgs[1], ts, {'args': funcArgs[2], blockinfo});
        }, maliDDKCloseSlice(pid, tid, ts, args, blockinfo) {
            const thread = this.importer.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
            if (!thread.sliceGroup.openSliceCount) {
                return;
            }
            thread.sliceGroup.endSlice(ts);
        }, autoDetectLineRE(line) {
            const lineREWithThread = /^\s*\(([\w\-]*)\)\s*(\w+):\s*([\w\\\/\.\-]*@\d*):?\s*(.*)$/;
            if (lineREWithThread.test(line)) {
                return lineREWithThread;
            }
            const lineRENoThread = /^s*()(\w+):\s*([\w\\\/.\-]*):?\s*(.*)$/;
            if (lineRENoThread.test(line)) {
                return lineRENoThread;
            }
            return null;
        }, lineRE: null, maliDDKEvent(eventName, cpuNumber, pid, ts, eventBase) {
            if (this.lineRE === null) {
                this.lineRE = this.autoDetectLineRE(eventBase.details);
                if (this.lineRE === null) return false;
            }
            const maliEvent = this.lineRE.exec(eventBase.details);
            const tid = (maliEvent[1] === '' ? 'mali' : maliEvent[1]);
            switch (maliEvent[2]) {
                case'cros_trace_print_enter':
                    this.maliDDKOpenSlice(pid, tid, ts, maliEvent[4], maliEvent[3]);
                    break;
                case'cros_trace_print_exit':
                    this.maliDDKCloseSlice(pid, tid, ts, [], maliEvent[3]);
            }
            return true;
        }, maliJobEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const jobEventRE = /^.*tracing_mark_write: (S|F)\|(\d+)\|(\w+)-job\|(\d+)\|(\d+)\|(\d+)\|(\d+)\|(\d+)\|([a-z0-9]+)\|(\d+)$/;
            const jobEvent = jobEventRE.exec(eventBase.details);
            if (!jobEvent) {
                this.model_.importWarning({
                    type: 'parse_error',
                    args: 'unexpected mali_job_systrace_event_* event syntax'
                });
                return;
            }
            const jobType = jobEvent[3];
            const jobId = jobEvent[4];
            const thread = this.importer.model_.getOrCreateProcess(0).getOrCreateThread('mali:' + jobType);
            switch (jobEvent[1]) {
                case'S': {
                    const args = {
                        ctx: jobEvent[9],
                        pid: parseInt(jobEvent[2], 10),
                        dep0: parseInt(jobEvent[5], 10),
                        dep1: parseInt(jobEvent[7], 10)
                    };
                    if (thread.sliceGroup.openSliceCount) {
                        if (!(jobType in this.deferredJobs_)) {
                            this.deferredJobs_[jobType] = [];
                        }
                        this.deferredJobs_[jobType].push({id: jobId, args});
                    } else {
                        thread.sliceGroup.beginSlice(null, jobId, ts, args);
                    }
                }
                    break;
                case'F': {
                    if (!thread.sliceGroup.openSliceCount) {
                        return;
                    }
                    if (thread.sliceGroup.mostRecentlyOpenedPartialSlice.title !== jobId) {
                        this.model_.importWarning({
                            type: 'invalid event nesting',
                            message: 'non-sequential jobs in same mali job slot'
                        });
                    }
                    thread.sliceGroup.endSlice(ts);
                    const deferredJobs = this.deferredJobs_[jobType];
                    if (deferredJobs && deferredJobs.length) {
                        const job = deferredJobs.shift();
                        thread.sliceGroup.beginSlice(null, job.id, ts, job.args);
                    }
                }
                    break;
            }
            return true;
        }, dvfsSample(counterName, seriesName, ts, s) {
            const value = parseInt(s);
            const counter = this.model_.kernel.getOrCreateCounter('DVFS', counterName);
            if (counter.numSeries === 0) {
                counter.addSeries(new tr.model.CounterSeries(seriesName, ColorScheme.getColorIdForGeneralPurposeString(counter.name)));
            }
            counter.series.forEach(function (series) {
                series.addCounterSample(ts, value);
            });
        }, dvfsEventEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /utilization=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            this.dvfsSample('DVFS Utilization', 'utilization', ts, event[1]);
            return true;
        }, dvfsSetClockEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /frequency=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            this.dvfsSample('DVFS Frequency', 'frequency', ts, event[1]);
            return true;
        }, dvfsSetVoltageEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /voltage=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            this.dvfsSample('DVFS Voltage', 'voltage', ts, event[1]);
            return true;
        }, hwcSample(cat, counterName, seriesName, ts, eventBase) {
            const event = /val=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const value = parseInt(event[1]);
            const counter = this.model_.kernel.getOrCreateCounter(cat, counterName);
            if (counter.numSeries === 0) {
                counter.addSeries(new tr.model.CounterSeries(seriesName, ColorScheme.getColorIdForGeneralPurposeString(counter.name)));
            }
            counter.series.forEach(function (series) {
                series.addCounterSample(ts, value);
            });
            return true;
        }, jmSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:jm', 'JM: ' + ctrName, seriesName, ts, eventBase);
        }, addJMCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.jmSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addJMCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.jmSample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, tilerSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:tiler', 'Tiler: ' + ctrName, seriesName, ts, eventBase);
        }, addTilerCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.tilerSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addTilerCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.tilerSample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, fragSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:fragment', 'Fragment: ' + ctrName, seriesName, ts, eventBase);
        }, addFragCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.fragSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addFragCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.fragSample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, computeSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:compute', 'Compute: ' + ctrName, seriesName, ts, eventBase);
        }, addComputeCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.computeSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addComputeCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.computeSample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addTripipeCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.hwcSample('mali:shader', 'Tripipe: ' + hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, arithSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:arith', 'Arith: ' + ctrName, seriesName, ts, eventBase);
        }, addArithCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.arithSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addArithCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.arithSample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addLSCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.hwcSample('mali:ls', 'LS: ' + hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, textureSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:texture', 'Texture: ' + ctrName, seriesName, ts, eventBase);
        }, addTexCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.textureSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addLSCCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.hwcSample('mali:lsc', 'LSC: ' + hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addAXICounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.hwcSample('mali:axi', 'AXI: ' + hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, mmuSample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:mmu', 'MMU: ' + ctrName, seriesName, ts, eventBase);
        }, addMMUCounter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.mmuSample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addMMUCycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.mmuSample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, l2Sample(ctrName, seriesName, ts, eventBase) {
            return this.hwcSample('mali:l2', 'L2: ' + ctrName, seriesName, ts, eventBase);
        }, addL2Counter(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.l2Sample(hwcTitle, 'count', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }, addL2Cycles(hwcEventName, hwcTitle) {
            function handler(eventName, cpuNumber, pid, ts, eventBase) {
                return this.l2Sample(hwcTitle, 'cycles', ts, eventBase);
            }

            this.importer.registerEventHandler(hwcEventName, handler.bind(this));
        }
    };
    Parser.register(MaliParser);
    return {MaliParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const Parser = tr.e.importer.linux_perf.Parser;

    function MemReclaimParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('mm_vmscan_kswapd_wake', MemReclaimParser.prototype.kswapdWake.bind(this));
        importer.registerEventHandler('mm_vmscan_kswapd_sleep', MemReclaimParser.prototype.kswapdSleep.bind(this));
        importer.registerEventHandler('mm_vmscan_direct_reclaim_begin', MemReclaimParser.prototype.reclaimBegin.bind(this));
        importer.registerEventHandler('mm_vmscan_direct_reclaim_end', MemReclaimParser.prototype.reclaimEnd.bind(this));
        importer.registerEventHandler('lowmemory_kill', MemReclaimParser.prototype.lowmemoryKill.bind(this));
    }

    const kswapdWakeRE = /nid=(\d+) order=(\d+)/;
    const kswapdSleepRE = /nid=(\d+)/;
    const reclaimBeginRE = /order=(\d+) may_writepage=\d+ gfp_flags=(.+)/;
    const reclaimEndRE = /nr_reclaimed=(\d+)/;
    const lowmemoryRE = /([^ ]+) \((\d+)\), page cache (\d+)kB \(limit (\d+)kB\), free (-?\d+)Kb/;
    MemReclaimParser.prototype = {
        __proto__: Parser.prototype, kswapdWake(eventName, cpuNumber, pid, ts, eventBase) {
            const event = kswapdWakeRE.exec(eventBase.details);
            if (!event) return false;
            const tgid = parseInt(eventBase.tgid);
            const nid = parseInt(event[1]);
            const order = parseInt(event[2]);
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, tgid, pid);
            if (kthread.openSliceTS) {
                if (order > kthread.order) {
                    kthread.order = order;
                }
            } else {
                kthread.openSliceTS = ts;
                kthread.order = order;
            }
            return true;
        }, kswapdSleep(eventName, cpuNumber, pid, ts, eventBase) {
            const tgid = parseInt(eventBase.tgid);
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, tgid, pid);
            if (kthread.openSliceTS) {
                kthread.thread.sliceGroup.pushCompleteSlice('memreclaim', eventBase.threadName, kthread.openSliceTS, ts - kthread.openSliceTS, 0, 0, {order: kthread.order});
            }
            kthread.openSliceTS = undefined;
            kthread.order = undefined;
            return true;
        }, reclaimBegin(eventName, cpuNumber, pid, ts, eventBase) {
            const event = reclaimBeginRE.exec(eventBase.details);
            if (!event) return false;
            const order = parseInt(event[1]);
            const gfp = event[2];
            const tgid = parseInt(eventBase.tgid);
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, tgid, pid);
            kthread.openSliceTS = ts;
            kthread.order = order;
            kthread.gfp = gfp;
            return true;
        }, reclaimEnd(eventName, cpuNumber, pid, ts, eventBase) {
            const event = reclaimEndRE.exec(eventBase.details);
            if (!event) return false;
            const nrReclaimed = parseInt(event[1]);
            const tgid = parseInt(eventBase.tgid);
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, tgid, pid);
            if (kthread.openSliceTS !== undefined) {
                kthread.thread.sliceGroup.pushCompleteSlice('memreclaim', 'direct reclaim', kthread.openSliceTS, ts - kthread.openSliceTS, 0, 0, {
                    order: kthread.order,
                    gfp: kthread.gfp,
                    nr_reclaimed: nrReclaimed
                });
            }
            kthread.openSliceTS = undefined;
            kthread.order = undefined;
            kthread.gfp = undefined;
            return true;
        }, lowmemoryKill(eventName, cpuNumber, pid, ts, eventBase) {
            const event = lowmemoryRE.exec(eventBase.details);
            if (!event) return false;
            const tgid = parseInt(eventBase.tgid);
            const killedName = event[1];
            const killedPid = parseInt(event[2]);
            const cache = parseInt(event[3]);
            const free = parseInt(event[5]);
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, tgid, pid);
            kthread.thread.sliceGroup.pushCompleteSlice('lowmemory', 'low memory kill', ts, 0, 0, 0, {
                killed_name: killedName,
                killed_pid: killedPid,
                cache,
                free
            });
            return true;
        }
    };
    Parser.register(MemReclaimParser);
    return {MemReclaimParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function PowerParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('power_start', PowerParser.prototype.powerStartEvent.bind(this));
        importer.registerEventHandler('power_frequency', PowerParser.prototype.powerFrequencyEvent.bind(this));
        importer.registerEventHandler('cpu_frequency', PowerParser.prototype.cpuFrequencyEvent.bind(this));
        importer.registerEventHandler('cpu_frequency_limits', PowerParser.prototype.cpuFrequencyLimitsEvent.bind(this));
        importer.registerEventHandler('cpu_idle', PowerParser.prototype.cpuIdleEvent.bind(this));
    }

    PowerParser.prototype = {
        __proto__: Parser.prototype, cpuStateSlice(ts, targetCpuNumber, eventType, cpuState) {
            const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
            if (eventType !== '1') {
                this.importer.model.importWarning({
                    type: 'parse_error',
                    message: 'Don\'t understand power_start events of ' + 'type ' + eventType
                });
                return;
            }
            const powerCounter = targetCpu.getOrCreateCounter('', 'C-State');
            if (powerCounter.numSeries === 0) {
                powerCounter.addSeries(new tr.model.CounterSeries('state', ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name + '.' + 'state')));
            }
            powerCounter.series.forEach(function (series) {
                series.addCounterSample(ts, cpuState);
            });
        }, cpuIdleSlice(ts, targetCpuNumber, cpuState) {
            const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
            const powerCounter = targetCpu.getOrCreateCounter('', 'C-State');
            if (powerCounter.numSeries === 0) {
                powerCounter.addSeries(new tr.model.CounterSeries('state', ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name)));
            }
            const val = (cpuState !== 4294967295 ? cpuState + 1 : 0);
            powerCounter.series.forEach(function (series) {
                series.addCounterSample(ts, val);
            });
        }, cpuFrequencySlice(ts, targetCpuNumber, powerState) {
            const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
            const powerCounter = targetCpu.getOrCreateCounter('', 'Clock Frequency');
            if (powerCounter.numSeries === 0) {
                powerCounter.addSeries(new tr.model.CounterSeries('state', ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name + '.' + 'state')));
            }
            powerCounter.series.forEach(function (series) {
                series.addCounterSample(ts, powerState);
            });
        }, cpuFrequencyLimitsSlice(ts, targetCpuNumber, minFreq, maxFreq) {
            const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
            const powerCounter = targetCpu.getOrCreateCounter('', 'Clock Frequency Limits');
            if (powerCounter.numSeries === 0) {
                powerCounter.addSeries(new tr.model.CounterSeries('Min Frequency', ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name + '.' + 'Min Frequency')));
                powerCounter.addSeries(new tr.model.CounterSeries('Max Frequency', ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name + '.' + 'Max Frequency')));
            }
            powerCounter.series.forEach(function (series) {
                if (series.name === 'Min Frequency') {
                    series.addCounterSample(ts, minFreq);
                }
                if (series.name === 'Max Frequency') {
                    series.addCounterSample(ts, maxFreq);
                }
            });
        }, powerStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /type=(\d+) state=(\d) cpu_id=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const targetCpuNumber = parseInt(event[3]);
            const cpuState = parseInt(event[2]);
            this.cpuStateSlice(ts, targetCpuNumber, event[1], cpuState);
            return true;
        }, powerFrequencyEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /type=(\d+) state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const targetCpuNumber = parseInt(event[3]);
            const powerState = parseInt(event[2]);
            this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
            return true;
        }, cpuFrequencyEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const targetCpuNumber = parseInt(event[2]);
            const powerState = parseInt(event[1]);
            this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
            return true;
        }, cpuFrequencyLimitsEvent(eventName, cpu, pid, ts, eventBase) {
            const event = /min=(\d+) max=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const targetCpuNumber = parseInt(event[3]);
            const minFreq = parseInt(event[1]);
            const maxFreq = parseInt(event[2]);
            this.cpuFrequencyLimitsSlice(ts, targetCpuNumber, minFreq, maxFreq);
            return true;
        }, cpuIdleEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            const targetCpuNumber = parseInt(event[2]);
            const cpuState = parseInt(event[1]);
            this.cpuIdleSlice(ts, targetCpuNumber, cpuState);
            return true;
        }
    };
    Parser.register(PowerParser);
    return {PowerParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function RegulatorParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('regulator_enable', RegulatorParser.prototype.regulatorEnableEvent.bind(this));
        importer.registerEventHandler('regulator_enable_delay', RegulatorParser.prototype.regulatorEnableDelayEvent.bind(this));
        importer.registerEventHandler('regulator_enable_complete', RegulatorParser.prototype.regulatorEnableCompleteEvent.bind(this));
        importer.registerEventHandler('regulator_disable', RegulatorParser.prototype.regulatorDisableEvent.bind(this));
        importer.registerEventHandler('regulator_disable_complete', RegulatorParser.prototype.regulatorDisableCompleteEvent.bind(this));
        importer.registerEventHandler('regulator_set_voltage', RegulatorParser.prototype.regulatorSetVoltageEvent.bind(this));
        importer.registerEventHandler('regulator_set_voltage_complete', RegulatorParser.prototype.regulatorSetVoltageCompleteEvent.bind(this));
        this.model_ = importer.model_;
    }

    const regulatorEnableRE = /name=(.+)/;
    const regulatorDisableRE = /name=(.+)/;
    const regulatorSetVoltageCompleteRE = /name=(\S+), val=(\d+)/;
    RegulatorParser.prototype = {
        __proto__: Parser.prototype, getCtr_(ctrName, valueName) {
            const ctr = this.model_.kernel.getOrCreateCounter(null, 'vreg ' + ctrName + ' ' + valueName);
            if (ctr.series[0] === undefined) {
                ctr.addSeries(new tr.model.CounterSeries(valueName, ColorScheme.getColorIdForGeneralPurposeString(ctrName + '.' + valueName)));
            }
            return ctr;
        }, regulatorEnableEvent(eventName, cpuNum, pid, ts, eventBase) {
            const event = regulatorEnableRE.exec(eventBase.details);
            if (!event) return false;
            const name = event[1];
            const ctr = this.getCtr_(name, 'enabled');
            ctr.series[0].addCounterSample(ts, 1);
            return true;
        }, regulatorEnableDelayEvent(eventName, cpuNum, pid, ts, eventBase) {
            return true;
        }, regulatorEnableCompleteEvent(eventName, cpuNum, pid, ts, eventBase) {
            return true;
        }, regulatorDisableEvent(eventName, cpuNum, pid, ts, eventBase) {
            const event = regulatorDisableRE.exec(eventBase.details);
            if (!event) return false;
            const name = event[1];
            const ctr = this.getCtr_(name, 'enabled');
            ctr.series[0].addCounterSample(ts, 0);
            return true;
        }, regulatorDisableCompleteEvent(eventName, cpuNum, pid, ts, eventBase) {
            return true;
        }, regulatorSetVoltageEvent(eventName, cpuNum, pid, ts, eventBase) {
            return true;
        }, regulatorSetVoltageCompleteEvent(eventName, cpuNum, pid, ts, eventBase) {
            const event = regulatorSetVoltageCompleteRE.exec(eventBase.details);
            if (!event) return false;
            const name = event[1];
            const voltage = parseInt(event[2]);
            const ctr = this.getCtr_(name, 'voltage');
            ctr.series[0].addCounterSample(ts, voltage);
            return true;
        }
    };
    Parser.register(RegulatorParser);
    return {RegulatorParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const Parser = tr.e.importer.linux_perf.Parser;

    function RssParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('rss_stat', RssParser.prototype.rssStat.bind(this));
    }

    const TestExports = {};
    const rssStatRE = new RegExp('member=(\\d+) size=(\\d+)');
    TestExports.rssStatRE = rssStatRE;
    const unknownThreadName = '<...>';
    RssParser.prototype = {
        __proto__: Parser.prototype, rssStat(eventName, cpuNumber, pid, ts, eventBase) {
            const event = rssStatRE.exec(eventBase.details);
            if (!event) return false;
            const member = parseInt(event[1]);
            const size = parseInt(event[2]);
            if (eventBase.tgid === undefined) {
                return false;
            }
            const tgid = parseInt(eventBase.tgid);
            const process = this.importer.model_.getOrCreateProcess(tgid);
            let subTitle = '';
            if (member === 0) {
                subTitle = ' (file pages)';
            } else if (member === 1) {
                subTitle = ' (anon)';
            }
            const rssCounter = process.getOrCreateCounter('RSS', 'RSS ' + member + subTitle);
            if (rssCounter.numSeries === 0) {
                rssCounter.addSeries(new tr.model.CounterSeries('RSS', tr.b.ColorScheme.getColorIdForGeneralPurposeString(rssCounter.name)));
            }
            rssCounter.series.forEach(function (series) {
                series.addCounterSample(ts, size);
            });
            return true;
        },
    };
    Parser.register(RssParser);
    return {RssParser, _RssParserTestExports: TestExports};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const Parser = tr.e.importer.linux_perf.Parser;

    function SchedParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('sched_switch', SchedParser.prototype.schedSwitchEvent.bind(this));
        importer.registerEventHandler('sched_wakeup', SchedParser.prototype.schedWakeupEvent.bind(this));
        importer.registerEventHandler('sched_blocked_reason', SchedParser.prototype.schedBlockedEvent.bind(this));
        importer.registerEventHandler('sched_cpu_hotplug', SchedParser.prototype.schedCpuHotplugEvent.bind(this));
    }

    const TestExports = {};
    const schedSwitchRE = new RegExp('prev_comm=(.+) prev_pid=(\\d+) prev_prio=(\\d+) ' + 'prev_state=(\\S\\+?|\\S\\|\\S) ==> ' + 'next_comm=(.+) next_pid=(\\d+) next_prio=(\\d+)');
    const schedBlockedRE = new RegExp('pid=(\\d+) iowait=(\\d) caller=(.+)');
    TestExports.schedSwitchRE = schedSwitchRE;
    const schedWakeupRE = /comm=(.+) pid=(\d+) prio=(\d+)(?: success=\d+)? target_cpu=(\d+)/;
    TestExports.schedWakeupRE = schedWakeupRE;
    const unknownThreadName = '<...>';
    SchedParser.prototype = {
        __proto__: Parser.prototype, schedSwitchEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = schedSwitchRE.exec(eventBase.details);
            if (!event) return false;
            const prevState = event[4];
            const nextComm = event[5];
            const nextPid = parseInt(event[6]);
            const nextPrio = parseInt(event[7]);
            if (eventBase.tgid !== undefined) {
                const tgid = parseInt(eventBase.tgid);
                const process = this.importer.model_.getOrCreateProcess(tgid);
                const storedThread = process.getThread(pid);
                if (!storedThread) {
                    const thread = process.getOrCreateThread(pid);
                    thread.name = eventBase.threadName;
                } else if (storedThread.name === unknownThreadName) {
                    storedThread.name = eventBase.threadName;
                }
            }
            const nextThread = this.importer.threadsByLinuxPid[nextPid];
            let nextName;
            if (nextThread) {
                nextName = nextThread.userFriendlyName;
            } else {
                nextName = nextComm;
            }
            const cpu = this.importer.getOrCreateCpu(cpuNumber);
            cpu.switchActiveThread(ts, {stateWhenDescheduled: prevState}, nextPid, nextName, {
                comm: nextComm,
                tid: nextPid,
                prio: nextPrio
            });
            return true;
        }, schedWakeupEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = schedWakeupRE.exec(eventBase.details);
            if (!event) return false;
            const fromPid = pid;
            const comm = event[1];
            pid = parseInt(event[2]);
            const prio = parseInt(event[3]);
            this.importer.markPidRunnable(ts, pid, comm, prio, fromPid);
            return true;
        }, schedCpuHotplugEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = /cpu (\d+) (.+) error=(\d+)/.exec(eventBase.details);
            if (!event) return false;
            cpuNumber = event[1];
            const state = event[2];
            const targetCpu = this.importer.getOrCreateCpu(cpuNumber);
            const powerCounter = targetCpu.getOrCreateCounter('', 'Cpu Hotplug');
            if (powerCounter.numSeries === 0) {
                powerCounter.addSeries(new tr.model.CounterSeries('State', tr.b.ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name + '.' + 'State')));
            }
            powerCounter.series.forEach(function (series) {
                if (series.name === 'State') {
                    series.addCounterSample(ts, state.localeCompare('offline') ? 0 : 1);
                }
            });
            return true;
        }, schedBlockedEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = schedBlockedRE.exec(eventBase.details);
            if (!event) return false;
            pid = parseInt(event[1]);
            const iowait = parseInt(event[2]);
            const caller = event[3];
            this.importer.addPidBlockedReason(ts, pid, iowait, caller);
            return true;
        }
    };
    Parser.register(SchedParser);
    return {SchedParser, _SchedParserTestExports: TestExports};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function SyncParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('sync_timeline', SyncParser.prototype.timelineEvent.bind(this));
        importer.registerEventHandler('sync_wait', SyncParser.prototype.syncWaitEvent.bind(this));
        importer.registerEventHandler('sync_pt', SyncParser.prototype.syncPtEvent.bind(this));
        this.model_ = importer.model_;
    }

    const syncTimelineRE = /name=(\S+) value=(\S*)/;
    const syncWaitRE = /(\S+) name=(\S+) state=(\d+)/;
    const syncPtRE = /name=(\S+) value=(\S*)/;
    SyncParser.prototype = {
        __proto__: Parser.prototype, timelineEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = syncTimelineRE.exec(eventBase.details);
            if (!event) return false;
            const thread = this.importer.getOrCreatePseudoThread(event[1]);
            if (thread.lastActiveTs !== undefined) {
                const duration = ts - thread.lastActiveTs;
                let value = thread.lastActiveValue;
                if (value === undefined) value = ' ';
                const slice = new tr.model.ThreadSlice('', value, ColorScheme.getColorIdForGeneralPurposeString(value), thread.lastActiveTs, {}, duration);
                thread.thread.sliceGroup.pushSlice(slice);
            }
            thread.lastActiveTs = ts;
            thread.lastActiveValue = event[2];
            return true;
        }, syncWaitEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = syncWaitRE.exec(eventBase.details);
            if (!event) return false;
            if (eventBase.tgid === undefined) {
                return false;
            }
            const tgid = parseInt(eventBase.tgid);
            const thread = this.model_.getOrCreateProcess(tgid).getOrCreateThread(pid);
            thread.name = eventBase.threadName;
            const slices = thread.kernelSliceGroup;
            if (!slices.isTimestampValidForBeginOrEnd(ts)) {
                this.model_.importWarning({type: 'parse_error', message: 'Timestamps are moving backward.'});
                return false;
            }
            const name = 'fence_wait("' + event[2] + '")';
            if (event[1] === 'begin') {
                const slice = slices.beginSlice(null, name, ts, {'Start state': event[3]});
            } else if (event[1] === 'end') {
                if (slices.openSliceCount > 0) {
                    slices.endSlice(ts);
                }
            } else {
                return false;
            }
            return true;
        }, syncPtEvent(eventName, cpuNumber, pid, ts, eventBase) {
            return !!syncPtRE.exec(eventBase.details);
        }
    };
    Parser.register(SyncParser);
    return {SyncParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const ColorScheme = tr.b.ColorScheme;
    const Parser = tr.e.importer.linux_perf.Parser;

    function WorkqueueParser(importer) {
        Parser.call(this, importer);
        importer.registerEventHandler('workqueue_execute_start', WorkqueueParser.prototype.executeStartEvent.bind(this));
        importer.registerEventHandler('workqueue_execute_end', WorkqueueParser.prototype.executeEndEvent.bind(this));
        importer.registerEventHandler('workqueue_queue_work', WorkqueueParser.prototype.executeQueueWork.bind(this));
        importer.registerEventHandler('workqueue_activate_work', WorkqueueParser.prototype.executeActivateWork.bind(this));
    }

    const workqueueExecuteStartRE = /work struct (.+): function (\S+)/;
    const workqueueExecuteEndRE = /work struct (.+)/;
    WorkqueueParser.prototype = {
        __proto__: Parser.prototype, executeStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = workqueueExecuteStartRE.exec(eventBase.details);
            if (!event) return false;
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, pid, pid);
            kthread.openSliceTS = ts;
            kthread.openSlice = event[2];
            return true;
        }, executeEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
            const event = workqueueExecuteEndRE.exec(eventBase.details);
            if (!event) return false;
            const kthread = this.importer.getOrCreateKernelThread(eventBase.threadName, pid, pid);
            if (kthread.openSlice) {
                const slice = new tr.model.ThreadSlice('', kthread.openSlice, ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice), kthread.openSliceTS, {}, ts - kthread.openSliceTS);
                kthread.thread.sliceGroup.pushSlice(slice);
            }
            kthread.openSlice = undefined;
            return true;
        }, executeQueueWork(eventName, cpuNumber, pid, ts, eventBase) {
            return true;
        }, executeActivateWork(eventName, cpuNumber, pid, ts, eventBase) {
            return true;
        }
    };
    Parser.register(WorkqueueParser);
    return {WorkqueueParser,};
});
'use strict';
tr.exportTo('tr.e.importer.linux_perf', function () {
    const MONOTONIC_TO_FTRACE_GLOBAL_SYNC_ID = 'linux_clock_monotonic_to_ftrace_global';
    const IMPORT_PRIORITY = 2;

    function FTraceImporter(model, events) {
        this.importPriority = IMPORT_PRIORITY;
        this.model_ = model;
        this.events_ = events;
        this.wakeups_ = [];
        this.blockedReasons_ = [];
        this.kernelThreadStates_ = {};
        this.buildMapFromLinuxPidsToThreads_();
        this.lines_ = [];
        this.pseudoThreadCounter = 1;
        this.parsers_ = [];
        this.eventHandlers_ = {};
        this.haveClockSyncedMonotonicToGlobal_ = false;
        this.clockDomainId_ = tr.model.ClockDomainId.LINUX_FTRACE_GLOBAL;
    }

    const TestExports = {};
    const lineREWithTGID = new RegExp('^\\s*(.+)-(\\d+)\\s+\\(\\s*(\\d+|-+)\\)\\s\\[(\\d+)\\]' + '\\s+[dX.][Nnp.][Hhs.][0-9a-f.]' + '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
    const lineParserWithTGID = function (line) {
        const groups = lineREWithTGID.exec(line);
        if (!groups) return groups;
        let tgid = groups[3];
        if (tgid[0] === '-') tgid = undefined;
        return {
            threadName: groups[1],
            pid: groups[2],
            tgid,
            cpuNumber: groups[4],
            timestamp: groups[5],
            eventName: groups[6],
            details: groups[7]
        };
    };
    TestExports.lineParserWithTGID = lineParserWithTGID;
    const lineREWithIRQInfo = new RegExp('^\\s*(.+)-(\\d+)\\s+\\[(\\d+)\\]' + '\\s+[dX.][Nnp.][Hhs.][0-9a-f.]' + '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
    const lineParserWithIRQInfo = function (line) {
        const groups = lineREWithIRQInfo.exec(line);
        if (!groups) return groups;
        return {
            threadName: groups[1],
            pid: groups[2],
            cpuNumber: groups[3],
            timestamp: groups[4],
            eventName: groups[5],
            details: groups[6]
        };
    };
    TestExports.lineParserWithIRQInfo = lineParserWithIRQInfo;
    const lineREWithLegacyFmt = /^\s*(.+)-(\d+)\s+\[(\d+)\]\s*(\d+\.\d+):\s+(\S+):\s(.*)$/;
    const lineParserWithLegacyFmt = function (line) {
        const groups = lineREWithLegacyFmt.exec(line);
        if (!groups) {
            return groups;
        }
        return {
            threadName: groups[1],
            pid: groups[2],
            cpuNumber: groups[3],
            timestamp: groups[4],
            eventName: groups[5],
            details: groups[6]
        };
    };
    TestExports.lineParserWithLegacyFmt = lineParserWithLegacyFmt;
    const traceEventClockSyncRE = /trace_event_clock_sync: parent_ts=(\d+\.?\d*)/;
    TestExports.traceEventClockSyncRE = traceEventClockSyncRE;
    const realTimeClockSyncRE = /trace_event_clock_sync: realtime_ts=(\d+)/;
    const genericClockSyncRE = /trace_event_clock_sync: name=([\w\-]+)/;
    const pseudoKernelPID = 0;

    function autoDetectLineParser(line) {
        if (line[0] === '{') return false;
        if (lineREWithTGID.test(line)) return lineParserWithTGID;
        if (lineREWithIRQInfo.test(line)) return lineParserWithIRQInfo;
        if (lineREWithLegacyFmt.test(line)) return lineParserWithLegacyFmt;
        return undefined;
    }

    TestExports.autoDetectLineParser = autoDetectLineParser;
    FTraceImporter.canImport = function (events) {
        if (events instanceof tr.b.TraceStream) events = events.header;
        if (!(typeof (events) === 'string' || events instanceof String)) {
            return false;
        }
        if (FTraceImporter._extractEventsFromSystraceHTML(events, false).ok) {
            return true;
        }
        if (FTraceImporter._extractEventsFromSystraceMultiHTML(events, false).ok) {
            return true;
        }
        if (/^# tracer:/.test(events)) return true;
        const lineBreakIndex = events.indexOf('\n');
        if (lineBreakIndex > -1) events = events.substring(0, lineBreakIndex);
        if (autoDetectLineParser(events)) return true;
        return false;
    };
    FTraceImporter._extractEventsFromSystraceHTML = function (incomingEvents, produceResult) {
        const failure = {ok: false};
        if (produceResult === undefined) produceResult = true;
        const header = incomingEvents instanceof tr.b.TraceStream ? incomingEvents.header : incomingEvents;
        if (!/^<!DOCTYPE html>/.test(header)) return failure;
        const r = new tr.importer.SimpleLineReader(incomingEvents);
        if (!r.advanceToLineMatching(/^  <script>$/)) return failure;
        if (!r.advanceToLineMatching(/^  var linuxPerfData = "\\$/)) return failure;
        const eventsBeginAtLine = r.curLineNumber + 1;
        r.beginSavingLines();
        if (!r.advanceToLineMatching(/^  <\/script>$/)) return failure;
        let rawEvents = r.endSavingLinesAndGetResult();
        rawEvents = rawEvents.slice(1, rawEvents.length - 1);
        if (!r.advanceToLineMatching(/^<\/body>$/)) return failure;
        if (!r.advanceToLineMatching(/^<\/html>$/)) return failure;

        function endsWith(str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }

        function stripSuffix(str, suffix) {
            if (!endsWith(str, suffix)) return str;
            return str.substring(str, str.length - suffix.length);
        }

        let events = [];
        if (produceResult) {
            for (let i = 0; i < rawEvents.length; i++) {
                let event = rawEvents[i];
                event = stripSuffix(event, '\\n\\');
                events.push(event);
            }
        } else {
            events = [rawEvents[rawEvents.length - 1]];
        }
        const oldLastEvent = events[events.length - 1];
        const newLastEvent = stripSuffix(oldLastEvent, '\\n";');
        if (newLastEvent === oldLastEvent) return failure;
        events[events.length - 1] = newLastEvent;
        return {ok: true, lines: produceResult ? events : undefined, eventsBeginAtLine};
    };
    FTraceImporter._extractEventsFromSystraceMultiHTML = function (incomingEvents, produceResult) {
        const failure = {ok: false};
        if (produceResult === undefined) produceResult = true;
        const header = incomingEvents instanceof tr.b.TraceStream ? incomingEvents.header : incomingEvents;
        if (!(new RegExp('^<!DOCTYPE HTML>', 'i').test(header))) return failure;
        const r = new tr.importer.SimpleLineReader(incomingEvents);
        let events = [];
        let eventsBeginAtLine;
        while (!/^# tracer:/.test(events)) {
            if (!r.advanceToLineMatching(/^  <script class="trace-data" type="application\/text">$/)) {
                return failure;
            }
            eventsBeginAtLine = r.curLineNumber + 1;
            r.beginSavingLines();
            if (!r.advanceToLineMatching(/^  <\/script>$/)) return failure;
            events = r.endSavingLinesAndGetResult();
            events = events.slice(1, events.length - 1);
        }
        if (!r.advanceToLineMatching(/^<\/body>$/)) return failure;
        if (!r.advanceToLineMatching(/^<\/html>$/)) return failure;
        return {ok: true, lines: produceResult ? events : undefined, eventsBeginAtLine,};
    };
    FTraceImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'FTraceImporter';
        }, get model() {
            return this.model_;
        }, importClockSyncMarkers() {
            this.lazyInit_();
            this.forEachLine_(function (text, eventBase, cpuNumber, pid, ts) {
                const eventName = eventBase.eventName;
                if (eventName !== 'tracing_mark_write' && eventName !== '0') return;
                if (traceEventClockSyncRE.exec(eventBase.details) || genericClockSyncRE.exec(eventBase.details)) {
                    this.traceClockSyncEvent_(eventName, cpuNumber, pid, ts, eventBase);
                } else if (realTimeClockSyncRE.exec(eventBase.details)) {
                    const match = realTimeClockSyncRE.exec(eventBase.details);
                    this.model_.realtime_to_monotonic_offset_ms = ts - match[1];
                    this.model_.realtime_ts = parseFloat(match[1]);
                }
            }.bind(this));
        }, importEvents() {
            if (this.lines_.length === 0) return;
            const modelTimeTransformer = this.model_.clockSyncManager.getModelTimeTransformer(this.clockDomainId_);
            this.importCpuData_(modelTimeTransformer);
            this.buildMapFromLinuxPidsToThreads_();
            this.buildPerThreadCpuSlicesFromCpuState_();
        }, registerEventHandler(eventName, handler) {
            this.eventHandlers_[eventName] = handler;
        }, getOrCreateCpu(cpuNumber) {
            return this.model_.kernel.getOrCreateCpu(cpuNumber);
        }, getOrCreateKernelThread(kernelThreadName, pid, tid) {
            if (!this.kernelThreadStates_[kernelThreadName]) {
                const thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
                thread.name = kernelThreadName;
                this.kernelThreadStates_[kernelThreadName] = {
                    pid,
                    thread,
                    openSlice: undefined,
                    openSliceTS: undefined
                };
                this.threadsByLinuxPid[tid] = thread;
            }
            return this.kernelThreadStates_[kernelThreadName];
        }, getOrCreateBinderKernelThread(kernelThreadName, pid, tid) {
            const key = kernelThreadName + pid + tid;
            if (!this.kernelThreadStates_[key]) {
                const thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
                thread.name = kernelThreadName;
                this.kernelThreadStates_[key] = {pid, thread, openSlice: undefined, openSliceTS: undefined};
                this.threadsByLinuxPid[tid] = thread;
            }
            return this.kernelThreadStates_[key];
        }, getOrCreatePseudoThread(threadName) {
            let thread = this.kernelThreadStates_[threadName];
            if (!thread) {
                thread = this.getOrCreateKernelThread(threadName, pseudoKernelPID, this.pseudoThreadCounter);
                this.pseudoThreadCounter++;
            }
            return thread;
        }, markPidRunnable(ts, pid, comm, prio, fromPid) {
            this.wakeups_.push({ts, tid: pid, fromTid: fromPid});
        }, addPidBlockedReason(ts, pid, iowait, caller) {
            this.blockedReasons_.push({ts, tid: pid, iowait, caller});
        }, buildMapFromLinuxPidsToThreads_() {
            this.threadsByLinuxPid = {};
            this.model_.getAllThreads().forEach(function (thread) {
                this.threadsByLinuxPid[thread.tid] = thread;
            }.bind(this));
        }, buildPerThreadCpuSlicesFromCpuState_() {
            const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
            for (const cpuNumber in this.model_.kernel.cpus) {
                const cpu = this.model_.kernel.cpus[cpuNumber];
                for (let i = 0; i < cpu.slices.length; i++) {
                    const cpuSlice = cpu.slices[i];
                    const thread = this.threadsByLinuxPid[cpuSlice.args.tid];
                    if (!thread) continue;
                    cpuSlice.threadThatWasRunning = thread;
                    if (!thread.tempCpuSlices) {
                        thread.tempCpuSlices = [];
                    }
                    thread.tempCpuSlices.push(cpuSlice);
                }
            }
            for (const i in this.wakeups_) {
                const wakeup = this.wakeups_[i];
                const thread = this.threadsByLinuxPid[wakeup.tid];
                if (!thread) continue;
                thread.tempWakeups = thread.tempWakeups || [];
                thread.tempWakeups.push(wakeup);
            }
            for (const i in this.blockedReasons_) {
                const reason = this.blockedReasons_[i];
                const thread = this.threadsByLinuxPid[reason.tid];
                if (!thread) continue;
                thread.tempBlockedReasons = thread.tempBlockedReasons || [];
                thread.tempBlockedReasons.push(reason);
            }
            this.model_.getAllThreads().forEach(function (thread) {
                if (thread.tempCpuSlices === undefined) return;
                const origSlices = thread.tempCpuSlices;
                delete thread.tempCpuSlices;
                origSlices.sort(function (x, y) {
                    return x.start - y.start;
                });
                const wakeups = thread.tempWakeups || [];
                delete thread.tempWakeups;
                wakeups.sort(function (x, y) {
                    return x.ts - y.ts;
                });
                const reasons = thread.tempBlockedReasons || [];
                delete thread.tempBlockedReasons;
                reasons.sort(function (x, y) {
                    return x.ts - y.ts;
                });
                const slices = [];
                if (origSlices.length) {
                    const slice = origSlices[0];
                    if (wakeups.length && wakeups[0].ts < slice.start) {
                        const wakeup = wakeups.shift();
                        const wakeupDuration = slice.start - wakeup.ts;
                        const args = {'wakeup from tid': wakeup.fromTid};
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.RUNNABLE, '', wakeup.ts, args, wakeupDuration));
                    }
                    const runningSlice = new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.RUNNING, '', slice.start, {}, slice.duration);
                    runningSlice.cpuOnWhichThreadWasRunning = slice.cpu;
                    slices.push(runningSlice);
                }
                for (let i = 1; i < origSlices.length; i++) {
                    let wakeup = undefined;
                    const prevSlice = origSlices[i - 1];
                    const nextSlice = origSlices[i];
                    let midDuration = nextSlice.start - prevSlice.end;
                    while (wakeups.length && wakeups[0].ts < nextSlice.start) {
                        const w = wakeups.shift();
                        if (wakeup === undefined && w.ts > prevSlice.end) {
                            wakeup = w;
                        }
                    }
                    let blockedReason = undefined;
                    while (reasons.length && reasons[0].ts < prevSlice.end) {
                        const r = reasons.shift();
                    }
                    if (wakeup !== undefined && reasons.length && reasons[0].ts < wakeup.ts) {
                        blockedReason = reasons.shift();
                    }
                    const pushSleep = function (state) {
                        if (wakeup !== undefined) {
                            midDuration = wakeup.ts - prevSlice.end;
                        }
                        if (blockedReason !== undefined) {
                            const args = {'kernel callsite when blocked:': blockedReason.caller};
                            if (blockedReason.iowait) {
                                switch (state) {
                                    case SCHEDULING_STATE.UNINTR_SLEEP:
                                        state = SCHEDULING_STATE.UNINTR_SLEEP_IO;
                                        break;
                                    case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:
                                        state = SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO;
                                        break;
                                    case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:
                                        state = SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO;
                                        break;
                                    default:
                                }
                            }
                            slices.push(new tr.model.ThreadTimeSlice(thread, state, '', prevSlice.end, args, midDuration));
                        } else {
                            slices.push(new tr.model.ThreadTimeSlice(thread, state, '', prevSlice.end, {}, midDuration));
                        }
                        if (wakeup !== undefined) {
                            const wakeupDuration = nextSlice.start - wakeup.ts;
                            const args = {'wakeup from tid': wakeup.fromTid};
                            slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.RUNNABLE, '', wakeup.ts, args, wakeupDuration));
                            wakeup = undefined;
                        }
                    };
                    if (prevSlice.args.stateWhenDescheduled === 'S') {
                        pushSleep(SCHEDULING_STATE.SLEEPING);
                    } else if (prevSlice.args.stateWhenDescheduled === 'R' || prevSlice.args.stateWhenDescheduled === 'R+') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.RUNNABLE, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'D') {
                        pushSleep(SCHEDULING_STATE.UNINTR_SLEEP);
                    } else if (prevSlice.args.stateWhenDescheduled === 'T') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.STOPPED, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 't') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.DEBUG, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'Z') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.ZOMBIE, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'X') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.EXIT_DEAD, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'x') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.TASK_DEAD, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'K') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.WAKE_KILL, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'W') {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.WAKING, '', prevSlice.end, {}, midDuration));
                    } else if (prevSlice.args.stateWhenDescheduled === 'D|K') {
                        pushSleep(SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL);
                    } else if (prevSlice.args.stateWhenDescheduled === 'D|W') {
                        pushSleep(SCHEDULING_STATE.UNINTR_SLEEP_WAKING);
                    } else {
                        slices.push(new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.UNKNOWN, '', prevSlice.end, {}, midDuration));
                        this.model_.importWarning({
                            type: 'parse_error', message: 'Unrecognized sleep state: ' +
                                prevSlice.args.stateWhenDescheduled
                        });
                    }
                    const runningSlice = new tr.model.ThreadTimeSlice(thread, SCHEDULING_STATE.RUNNING, '', nextSlice.start, {}, nextSlice.duration);
                    runningSlice.cpuOnWhichThreadWasRunning = prevSlice.cpu;
                    slices.push(runningSlice);
                }
                thread.timeSlices = slices;
            }, this);
        }, createParsers_() {
            const allTypeInfos = tr.e.importer.linux_perf.Parser.getAllRegisteredTypeInfos();
            const parsers = allTypeInfos.map(function (typeInfo) {
                return new typeInfo.constructor(this);
            }, this);
            return parsers;
        }, registerDefaultHandlers_() {
            this.registerEventHandler('tracing_mark_write', FTraceImporter.prototype.traceMarkingWriteEvent_.bind(this));
            this.registerEventHandler('0', FTraceImporter.prototype.traceMarkingWriteEvent_.bind(this));
            this.registerEventHandler('tracing_mark_write:trace_event_clock_sync', function () {
                return true;
            });
            this.registerEventHandler('0:trace_event_clock_sync', function () {
                return true;
            });
        }, traceClockSyncEvent_(eventName, cpuNumber, pid, ts, eventBase) {
            let event = /name=(\w+?)\s(.+)/.exec(eventBase.details);
            if (event) {
                const name = event[1];
                const pieces = event[2].split(' ');
                const args = {perfTs: ts};
                for (let i = 0; i < pieces.length; i++) {
                    const parts = pieces[i].split('=');
                    if (parts.length !== 2) {
                        throw new Error('omgbbq');
                    }
                    args[parts[0]] = parts[1];
                }
                this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_, name, ts);
                return true;
            }
            event = /name=([\w\-]+)/.exec(eventBase.details);
            if (event) {
                this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_, event[1], ts);
                return true;
            }
            event = /parent_ts=(\d+\.?\d*)/.exec(eventBase.details);
            if (!event) return false;
            let monotonicTs = event[1] * 1000;
            if (monotonicTs === 0) monotonicTs = ts;
            if (this.haveClockSyncedMonotonicToGlobal_) {
                return true;
            }
            this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_, MONOTONIC_TO_FTRACE_GLOBAL_SYNC_ID, ts);
            this.model_.clockSyncManager.addClockSyncMarker(tr.model.ClockDomainId.LINUX_CLOCK_MONOTONIC, MONOTONIC_TO_FTRACE_GLOBAL_SYNC_ID, monotonicTs);
            this.haveClockSyncedMonotonicToGlobal_ = true;
            return true;
        }, traceMarkingWriteEvent_(eventName, cpuNumber, pid, ts, eventBase, threadName) {
            eventBase.details = eventBase.details.replace(/\\n.*$/, '');
            const event = /^\s*(\w+):\s*(.*)$/.exec(eventBase.details);
            if (!event) {
                const tag = eventBase.details.substring(0, 2);
                if (tag === 'B|' || tag === 'E' || tag === 'E|' || tag === 'X|' || tag === 'C|' || tag === 'S|' || tag === 'F|') {
                    eventBase.subEventName = 'android';
                } else {
                    return false;
                }
            } else {
                eventBase.subEventName = event[1];
                eventBase.details = event[2];
            }
            const writeEventName = eventName + ':' + eventBase.subEventName;
            const handler = this.eventHandlers_[writeEventName];
            if (!handler) {
                this.model_.importWarning({
                    type: 'parse_error',
                    message: 'Unknown trace_marking_write event ' + writeEventName
                });
                return true;
            }
            return handler(writeEventName, cpuNumber, pid, ts, eventBase, threadName);
        }, importCpuData_(modelTimeTransformer) {
            this.forEachLine_(function (text, eventBase, cpuNumber, pid, ts) {
                const eventName = eventBase.eventName;
                const handler = this.eventHandlers_[eventName];
                if (!handler) {
                    this.model_.importWarning({
                        type: 'parse_error',
                        message: 'Unknown event ' + eventName + ' (' + text + ')'
                    });
                    return;
                }
                ts = modelTimeTransformer(ts);
                if (!handler(eventName, cpuNumber, pid, ts, eventBase)) {
                    this.model_.importWarning({
                        type: 'parse_error',
                        message: 'Malformed ' + eventName + ' event (' + text + ')'
                    });
                }
            }.bind(this));
        }, parseLines_() {
            let extractResult = FTraceImporter._extractEventsFromSystraceHTML(this.events_, true);
            if (!extractResult.ok) {
                extractResult = FTraceImporter._extractEventsFromSystraceMultiHTML(this.events_, true);
            }
            let lineParser = undefined;
            if (extractResult.ok) {
                for (const line of extractResult.lines) {
                    lineParser = this.parseLine_(line, lineParser);
                }
            } else {
                const r = new tr.importer.SimpleLineReader(this.events_);
                for (const line of r) {
                    lineParser = this.parseLine_(line, lineParser);
                }
            }
        }, parseLine_(line, lineParser) {
            line = line.trim();
            if (line.length === 0) return lineParser;
            if (/^#/.test(line)) {
                const clockType = /^# clock_type=([A-Z_]+)$/.exec(line);
                if (clockType) {
                    this.clockDomainId_ = clockType[1];
                }
                return lineParser;
            }
            if (!lineParser) {
                lineParser = autoDetectLineParser(line);
                if (!lineParser) {
                    this.model_.importWarning({type: 'parse_error', message: 'Cannot parse line: ' + line});
                    return lineParser;
                }
            }
            const eventBase = lineParser(line);
            if (!eventBase) {
                this.model_.importWarning({type: 'parse_error', message: 'Unrecognized line: ' + line});
                return lineParser;
            }
            this.lines_.push([line, eventBase, parseInt(eventBase.cpuNumber), parseInt(eventBase.pid), parseFloat(eventBase.timestamp) * 1000]);
            return lineParser;
        }, forEachLine_(handler) {
            for (let i = 0; i < this.lines_.length; ++i) {
                const line = this.lines_[i];
                handler.apply(this, line);
            }
        }, lazyInit_() {
            this.parsers_ = this.createParsers_();
            this.registerDefaultHandlers_();
            this.parseLines_();
        }
    };
    tr.importer.Importer.register(FTraceImporter);
    return {FTraceImporter, _FTraceImporterTestExports: TestExports, IMPORT_PRIORITY,};
});
'use strict';
tr.exportTo('tr.e.importer.android.atrace_process_dump', function () {
    const IMPORT_PRIORITY = tr.e.importer.linux_perf.IMPORT_PRIORITY + 1;
    const HEADER = 'ATRACE_PROCESS_DUMP';
    const PROTECTION_FLAG_LETTERS = {
        '-': 0,
        'r': tr.model.VMRegion.PROTECTION_FLAG_READ,
        'w': tr.model.VMRegion.PROTECTION_FLAG_WRITE,
        'x': tr.model.VMRegion.PROTECTION_FLAG_EXECUTE,
        's': tr.model.VMRegion.PROTECTION_FLAG_MAYSHARE,
    };

    class AtraceProcessDumpImporter extends tr.importer.Importer {
        constructor(model, data) {
            super(model, data);
            this.importPriority = IMPORT_PRIORITY;
            this.model_ = model;
            this.raw_data_ = data;
            this.clock_sync_markers_ = {};
            this.snapshots_ = [];
            this.processes_ = {};
        }

        static canImport(events) {
            if (!(typeof (events) === 'string' || events instanceof String)) {
                return false;
            }
            return events.startsWith(HEADER);
        }

        get importerName() {
            return 'AtraceProcessDumpImporter';
        }

        get model() {
            return this.model_;
        }

        lazyParseData() {
            if (this.raw_data_ === undefined) {
                return;
            }
            const dump = JSON.parse(this.raw_data_.slice(HEADER.length + 1));
            this.clock_sync_markers_ = dump.clock_sync_markers;
            this.snapshots_ = dump.dump.snapshots;
            this.processes_ = dump.dump.processes;
            this.raw_data_ = undefined;
        }

        importClockSyncMarkers() {
            this.lazyParseData();
            for (const syncId in this.clock_sync_markers_) {
                const ts = parseInt(this.clock_sync_markers_[syncId]);
                this.model_.clockSyncManager.addClockSyncMarker(tr.model.ClockDomainId.LINUX_CLOCK_MONOTONIC, syncId, ts);
            }
        }

        setProcessMemoryDumpTotals_(pmd, processInfo) {
            pmd.totals = {
                'residentBytes': processInfo.rss * 1024,
                'platformSpecific': {'vm': processInfo.vm * 1024}
            };
            const totals = pmd.totals.platformSpecific;

            function importGpuMetric(name) {
                if (processInfo[name] !== undefined && processInfo[name] > 0) {
                    totals[name] = processInfo[name] * 1024;
                    totals[name + '_pss'] = processInfo[name + '_pss'] * 1024;
                }
            }

            importGpuMetric('gpu_egl');
            importGpuMetric('gpu_gl');
            importGpuMetric('gpu_etc');
            if (processInfo.pss !== undefined) {
                totals.pss = processInfo.pss * 1024;
                totals.swp = processInfo.swp * 1024;
                totals.pc = processInfo.pc * 1024;
                totals.pd = processInfo.pd * 1024;
                totals.sc = processInfo.sc * 1024;
                totals.sd = processInfo.sd * 1024;
            }
        }

        setProcessMemoryDumpVmRegions_(pmd, processInfo) {
            if (processInfo.mmaps === undefined) {
                return;
            }
            const vmRegions = [];
            for (const memoryMap of processInfo.mmaps) {
                const addr = memoryMap.vm.split('-').map(x => parseInt(x, 16));
                let flags = 0;
                for (const letter of memoryMap.flags) {
                    flags |= PROTECTION_FLAG_LETTERS[letter];
                }
                const totals = {
                    'proportionalResident': memoryMap.pss * 1024,
                    'privateCleanResident': memoryMap.pc * 1024,
                    'privateDirtyResident': memoryMap.pd * 1024,
                    'sharedCleanResident': memoryMap.sc * 1024,
                    'sharedDirtyResident': memoryMap.sd * 1024,
                    'swapped': memoryMap.swp * 1024,
                };
                vmRegions.push(new tr.model.VMRegion(addr[0], addr[1] - addr[0], flags, memoryMap.file, totals));
            }
            pmd.vmRegions = tr.model.VMRegionClassificationNode.fromRegions(vmRegions);
        }

        importEvents() {
            this.lazyParseData();
            for (const [pid, process] of Object.entries(this.processes_)) {
                const modelProcess = this.model_.getProcess(pid);
                if (modelProcess === undefined) {
                    continue;
                }
                modelProcess.name = process.name;
                const threads = process.threads;
                if (threads === undefined) {
                    continue;
                }
                for (const [tid, thread] of Object.entries(threads)) {
                    const modelThread = modelProcess.threads[tid];
                    if (modelThread === undefined) {
                        continue;
                    }
                    modelThread.name = thread.name;
                }
            }
            const memCounter = this.model_.kernel.getOrCreateCounter('global', 'SystemMemory');
            const memUsedSeries = new tr.model.CounterSeries('Used (KB)', 0);
            const memSwappedSeries = new tr.model.CounterSeries('Swapped (KB)', 0);
            memCounter.addSeries(memUsedSeries);
            memCounter.addSeries(memSwappedSeries);
            for (const snapshot of this.snapshots_) {
                const ts = parseInt(snapshot.ts);
                const memoryDump = snapshot.memdump;
                if (memoryDump === undefined) {
                    const memInfo = snapshot.meminfo;
                    if (memInfo === undefined) {
                        continue;
                    }
                    const memCaches = memInfo.Buffers + memInfo.Cached - memInfo.Mapped;
                    const memUsed = memInfo.MemTotal - memInfo.MemFree - memCaches;
                    const memSwapped = memInfo.SwapTotal - memInfo.SwapFree;
                    memUsedSeries.addCounterSample(ts, memUsed);
                    memSwappedSeries.addCounterSample(ts, memSwapped);
                    continue;
                }
                const gmd = new tr.model.GlobalMemoryDump(this.model_, ts);
                this.model_.globalMemoryDumps.push(gmd);
                for (const [pid, processInfo] of Object.entries(memoryDump)) {
                    if (processInfo.rss === undefined) {
                        continue;
                    }
                    const modelProcess = this.model_.getProcess(pid);
                    if (modelProcess === undefined) {
                        continue;
                    }
                    const pmd = new tr.model.ProcessMemoryDump(gmd, modelProcess, ts);
                    gmd.processMemoryDumps[pid] = pmd;
                    modelProcess.memoryDumps.push(pmd);
                    this.setProcessMemoryDumpTotals_(pmd, processInfo);
                    this.setProcessMemoryDumpVmRegions_(pmd, processInfo);
                }
            }
        }
    }

    tr.importer.Importer.register(AtraceProcessDumpImporter);
    return {AtraceProcessDumpImporter,};
});
'use strict';
tr.exportTo('tr.model', function () {
    const ColorScheme = tr.b.ColorScheme;

    function Activity(name, category, range, args) {
        tr.model.TimedEvent.call(this, range.min);
        this.title = name;
        this.category = category;
        this.colorId = ColorScheme.getColorIdForGeneralPurposeString(name);
        this.duration = range.duration;
        this.args = args;
        this.name = name;
    }

    Activity.prototype = {
        __proto__: tr.model.TimedEvent.prototype, shiftTimestampsForward(amount) {
            this.start += amount;
        }, addBoundsToRange(range) {
            range.addValue(this.start);
            range.addValue(this.end);
        }
    };
    return {Activity,};
});
'use strict';
tr.exportTo('tr.e.importer.android', function () {
    const Importer = tr.importer.Importer;
    const ACTIVITY_STATE = {
        NONE: 'none',
        CREATED: 'created',
        STARTED: 'started',
        RESUMED: 'resumed',
        PAUSED: 'paused',
        STOPPED: 'stopped',
        DESTROYED: 'destroyed'
    };
    const activityMap = {};

    function EventLogImporter(model, events) {
        this.model_ = model;
        this.events_ = events;
        this.importPriority = 3;
    }

    const eventLogActivityRE = new RegExp('(\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d+)' + '\\s+(\\d+)\\s+(\\d+)\\s+([A-Z])\\s*' + '(am_\\w+)\\s*:(.*)');
    const amCreateRE = new RegExp('\s*\\[.*,.*,.*,(.*),.*,.*,.*,.*\\]');
    const amFocusedRE = new RegExp('\s*\\[\\d+,(.*)\\]');
    const amProcStartRE = new RegExp('\s*\\[\\d+,\\d+,\\d+,.*,activity,(.*)\\]');
    const amOnResumeRE = new RegExp('\s*\\[\\d+,(.*)\\]');
    const amOnPauseRE = new RegExp('\s*\\[\\d+,(.*)\\]');
    const amLaunchTimeRE = new RegExp('\s*\\[\\d+,\\d+,(.*),(\\d+),(\\d+)');
    const amDestroyRE = new RegExp('\s*\\[\\d+,\\d+,\\d+,(.*)\\]');
    EventLogImporter.canImport = function (events) {
        if (!(typeof (events) === 'string' || events instanceof String)) {
            return false;
        }
        if (/^<!DOCTYPE html>/.test(events)) return false;
        return eventLogActivityRE.test(events);
    };
    EventLogImporter.prototype = {
        __proto__: Importer.prototype, get importerName() {
            return 'EventLogImporter';
        }, get model() {
            return this.model_;
        }, getFullActivityName(component) {
            const componentSplit = component.split('/');
            if (componentSplit[1].startsWith('.')) {
                return componentSplit[0] + componentSplit[1];
            }
            return componentSplit[1];
        }, getProcName(component) {
            const componentSplit = component.split('/');
            return componentSplit[0];
        }, findOrCreateActivity(activityName) {
            if (activityName in activityMap) {
                return activityMap[activityName];
            }
            const activity = {state: ACTIVITY_STATE.NONE, name: activityName};
            activityMap[activityName] = activity;
            return activity;
        }, deleteActivity(activityName) {
            delete activityMap[activityName];
        }, handleCreateActivity(ts, activityName) {
            const activity = this.findOrCreateActivity(activityName);
            activity.state = ACTIVITY_STATE.CREATED;
            activity.createdTs = ts;
        }, handleFocusActivity(ts, procName, activityName) {
            const activity = this.findOrCreateActivity(activityName);
            activity.lastFocusedTs = ts;
        }, handleProcStartForActivity(ts, activityName) {
            const activity = this.findOrCreateActivity(activityName);
            activity.procStartTs = ts;
        }, handleOnResumeCalled(ts, pid, activityName) {
            const activity = this.findOrCreateActivity(activityName);
            activity.state = ACTIVITY_STATE.RESUMED;
            activity.lastResumeTs = ts;
            activity.pid = pid;
        }, handleOnPauseCalled(ts, activityName) {
            const activity = this.findOrCreateActivity(activityName);
            activity.state = ACTIVITY_STATE.PAUSED;
            activity.lastPauseTs = ts;
            if (ts > this.model_.bounds.min && ts < this.model_.bounds.max) {
                this.addActivityToProcess(activity);
            }
        }, handleLaunchTime(ts, activityName, launchTime) {
            const activity = this.findOrCreateActivity(activityName);
            activity.launchTime = launchTime;
        }, handleDestroyActivity(ts, activityName) {
            this.deleteActivity(activityName);
        }, addActivityToProcess(activity) {
            if (activity.pid === undefined) return;
            const process = this.model_.getOrCreateProcess(activity.pid);
            const range = tr.b.math.Range.fromExplicitRange(Math.max(this.model_.bounds.min, activity.lastResumeTs), activity.lastPauseTs);
            const newActivity = new tr.model.Activity(activity.name, 'Android Activity', range, {
                created: activity.createdTs,
                procstart: activity.procStartTs,
                lastfocus: activity.lastFocusedTs
            });
            process.activities.push(newActivity);
        }, parseAmLine_(line) {
            let match = eventLogActivityRE.exec(line);
            if (!match) return;
            const firstRealtimeTs = this.model_.bounds.min -
                this.model_.realtime_to_monotonic_offset_ms;
            const year = new Date(firstRealtimeTs).getFullYear();
            const ts = match[1].substring(0, 5) + '-' + year + ' ' +
                match[1].substring(5, match[1].length);
            const monotonicTs = Date.parse(ts) +
                this.model_.realtime_to_monotonic_offset_ms;
            const pid = match[2];
            const action = match[5];
            const data = match[6];
            if (action === 'am_create_activity') {
                match = amCreateRE.exec(data);
                if (match && match.length >= 2) {
                    this.handleCreateActivity(monotonicTs, this.getFullActivityName(match[1]));
                }
            } else if (action === 'am_focused_activity') {
                match = amFocusedRE.exec(data);
                if (match && match.length >= 2) {
                    this.handleFocusActivity(monotonicTs, this.getProcName(match[1]), this.getFullActivityName(match[1]));
                }
            } else if (action === 'am_proc_start') {
                match = amProcStartRE.exec(data);
                if (match && match.length >= 2) {
                    this.handleProcStartForActivity(monotonicTs, this.getFullActivityName(match[1]));
                }
            } else if (action === 'am_on_resume_called') {
                match = amOnResumeRE.exec(data);
                if (match && match.length >= 2) {
                    this.handleOnResumeCalled(monotonicTs, pid, match[1]);
                }
            } else if (action === 'am_on_paused_called') {
                match = amOnPauseRE.exec(data);
                if (match && match.length >= 2) {
                    this.handleOnPauseCalled(monotonicTs, match[1]);
                }
            } else if (action === 'am_activity_launch_time') {
                match = amLaunchTimeRE.exec(data);
                this.handleLaunchTime(monotonicTs, this.getFullActivityName(match[1]), match[2]);
            } else if (action === 'am_destroy_activity') {
                match = amDestroyRE.exec(data);
                if (match && match.length === 2) {
                    this.handleDestroyActivity(monotonicTs, this.getFullActivityName(match[1]));
                }
            }
        }, importEvents() {
            if (isNaN(this.model_.realtime_to_monotonic_offset_ms)) {
                this.model_.importWarning({
                    type: 'eveng_log_clock_sync',
                    message: 'Need a trace_event_clock_sync to map realtime to import.'
                });
                return;
            }
            this.model_.updateBounds();
            const lines = this.events_.split('\n');
            lines.forEach(this.parseAmLine_, this);
            for (const activityName in activityMap) {
                const activity = activityMap[activityName];
                if (activity.state === ACTIVITY_STATE.RESUMED) {
                    activity.lastPauseTs = this.model_.bounds.max;
                    this.addActivityToProcess(activity);
                }
            }
        }
    };
    Importer.register(EventLogImporter);
    return {EventLogImporter,};
});
'use strict';
tr.exportTo('tr.e.importer.android.process_data', function () {
    const Importer = tr.importer.Importer;
    const PROCESS_DUMP_HEADER = 'PROCESS DUMP';

    function ProcessDataImporter(model, processData) {
        this.model_ = model;
        this.processDataLines = processData.split('\n');
        this.importPriority = 3;
    }

    ProcessDataImporter.canImport = function (events) {
        if (!(typeof (events) === 'string' || events instanceof String)) {
            return false;
        }
        if (events.split('\n')[0] === PROCESS_DUMP_HEADER) {
            return true;
        }
        return false;
    };
    ProcessDataImporter.prototype = {
        __proto__: Importer.prototype, get importerName() {
            return 'ProcessDataImporter';
        }, get model() {
            return this.model_;
        }, parseEventData(data) {
            const allDumpedProcesses = {};
            let parseProcesses = false;
            let parseThreads = false;
            let legacy = false;
            for (let i = 1; i < data.length; i++) {
                const cols = data[i].split(/\s+/);
                if (cols[0].startsWith('USER')) {
                    if (parseProcesses) {
                        parseProcesses = false;
                        parseThreads = true;
                    } else {
                        parseThreads = false;
                        parseProcesses = true;
                    }
                    const colCount = cols.length;
                    if (parseProcesses && colCount === 9) {
                        legacy = false;
                    } else if (parseProcesses && colCount === 8) {
                        legacy = true;
                    }
                    continue;
                }
                if (parseProcesses) {
                    const pid = Number(cols[1]);
                    if (allDumpedProcesses[pid] === undefined) {
                        allDumpedProcesses[pid] = {};
                    }
                    allDumpedProcesses[pid] = {'name': cols[8], pid, 'comm': cols[9]};
                    continue;
                }
                if (parseThreads) {
                    let pid;
                    let tid;
                    let name;
                    if (legacy) {
                        pid = Number(cols[1]);
                        if (allDumpedProcesses[pid] !== undefined) {
                            tid = pid;
                        } else {
                            tid = pid;
                            pid = Number(cols[2]);
                        }
                        name = cols.slice(8).join(' ');
                    } else {
                        pid = Number(cols[1]);
                        tid = Number(cols[2]);
                        name = cols.slice(3).join(' ');
                    }
                    if (allDumpedProcesses[pid] === undefined) continue;
                    if (allDumpedProcesses[pid].threads === undefined) {
                        allDumpedProcesses[pid].threads = {};
                    }
                    allDumpedProcesses[pid].threads[tid] = {tid, name};
                    continue;
                }
            }
            return allDumpedProcesses;
        }, importEvents() {
            const allDumpedProcesses = this.parseEventData(this.processDataLines);
            const modelProcesses = this.model_.getAllProcesses();
            for (let i = 0; i < modelProcesses.length; i++) {
                const modelProcess = modelProcesses[i];
                const pid = modelProcess.pid;
                const dumpedProcess = allDumpedProcesses[pid];
                if (dumpedProcess === undefined) {
                    continue;
                }
                modelProcess.name = dumpedProcess.name;
                const processDumpThreads = dumpedProcess.threads;
                if (processDumpThreads !== undefined) {
                    for (const tid in modelProcess.threads) {
                        const modelThread = modelProcess.threads[tid];
                        if (Number(pid) === Number(tid)) {
                            modelThread.name = 'UI thread';
                        } else if (modelThread.name === '<...>') {
                            if (processDumpThreads[tid] !== undefined) {
                                modelThread.name = processDumpThreads[tid].name;
                            }
                        }
                    }
                }
            }
        }
    };
    Importer.register(ProcessDataImporter);
    return {ProcessDataImporter,};
});
'use strict';
tr.exportTo('tr.e.importer.battor', function () {
    function BattorImporter(model, events) {
        this.importPriority = 3;
        this.model_ = model;
        this.samples_ = [];
        this.syncTimestampsById_ = new Map();
        this.parseTrace_(events);
    }

    const battorDataLineRE = new RegExp('^(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)' + '(?:\\s+<(\\S+)>)?$');
    const battorHeaderLineRE = /^# BattOr/;
    BattorImporter.canImport = function (events) {
        if (!(typeof (events) === 'string' || events instanceof String)) {
            return false;
        }
        return battorHeaderLineRE.test(events);
    };
    BattorImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'BattorImporter';
        }, get model() {
            return this.model_;
        }, importClockSyncMarkers() {
            for (const [syncId, ts] of this.syncTimestampsById_) {
                this.model_.clockSyncManager.addClockSyncMarker(tr.model.ClockDomainId.BATTOR, syncId, ts);
            }
        }, importEvents() {
            if (this.model_.device.powerSeries) {
                this.model_.importWarning({
                    type: 'import_error',
                    message: 'Power counter exists, can not import BattOr power trace.'
                });
                return;
            }
            const modelTimeTransformer = this.model_.clockSyncManager.getModelTimeTransformer(tr.model.ClockDomainId.BATTOR);
            const powerSeries = this.model_.device.powerSeries = new tr.model.PowerSeries(this.model_.device);
            for (let i = 0; i < this.samples_.length; i++) {
                const sample = this.samples_[i];
                powerSeries.addPowerSample(modelTimeTransformer(sample.ts), sample.powerInW);
            }
        }, parseTrace_(trace) {
            const lines = trace.split('\n');
            for (let line of lines) {
                line = line.trim();
                if (line.length === 0) continue;
                if (line.startsWith('#')) continue;
                const groups = battorDataLineRE.exec(line);
                if (!groups) {
                    this.model_.importWarning({
                        type: 'parse_error',
                        message: 'Unrecognized line in BattOr trace: ' + line
                    });
                    continue;
                }
                const ts = parseFloat(groups[1]);
                const voltageInV = tr.b.convertUnit(parseFloat(groups[2]), tr.b.UnitPrefixScale.METRIC.MILLI, tr.b.UnitPrefixScale.METRIC.NONE);
                const currentInA = tr.b.convertUnit(parseFloat(groups[3]), tr.b.UnitPrefixScale.METRIC.MILLI, tr.b.UnitPrefixScale.METRIC.NONE);
                const syncId = groups[4];
                if (syncId) {
                    this.syncTimestampsById_.set(syncId, ts);
                }
                if (voltageInV < 0 || currentInA < 0) {
                    this.model_.importWarning({
                        type: 'parse_error',
                        message: 'The following line in the BattOr trace has a negative ' + 'voltage or current, neither of which are allowed: ' + line + '. A common cause of this is that the device is charging ' + 'while the trace is being recorded.'
                    });
                    continue;
                }
                this.samples_.push(new Sample(ts, voltageInV, currentInA));
            }
        }
    };

    function Sample(ts, voltageInV, currentInA) {
        this.ts = ts;
        this.voltageInV = voltageInV;
        this.currentInA = currentInA;
    }

    Sample.prototype = {
        get powerInW() {
            return this.voltageInV * this.currentInA;
        }
    };
    tr.importer.Importer.register(BattorImporter);
    return {BattorImporter,};
});
'use strict';
tr.exportTo('tr.e.importer.ddms', function () {
    const kPid = 0;
    const kCategory = 'java';
    const kMethodLutEndMarker = '\n*end\n';
    const kThreadsStart = '\n*threads\n';
    const kMethodsStart = '\n*methods\n';
    const kTraceMethodEnter = 0x00;
    const kTraceMethodExit = 0x01;
    const kTraceUnroll = 0x02;
    const kTraceMethodActionMask = 0x03;
    const kTraceHeaderLength = 32;
    const kTraceMagicValue = 0x574f4c53;
    const kTraceVersionSingleClock = 2;
    const kTraceVersionDualClock = 3;
    const kTraceRecordSizeSingleClock = 10;
    const kTraceRecordSizeDualClock = 14;

    function Reader(stringPayload) {
        this.position_ = 0;
        this.data_ = new Uint8Array(stringPayload.length);
        for (let i = 0; i < stringPayload.length; ++i) {
            this.data_[i] = stringPayload.charCodeAt(i);
        }
    }

    Reader.prototype = {
        __proto__: Object.prototype, uint8() {
            const result = this.data_[this.position_];
            this.position_ += 1;
            return result;
        }, uint16() {
            let result = 0;
            result += this.uint8();
            result += this.uint8() << 8;
            return result;
        }, uint32() {
            let result = 0;
            result += this.uint8();
            result += this.uint8() << 8;
            result += this.uint8() << 16;
            result += this.uint8() << 24;
            return result;
        }, uint64() {
            const low = this.uint32();
            const high = this.uint32();
            const lowStr = ('0000000' + low.toString(16)).substr(-8);
            const highStr = ('0000000' + high.toString(16)).substr(-8);
            const result = highStr + lowStr;
            return result;
        }, seekTo(position) {
            this.position_ = position;
        }, hasMore() {
            return this.position_ < this.data_.length;
        }
    };

    function DdmsImporter(model, data) {
        this.importPriority = 3;
        this.model_ = model;
        this.data_ = data;
    }

    DdmsImporter.canImport = function (data) {
        if (typeof (data) === 'string' || data instanceof String) {
            const header = data.slice(0, 1000);
            return header.startsWith('*version\n') && header.indexOf('\nvm=') >= 0 && header.indexOf(kThreadsStart) >= 0;
        }
        return false;
    };
    DdmsImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'DdmsImporter';
        }, get model() {
            return this.model_;
        }, importEvents() {
            const divider = this.data_.indexOf(kMethodLutEndMarker) +
                kMethodLutEndMarker.length;
            this.metadata_ = this.data_.slice(0, divider);
            this.methods_ = {};
            this.parseThreads();
            this.parseMethods();
            const traceReader = new Reader(this.data_.slice(divider));
            const magic = traceReader.uint32();
            if (magic !== kTraceMagicValue) {
                throw Error('Failed to match magic value');
            }
            this.version_ = traceReader.uint16();
            if (this.version_ !== kTraceVersionDualClock) {
                throw Error('Unknown version');
            }
            const dataOffest = traceReader.uint16();
            const startDateTime = traceReader.uint64();
            const recordSize = traceReader.uint16();
            traceReader.seekTo(dataOffest);
            while (traceReader.hasMore()) {
                this.parseTraceEntry(traceReader);
            }
        }, parseTraceEntry(reader) {
            const tid = reader.uint16();
            const methodPacked = reader.uint32();
            const cpuSinceStart = reader.uint32();
            const wallClockSinceStart = reader.uint32();
            let method = methodPacked & ~kTraceMethodActionMask;
            const action = methodPacked & kTraceMethodActionMask;
            const thread = this.getTid(tid);
            method = this.getMethodName(method);
            if (action === kTraceMethodEnter) {
                thread.sliceGroup.beginSlice(kCategory, method, wallClockSinceStart, undefined, cpuSinceStart);
            } else if (thread.sliceGroup.openSliceCount) {
                thread.sliceGroup.endSlice(wallClockSinceStart, cpuSinceStart);
            }
        }, parseThreads() {
            let threads = this.metadata_.slice(this.metadata_.indexOf(kThreadsStart) +
                kThreadsStart.length);
            threads = threads.slice(0, threads.indexOf('\n*'));
            threads = threads.split('\n');
            threads.forEach(this.parseThread.bind(this));
        }, parseThread(threadLine) {
            const tid = threadLine.slice(0, threadLine.indexOf('\t'));
            const thread = this.getTid(parseInt(tid));
            thread.name = threadLine.slice(threadLine.indexOf('\t') + 1);
        }, getTid(tid) {
            return this.model_.getOrCreateProcess(kPid).getOrCreateThread(tid);
        }, parseMethods() {
            let methods = this.metadata_.slice(this.metadata_.indexOf(kMethodsStart) +
                kMethodsStart.length);
            methods = methods.slice(0, methods.indexOf('\n*'));
            methods = methods.split('\n');
            methods.forEach(this.parseMethod.bind(this));
        }, parseMethod(methodLine) {
            const data = methodLine.split('\t');
            const methodId = parseInt(data[0]);
            const methodName = data[1] + '.' + data[2] + data[3];
            this.addMethod(methodId, methodName);
        }, addMethod(methodId, methodName) {
            this.methods_[methodId] = methodName;
        }, getMethodName(methodId) {
            return this.methods_[methodId];
        }
    };
    tr.importer.Importer.register(DdmsImporter);
    return {DdmsImporter,};
});
'use strict';
tr.exportTo('tr.e.audits', function () {
    class LowMemoryAuditor extends tr.c.Auditor {
        constructor(model) {
            super();
            this.model_ = model;
        }

        runAnnotate() {
            this.model_.device.lowMemoryEvents = this.getLowMemoryEvents_();
        }

        getLowMemoryEvents_() {
            const model = this.model_;
            const result = [];
            for (const process of model.getAllProcesses()) {
                for (const e of process.getDescendantEvents()) {
                    if (!(e instanceof tr.model.ThreadSlice) || e.duration !== 0) {
                        continue;
                    }
                    if (e.category !== 'lowmemory') {
                        continue;
                    }
                    result.push(e);
                }
            }
            return result;
        }
    }

    tr.c.Auditor.register(LowMemoryAuditor);
    return {LowMemoryAuditor};
});
'use strict';

function filterDuplicateTimestamps(timestamps) {
    const dedupedTimestamps = [];
    let lastTs = 0;
    for (const ts of timestamps) {
        if (ts - lastTs >= 1) {
            dedupedTimestamps.push(ts);
            lastTs = ts;
        }
    }
    return dedupedTimestamps;
}

tr.exportTo('tr.e.audits', function () {
    const VSYNC_COUNTER_PRECISIONS = {'android.VSYNC-app': 15, 'android.VSYNC': 15};
    const VSYNC_SLICE_PRECISIONS = {
        'RenderWidgetHostViewAndroid::OnVSync': 5,
        'VSYNC': 10,
        'vblank': 10,
        'DisplayLinkMac::GetVSyncParameters': 5
    };
    const BEGIN_FRAME_SLICE_PRECISION = {'DisplayScheduler::BeginFrame': 10};

    function VSyncAuditor(model) {
        tr.c.Auditor.call(this, model);
    }

    VSyncAuditor.prototype = {
        __proto__: tr.c.Auditor.prototype, runAnnotate() {
            this.model.device.vSyncTimestamps = this.findVSyncTimestamps(this.model);
        }, findVSyncTimestamps(model) {
            let times = [];
            let maxPrecision = Number.NEGATIVE_INFINITY;
            let maxTitle = undefined;

            function useInstead(title, precisions) {
                const precision = precisions[title];
                if (precision === undefined) return false;
                if (title === maxTitle) return true;
                if (precision <= maxPrecision) {
                    if (precision === maxPrecision) {
                        model.importWarning({
                            type: 'VSyncAuditor',
                            message: 'Encountered two different VSync events (' +
                                maxTitle + ', ' + title + ') with the same precision, ' + 'ignoring the newer one (' + title + ')',
                            showToUser: false,
                        });
                    }
                    return false;
                }
                maxPrecision = precision;
                maxTitle = title;
                times = [];
                return true;
            }

            for (const pid in model.processes) {
                const process = model.processes[pid];
                for (const cid in process.counters) {
                    if (useInstead(cid, VSYNC_COUNTER_PRECISIONS)) {
                        const counter = process.counters[cid];
                        for (let i = 0; i < counter.series.length; i++) {
                            const series = counter.series[i];
                            Array.prototype.push.apply(times, series.timestamps);
                        }
                    }
                }
                for (const tid in process.threads) {
                    const thread = process.threads[tid];
                    for (let i = 0; i < thread.sliceGroup.slices.length; i++) {
                        const slice = thread.sliceGroup.slices[i];
                        if (useInstead(slice.title, VSYNC_SLICE_PRECISIONS)) {
                            times.push(slice.start);
                        } else if (useInstead(slice.title, BEGIN_FRAME_SLICE_PRECISION) && slice.args.args && slice.args.args.frame_time_us) {
                            times.push(slice.args.args.frame_time_us / 1000.0);
                        }
                    }
                }
            }
            times.sort(function (x, y) {
                return x - y;
            });
            return filterDuplicateTimestamps(times);
        }
    };
    tr.c.Auditor.register(VSyncAuditor);
    return {VSyncAuditor,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    function EmptyImporter(events) {
        this.importPriority = 0;
    }

    EmptyImporter.canImport = function (eventData) {
        if (eventData instanceof Array && eventData.length === 0) {
            return true;
        }
        if (typeof (eventData) === 'string' || eventData instanceof String) {
            return eventData.length === 0;
        }
        return false;
    };
    EmptyImporter.prototype = {
        __proto__: tr.importer.Importer.prototype, get importerName() {
            return 'EmptyImporter';
        }
    };
    tr.importer.Importer.register(EmptyImporter);
    return {EmptyImporter,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    function AnimationExpectation(parentModel, initiatorTitle, start, duration) {
        tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
        this.frameEvents_ = undefined;
    }

    AnimationExpectation.prototype = {
        __proto__: tr.model.um.UserExpectation.prototype, constructor: AnimationExpectation, get frameEvents() {
            if (this.frameEvents_) {
                return this.frameEvents_;
            }
            this.frameEvents_ = new tr.model.EventSet();
            this.associatedEvents.forEach(function (event) {
                if (event.title === tr.model.helpers.IMPL_RENDERING_STATS) {
                    this.frameEvents_.push(event);
                }
            }, this);
            return this.frameEvents_;
        }
    };
    tr.model.um.UserExpectation.subTypes.register(AnimationExpectation, {
        stageTitle: 'Animation',
        colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_animation')
    });
    return {AnimationExpectation,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    function ProtoExpectation(type, initiatorType) {
        this.type = type;
        this.initiatorType = initiatorType;
        this.start = Infinity;
        this.end = -Infinity;
        this.associatedEvents = new tr.model.EventSet();
        this.isAnimationBegin = false;
    }

    ProtoExpectation.RESPONSE_TYPE = 'r';
    ProtoExpectation.ANIMATION_TYPE = 'a';
    ProtoExpectation.IGNORED_TYPE = 'ignored';
    const INITIATOR_HIERARCHY = [tr.model.um.INITIATOR_TYPE.PINCH, tr.model.um.INITIATOR_TYPE.FLING, tr.model.um.INITIATOR_TYPE.MOUSE_WHEEL, tr.model.um.INITIATOR_TYPE.SCROLL, tr.model.um.INITIATOR_TYPE.VR, tr.model.um.INITIATOR_TYPE.VIDEO, tr.model.um.INITIATOR_TYPE.WEBGL, tr.model.um.INITIATOR_TYPE.CSS, tr.model.um.INITIATOR_TYPE.MOUSE, tr.model.um.INITIATOR_TYPE.KEYBOARD, tr.model.um.INITIATOR_TYPE.TAP, tr.model.um.INITIATOR_TYPE.TOUCH];

    function combineInitiatorTypes(title1, title2) {
        for (const item of INITIATOR_HIERARCHY) {
            if (title1 === item || title2 === item) return item;
        }
        throw new Error('Invalid titles in combineInitiatorTypes');
    }

    ProtoExpectation.prototype = {
        get isValid() {
            return this.end > this.start;
        }, containsTypeNames(typeNames) {
            return this.associatedEvents.some(x => typeNames.indexOf(x.typeName) >= 0);
        }, containsSliceTitle(title) {
            return this.associatedEvents.some(x => title === x.title);
        }, createInteractionRecord(model) {
            if (this.type !== ProtoExpectation.IGNORED_TYPE && !this.isValid) {
                model.importWarning({
                    type: 'ProtoExpectation',
                    message: 'Please file a bug with this trace. ' + this.debug(),
                    showToUser: true
                });
                return undefined;
            }
            const duration = this.end - this.start;
            let ir = undefined;
            switch (this.type) {
                case ProtoExpectation.RESPONSE_TYPE:
                    ir = new tr.model.um.ResponseExpectation(model, this.initiatorType, this.start, duration, this.isAnimationBegin);
                    break;
                case ProtoExpectation.ANIMATION_TYPE:
                    ir = new tr.model.um.AnimationExpectation(model, this.initiatorType, this.start, duration);
                    break;
            }
            if (!ir) return undefined;
            ir.sourceEvents.addEventSet(this.associatedEvents);

            function pushAssociatedEvents(event) {
                ir.associatedEvents.push(event);
                if (event.associatedEvents) {
                    ir.associatedEvents.addEventSet(event.associatedEvents);
                }
            }

            this.associatedEvents.forEach(function (event) {
                pushAssociatedEvents(event);
                if (event.subSlices) {
                    event.subSlices.forEach(pushAssociatedEvents);
                }
            });
            return ir;
        }, merge(other) {
            this.initiatorType = combineInitiatorTypes(this.initiatorType, other.initiatorType);
            this.associatedEvents.addEventSet(other.associatedEvents);
            this.start = Math.min(this.start, other.start);
            this.end = Math.max(this.end, other.end);
            if (other.isAnimationBegin) {
                this.isAnimationBegin = true;
            }
        }, pushEvent(event) {
            this.start = Math.min(this.start, event.start);
            this.end = Math.max(this.end, event.end);
            this.associatedEvents.push(event);
        }, pushSample(sample) {
            this.start = Math.min(this.start, sample.timestamp);
            this.end = Math.max(this.end, sample.timestamp);
            this.associatedEvents.push(sample);
        }, containsTimestampInclusive(timestamp) {
            return (this.start <= timestamp) && (timestamp <= this.end);
        }, intersects(other) {
            return (other.start < this.end) && (other.end > this.start);
        }, isNear(event, threshold) {
            return (this.end + threshold) > event.start;
        }, debug() {
            let debugString = this.type + '(';
            debugString += parseInt(this.start) + ' ';
            debugString += parseInt(this.end);
            this.associatedEvents.forEach(function (event) {
                debugString += ' ' + event.typeName;
            });
            return debugString + ')';
        }
    };
    return {ProtoExpectation,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    const ProtoExpectation = tr.importer.ProtoExpectation;
    const INITIATOR_TYPE = tr.model.um.INITIATOR_TYPE;
    const INPUT_TYPE = tr.e.cc.INPUT_EVENT_TYPE_NAMES;
    const KEYBOARD_TYPE_NAMES = [INPUT_TYPE.CHAR, INPUT_TYPE.KEY_DOWN_RAW, INPUT_TYPE.KEY_DOWN, INPUT_TYPE.KEY_UP];
    const MOUSE_RESPONSE_TYPE_NAMES = [INPUT_TYPE.CLICK, INPUT_TYPE.CONTEXT_MENU];
    const MOUSE_WHEEL_TYPE_NAMES = [INPUT_TYPE.MOUSE_WHEEL];
    const MOUSE_DRAG_TYPE_NAMES = [INPUT_TYPE.MOUSE_DOWN, INPUT_TYPE.MOUSE_MOVE, INPUT_TYPE.MOUSE_UP];
    const TAP_TYPE_NAMES = [INPUT_TYPE.TAP, INPUT_TYPE.TAP_CANCEL, INPUT_TYPE.TAP_DOWN];
    const PINCH_TYPE_NAMES = [INPUT_TYPE.PINCH_BEGIN, INPUT_TYPE.PINCH_END, INPUT_TYPE.PINCH_UPDATE];
    const FLING_TYPE_NAMES = [INPUT_TYPE.FLING_CANCEL, INPUT_TYPE.FLING_START];
    const TOUCH_TYPE_NAMES = [INPUT_TYPE.TOUCH_END, INPUT_TYPE.TOUCH_MOVE, INPUT_TYPE.TOUCH_START];
    const SCROLL_TYPE_NAMES = [INPUT_TYPE.SCROLL_BEGIN, INPUT_TYPE.SCROLL_END, INPUT_TYPE.SCROLL_UPDATE];
    const ALL_HANDLED_TYPE_NAMES = [].concat(KEYBOARD_TYPE_NAMES, MOUSE_RESPONSE_TYPE_NAMES, MOUSE_WHEEL_TYPE_NAMES, MOUSE_DRAG_TYPE_NAMES, PINCH_TYPE_NAMES, TAP_TYPE_NAMES, FLING_TYPE_NAMES, TOUCH_TYPE_NAMES, SCROLL_TYPE_NAMES);
    const RENDERER_FLING_TITLE = 'InputHandlerProxy::HandleGestureFling::started';
    const PLAYBACK_EVENT_TITLE = 'VideoPlayback';
    const CSS_ANIMATION_TITLE = 'Animation';
    const VR_COUNTER_NAMES = ['gpu.WebVR FPS', 'gpu.WebVR frame time (ms)', 'gpu.WebVR pose prediction (ms)', 'gpu.WebXR FPS',];
    const VR_EXPECTATION_EVENTS = {
        'Vr.AcquireGvrFrame': {
            'histogramName': 'acquire_frame',
            'description': 'Duration acquire a frame from GVR',
            'hasCpuTime': true,
        },
        'Vr.DrawFrame': {
            'histogramName': 'draw_frame',
            'description': 'Duration to render one frame',
            'hasCpuTime': true,
        },
        'Vr.PostSubmitDrawOnGpu': {
            'histogramName': 'post_submit_draw_on_gpu',
            'description': 'Duration to draw a frame on GPU post submit to ' + 'GVR. Note this duration may include time spent on ' + 'reprojection',
            'hasCpuTime': false,
        },
        'Vr.ProcessControllerInput': {
            'histogramName': 'update_controller',
            'description': 'Duration to query input from the controller',
            'hasCpuTime': true,
        },
        'Vr.ProcessControllerInputForWebXr': {
            'histogramName': 'update_controller_webxr',
            'description': 'Duration to query input from the controller for WebXR',
            'hasCpuTime': true,
        },
        'Vr.SubmitFrameNow': {
            'histogramName': 'submit_frame',
            'description': 'Duration to submit a frame to GVR',
            'hasCpuTime': true,
        }
    };
    const WEBXR_INSTANT_EVENTS = {
        'WebXR frame time (ms)': {
            'javascript': {
                'histogramName': 'webxr_frame_time_javascript',
                'description': 'WebXR frame time spent on JavaScript',
            },
            'rendering': {
                'histogramName': 'webxr_frame_time_rendering',
                'description': 'WebXR frame time spent on rendering'
            }
        },
        'WebXR pose prediction': {
            'milliseconds': {
                'histogramName': 'webxr_pose_prediction',
                'description': 'WebXR pose prediction in ms',
            },
        },
    };
    const XR_DEVICE_SERVICE_PROCESS = 'Service: xr_device_service';

    function isXrDeviceServiceProcess(process) {
        if (process.name === XR_DEVICE_SERVICE_PROCESS) return true;
        return false;
    }

    const VR_RESPONSE_MS = 1000;
    const INPUT_MERGE_THRESHOLD_MS = 200;
    const ANIMATION_MERGE_THRESHOLD_MS = 32;
    const MOUSE_WHEEL_THRESHOLD_MS = 40;
    const MOUSE_MOVE_THRESHOLD_MS = 40;

    function compareEvents(x, y) {
        if (x.start !== y.start) {
            return x.start - y.start;
        }
        if (x.end !== y.end) {
            return x.end - y.end;
        }
        if (x.guid && y.guid) {
            return x.guid - y.guid;
        }
        return 0;
    }

    function forEventTypesIn(events, typeNames, cb, opt_this) {
        events.forEach(function (event) {
            if (typeNames.indexOf(event.typeName) >= 0) {
                cb.call(opt_this, event);
            }
        });
    }

    function causedFrame(event) {
        return event.associatedEvents.some(isImplFrameEvent);
    }

    function getSortedFrameEventsByProcess(modelHelper) {
        const frameEventsByPid = {};
        for (const [pid, rendererHelper] of
            Object.entries(modelHelper.rendererHelpers)) {
            frameEventsByPid[pid] = rendererHelper.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds);
        }
        return frameEventsByPid;
    }

    function getSortedInputEvents(modelHelper) {
        const inputEvents = [];
        const browserProcess = modelHelper.browserHelper.process;
        const mainThread = browserProcess.findAtMostOneThreadNamed('CrBrowserMain');
        for (const slice of mainThread.asyncSliceGroup.getDescendantEvents()) {
            if (!slice.isTopLevel) continue;
            if (!(slice instanceof tr.e.cc.InputLatencyAsyncSlice)) continue;
            if (isNaN(slice.start) || isNaN(slice.duration) || isNaN(slice.end)) {
                continue;
            }
            inputEvents.push(slice);
        }
        return inputEvents.sort(compareEvents);
    }

    function findProtoExpectations(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        const handlers = [handleKeyboardEvents, handleMouseResponseEvents, handleMouseWheelEvents, handleMouseDragEvents, handleTapResponseEvents, handlePinchEvents, handleFlingEvents, handleTouchEvents, handleScrollEvents, handleCSSAnimations, handleWebGLAnimations, handleVideoAnimations, handleVrAnimations,];
        handlers.forEach(function (handler) {
            protoExpectations.push.apply(protoExpectations, handler(modelHelper, sortedInputEvents, warn));
        });
        protoExpectations.sort(compareEvents);
        return protoExpectations;
    }

    function handleKeyboardEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        forEventTypesIn(sortedInputEvents, KEYBOARD_TYPE_NAMES, function (event) {
            const pe = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.KEYBOARD);
            pe.pushEvent(event);
            protoExpectations.push(pe);
        });
        return protoExpectations;
    }

    function handleMouseResponseEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        forEventTypesIn(sortedInputEvents, MOUSE_RESPONSE_TYPE_NAMES, function (event) {
            const pe = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
        });
        return protoExpectations;
    }

    function handleMouseWheelEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;
        let prevEvent_ = undefined;
        forEventTypesIn(sortedInputEvents, MOUSE_WHEEL_TYPE_NAMES, function (event) {
            const prevEvent = prevEvent_;
            prevEvent_ = event;
            if (currentPE && (prevEvent.start + MOUSE_WHEEL_THRESHOLD_MS) >= event.start) {
                if (currentPE.type === ProtoExpectation.ANIMATION_TYPE) {
                    currentPE.pushEvent(event);
                } else {
                    currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.MOUSE_WHEEL);
                    currentPE.pushEvent(event);
                    protoExpectations.push(currentPE);
                }
                return;
            }
            currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE_WHEEL);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
        });
        return protoExpectations;
    }

    function handleMouseDragEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;
        let mouseDownEvent = undefined;
        forEventTypesIn(sortedInputEvents, MOUSE_DRAG_TYPE_NAMES, function (event) {
            switch (event.typeName) {
                case INPUT_TYPE.MOUSE_DOWN:
                    if (causedFrame(event)) {
                        const pe = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                    } else {
                        mouseDownEvent = event;
                    }
                    break;
                case INPUT_TYPE.MOUSE_MOVE:
                    if (!causedFrame(event)) {
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                    } else if (!currentPE || !currentPE.isNear(event, MOUSE_MOVE_THRESHOLD_MS)) {
                        currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
                        currentPE.pushEvent(event);
                        if (mouseDownEvent) {
                            currentPE.associatedEvents.push(mouseDownEvent);
                            mouseDownEvent = undefined;
                        }
                        protoExpectations.push(currentPE);
                    } else {
                        if (currentPE.type === ProtoExpectation.ANIMATION_TYPE) {
                            currentPE.pushEvent(event);
                        } else {
                            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.MOUSE);
                            currentPE.pushEvent(event);
                            protoExpectations.push(currentPE);
                        }
                    }
                    break;
                case INPUT_TYPE.MOUSE_UP:
                    if (!mouseDownEvent) {
                        const pe = new ProtoExpectation(causedFrame(event) ? ProtoExpectation.RESPONSE_TYPE : ProtoExpectation.IGNORED_TYPE, INITIATOR_TYPE.MOUSE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                        break;
                    }
                    if (currentPE) {
                        currentPE.pushEvent(event);
                    } else {
                        currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
                        if (mouseDownEvent) {
                            currentPE.associatedEvents.push(mouseDownEvent);
                        }
                        currentPE.pushEvent(event);
                        protoExpectations.push(currentPE);
                    }
                    mouseDownEvent = undefined;
                    currentPE = undefined;
                    break;
            }
        });
        if (mouseDownEvent) {
            currentPE = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            currentPE.pushEvent(mouseDownEvent);
            protoExpectations.push(currentPE);
        }
        return protoExpectations;
    }

    function handleTapResponseEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;
        forEventTypesIn(sortedInputEvents, TAP_TYPE_NAMES, function (event) {
            switch (event.typeName) {
                case INPUT_TYPE.TAP_DOWN:
                    currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TAP);
                    currentPE.pushEvent(event);
                    protoExpectations.push(currentPE);
                    break;
                case INPUT_TYPE.TAP:
                    if (currentPE) {
                        currentPE.pushEvent(event);
                    } else {
                        currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TAP);
                        currentPE.pushEvent(event);
                        protoExpectations.push(currentPE);
                    }
                    currentPE = undefined;
                    break;
                case INPUT_TYPE.TAP_CANCEL:
                    if (!currentPE) {
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                        break;
                    }
                    if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
                        currentPE.pushEvent(event);
                    } else {
                        currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TAP);
                        currentPE.pushEvent(event);
                        protoExpectations.push(currentPE);
                    }
                    currentPE = undefined;
                    break;
            }
        });
        return protoExpectations;
    }

    function handlePinchEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;
        let sawFirstUpdate = false;
        const modelBounds = modelHelper.model.bounds;
        forEventTypesIn(sortedInputEvents, PINCH_TYPE_NAMES, function (event) {
            switch (event.typeName) {
                case INPUT_TYPE.PINCH_BEGIN:
                    if (currentPE && currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
                        currentPE.pushEvent(event);
                        break;
                    }
                    currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.PINCH);
                    currentPE.pushEvent(event);
                    currentPE.isAnimationBegin = true;
                    protoExpectations.push(currentPE);
                    sawFirstUpdate = false;
                    break;
                case INPUT_TYPE.PINCH_UPDATE:
                    if (!currentPE || ((currentPE.type === ProtoExpectation.RESPONSE_TYPE) && sawFirstUpdate) || !currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
                        currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.PINCH);
                        currentPE.pushEvent(event);
                        protoExpectations.push(currentPE);
                    } else {
                        currentPE.pushEvent(event);
                        sawFirstUpdate = true;
                    }
                    break;
                case INPUT_TYPE.PINCH_END:
                    if (currentPE) {
                        currentPE.pushEvent(event);
                    } else {
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                    }
                    currentPE = undefined;
                    break;
            }
        });
        return protoExpectations;
    }

    function handleFlingEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;

        function isRendererFling(event) {
            return event.title === RENDERER_FLING_TITLE;
        }

        const browserHelper = modelHelper.browserHelper;
        const flingEvents = browserHelper.getAllAsyncSlicesMatching(isRendererFling);
        forEventTypesIn(sortedInputEvents, FLING_TYPE_NAMES, function (event) {
            flingEvents.push(event);
        });
        flingEvents.sort(compareEvents);
        flingEvents.forEach(function (event) {
            if (event.title === RENDERER_FLING_TITLE) {
                if (currentPE) {
                    currentPE.pushEvent(event);
                } else {
                    currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.FLING);
                    currentPE.pushEvent(event);
                    protoExpectations.push(currentPE);
                }
                return;
            }
            switch (event.typeName) {
                case INPUT_TYPE.FLING_START:
                    if (currentPE) {
                        warn({type: 'UserModelBuilder', message: 'Unexpected FlingStart', showToUser: false,});
                        currentPE.pushEvent(event);
                    } else {
                        currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.FLING);
                        currentPE.pushEvent(event);
                        currentPE.end = 0;
                        protoExpectations.push(currentPE);
                    }
                    break;
                case INPUT_TYPE.FLING_CANCEL:
                    if (currentPE) {
                        currentPE.pushEvent(event);
                        currentPE.end = event.start;
                        currentPE = undefined;
                    } else {
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                    }
                    break;
            }
        });
        if (currentPE && !currentPE.end) {
            currentPE.end = modelHelper.model.bounds.max;
        }
        return protoExpectations;
    }

    function handleTouchEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;
        let sawFirstMove = false;
        forEventTypesIn(sortedInputEvents, TOUCH_TYPE_NAMES, function (event) {
            switch (event.typeName) {
                case INPUT_TYPE.TOUCH_START:
                    if (currentPE) {
                        currentPE.pushEvent(event);
                    } else {
                        currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TOUCH);
                        currentPE.pushEvent(event);
                        currentPE.isAnimationBegin = true;
                        protoExpectations.push(currentPE);
                        sawFirstMove = false;
                    }
                    break;
                case INPUT_TYPE.TOUCH_MOVE:
                    if (!currentPE) {
                        currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.TOUCH);
                        currentPE.pushEvent(event);
                        protoExpectations.push(currentPE);
                        break;
                    }
                    if ((sawFirstMove && (currentPE.type === ProtoExpectation.RESPONSE_TYPE)) || !currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
                        const prevEnd = currentPE.end;
                        currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.TOUCH);
                        currentPE.pushEvent(event);
                        currentPE.start = prevEnd;
                        protoExpectations.push(currentPE);
                    } else {
                        currentPE.pushEvent(event);
                        sawFirstMove = true;
                    }
                    break;
                case INPUT_TYPE.TOUCH_END:
                    if (!currentPE) {
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                        break;
                    }
                    if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
                        currentPE.pushEvent(event);
                    } else {
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                    }
                    currentPE = undefined;
                    break;
            }
        });
        return protoExpectations;
    }

    function handleScrollEvents(modelHelper, sortedInputEvents, warn) {
        const protoExpectations = [];
        let currentPE = undefined;
        let sawFirstUpdate = false;
        forEventTypesIn(sortedInputEvents, SCROLL_TYPE_NAMES, function (event) {
            switch (event.typeName) {
                case INPUT_TYPE.SCROLL_BEGIN:
                    currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.SCROLL);
                    currentPE.pushEvent(event);
                    currentPE.isAnimationBegin = true;
                    protoExpectations.push(currentPE);
                    sawFirstUpdate = false;
                    break;
                case INPUT_TYPE.SCROLL_UPDATE:
                    if (currentPE) {
                        if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS) && ((currentPE.type === ProtoExpectation.ANIMATION_TYPE) || !sawFirstUpdate)) {
                            currentPE.pushEvent(event);
                            sawFirstUpdate = true;
                        } else {
                            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.SCROLL);
                            currentPE.pushEvent(event);
                            protoExpectations.push(currentPE);
                        }
                    } else {
                        currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.SCROLL);
                        currentPE.pushEvent(event);
                        protoExpectations.push(currentPE);
                    }
                    break;
                case INPUT_TYPE.SCROLL_END:
                    if (!currentPE) {
                        warn({type: 'UserModelBuilder', message: 'Unexpected ScrollEnd', showToUser: false,});
                        const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                        pe.pushEvent(event);
                        protoExpectations.push(pe);
                        break;
                    }
                    currentPE.pushEvent(event);
                    break;
            }
        });
        return protoExpectations;
    }

    function handleVideoAnimations(modelHelper, sortedInputEvents, warn) {
        const events = [];
        for (const pid in modelHelper.rendererHelpers) {
            for (const tid in modelHelper.rendererHelpers[pid].process.threads) {
                for (const asyncSlice of
                    modelHelper.rendererHelpers[pid].process.threads[tid].asyncSliceGroup.slices) {
                    if (asyncSlice.title === PLAYBACK_EVENT_TITLE) {
                        events.push(asyncSlice);
                    }
                }
            }
        }
        events.sort(tr.importer.compareEvents);
        const protoExpectations = [];
        for (const event of events) {
            const currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.VIDEO);
            currentPE.start = event.start;
            currentPE.end = event.end;
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
        }
        return protoExpectations;
    }

    function handleVrAnimations(modelHelper, sortedInputEvents, warn) {
        const events = [];
        const processes = [];
        if (typeof modelHelper.gpuHelper !== 'undefined') {
            processes.push(modelHelper.gpuHelper.process);
        }
        for (const helper of Object.values(modelHelper.rendererHelpers)) {
            processes.push(helper.process);
        }
        for (const helper of Object.values(modelHelper.browserHelpers)) {
            processes.push(helper.process);
        }
        for (const service of modelHelper.model.getAllProcesses(isXrDeviceServiceProcess)) {
            processes.push(service);
        }
        let vrCounterStart = Number.MAX_SAFE_INTEGER;
        let vrEventStart = Number.MAX_SAFE_INTEGER;
        for (const proc of processes) {
            for (const [counterName, counterSeries] of
                Object.entries(proc.counters)) {
                if (VR_COUNTER_NAMES.includes(counterName)) {
                    for (const series of counterSeries.series) {
                        for (const sample of series.samples) {
                            events.push(sample);
                            vrCounterStart = Math.min(vrCounterStart, sample.timestamp);
                        }
                    }
                }
            }
            for (const thread of Object.values(proc.threads)) {
                for (const container of thread.childEventContainers()) {
                    for (const slice of container.slices) {
                        if (slice.title in VR_EXPECTATION_EVENTS || slice.title in WEBXR_INSTANT_EVENTS) {
                            events.push(slice);
                            vrEventStart = Math.min(vrEventStart, slice.start);
                        }
                    }
                }
            }
        }
        if (events.length === 0) {
            return [];
        }
        events.sort(function (x, y) {
            if (x.range.min !== y.range.min) {
                return x.range.min - y.range.min;
            }
            return x.guid - y.guid;
        });
        vrCounterStart = (vrCounterStart === Number.MAX_SAFE_INTEGER) ? 0 : vrCounterStart;
        vrEventStart = (vrEventStart === Number.MAX_SAFE_INTEGER) ? 0 : vrEventStart;
        const vrAnimationStart = Math.max(vrCounterStart, vrEventStart) +
            VR_RESPONSE_MS;
        const responsePE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.VR);
        const animationPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.VR);
        let lastResponseEvent;
        for (const event of events) {
            if (event.range.min < vrAnimationStart) {
                if (event instanceof tr.model.CounterSample) {
                    responsePE.pushSample(event);
                } else {
                    responsePE.pushEvent(event);
                }
                lastResponseEvent = event;
            } else {
                if (event instanceof tr.model.CounterSample) {
                    animationPE.pushSample(event);
                } else {
                    animationPE.pushEvent(event);
                }
            }
        }
        if (lastResponseEvent instanceof tr.model.CounterSample) {
            animationPE.pushSample(lastResponseEvent);
        } else {
            animationPE.pushEvent(lastResponseEvent);
        }
        return [responsePE, animationPE];
    }

    function handleCSSAnimations(modelHelper, sortedInputEvents, warn) {
        const animationEvents = modelHelper.browserHelper.getAllAsyncSlicesMatching(function (event) {
            return ((event.title === CSS_ANIMATION_TITLE) && event.isTopLevel && (event.duration > 0));
        });
        const animationRanges = [];

        function pushAnimationRange(start, end, animation) {
            const range = tr.b.math.Range.fromExplicitRange(start, end);
            range.animation = animation;
            animationRanges.push(range);
        }

        animationEvents.forEach(function (animation) {
            if (animation.subSlices.length === 0) {
                pushAnimationRange(animation.start, animation.end, animation);
            } else {
                let start = undefined;
                animation.subSlices.forEach(function (sub) {
                    if ((sub.args.data.state === 'running') && (start === undefined)) {
                        start = sub.start;
                    } else if ((sub.args.data.state === 'paused') || (sub.args.data.state === 'idle') || (sub.args.data.state === 'finished')) {
                        if (start === undefined) {
                            start = modelHelper.model.bounds.min;
                        }
                        pushAnimationRange(start, sub.start, animation);
                        start = undefined;
                    }
                });
                if (start !== undefined) {
                    pushAnimationRange(start, animation.end, animation);
                }
            }
        });
        return animationRanges.map(function (range) {
            const protoExpectation = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.CSS);
            protoExpectation.start = range.min;
            protoExpectation.end = range.max;
            protoExpectation.associatedEvents.push(range.animation);
            return protoExpectation;
        });
    }

    function findWebGLEvents(modelHelper, mailboxEvents, animationEvents) {
        for (const event of modelHelper.model.getDescendantEvents()) {
            if (event.title === 'DrawingBuffer::prepareMailbox') {
                mailboxEvents.push(event);
            } else if (event.title === 'PageAnimator::serviceScriptedAnimations') {
                animationEvents.push(event);
            }
        }
    }

    function findMailboxEventsNearAnimationEvents(mailboxEvents, animationEvents) {
        if (animationEvents.length === 0) return [];
        mailboxEvents.sort(compareEvents);
        animationEvents.sort(compareEvents);
        const animationIterator = animationEvents[Symbol.iterator]();
        let animationEvent = animationIterator.next().value;
        const filteredEvents = [];
        for (const event of mailboxEvents) {
            while (animationEvent && (animationEvent.start < (event.start - ANIMATION_MERGE_THRESHOLD_MS))) {
                animationEvent = animationIterator.next().value;
            }
            if (!animationEvent) break;
            if (animationEvent.start < (event.start + ANIMATION_MERGE_THRESHOLD_MS)) {
                filteredEvents.push(event);
            }
        }
        return filteredEvents;
    }

    function createProtoExpectationsFromMailboxEvents(mailboxEvents) {
        const protoExpectations = [];
        let currentPE = undefined;
        for (const event of mailboxEvents) {
            if (currentPE === undefined || !currentPE.isNear(event, ANIMATION_MERGE_THRESHOLD_MS)) {
                currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.WEBGL);
                currentPE.pushEvent(event);
                protoExpectations.push(currentPE);
            } else {
                currentPE.pushEvent(event);
            }
        }
        return protoExpectations;
    }

    function handleWebGLAnimations(modelHelper, sortedInputEvents, warn) {
        const prepareMailboxEvents = [];
        const scriptedAnimationEvents = [];
        findWebGLEvents(modelHelper, prepareMailboxEvents, scriptedAnimationEvents);
        const webGLMailboxEvents = findMailboxEventsNearAnimationEvents(prepareMailboxEvents, scriptedAnimationEvents);
        return createProtoExpectationsFromMailboxEvents(webGLMailboxEvents);
    }

    function postProcessProtoExpectations(modelHelper, protoExpectations) {
        protoExpectations = findFrameEventsForAnimations(modelHelper, protoExpectations);
        protoExpectations = mergeIntersectingResponses(protoExpectations);
        protoExpectations = mergeIntersectingAnimations(protoExpectations);
        protoExpectations = fixResponseAnimationStarts(protoExpectations);
        protoExpectations = fixTapResponseTouchAnimations(protoExpectations);
        return protoExpectations;
    }

    function mergeIntersectingResponses(protoExpectations) {
        const newPEs = [];
        while (protoExpectations.length) {
            const pe = protoExpectations.shift();
            newPEs.push(pe);
            if (pe.type !== ProtoExpectation.RESPONSE_TYPE) continue;
            for (let i = 0; i < protoExpectations.length; ++i) {
                const otherPE = protoExpectations[i];
                if (otherPE.type !== pe.type) continue;
                if (!otherPE.intersects(pe)) continue;
                const typeNames = pe.associatedEvents.map(function (event) {
                    return event.typeName;
                });
                if (otherPE.containsTypeNames(typeNames)) continue;
                pe.merge(otherPE);
                protoExpectations.splice(i, 1);
                --i;
            }
        }
        return newPEs;
    }

    function mergeIntersectingAnimations(protoExpectations) {
        const newPEs = [];
        while (protoExpectations.length) {
            const pe = protoExpectations.shift();
            newPEs.push(pe);
            if (pe.type !== ProtoExpectation.ANIMATION_TYPE) continue;
            const isCSS = pe.initiatorType === INITIATOR_TYPE.CSS;
            const isFling = pe.containsTypeNames([INPUT_TYPE.FLING_START]);
            const isVideo = pe.initiatorType === INITIATOR_TYPE.VIDEO;
            for (let i = 0; i < protoExpectations.length; ++i) {
                const otherPE = protoExpectations[i];
                if (otherPE.type !== pe.type) continue;
                if ((isCSS && otherPE.initiatorType !== INITIATOR_TYPE.CSS) || isFling !== otherPE.containsTypeNames([INPUT_TYPE.FLING_START]) || isVideo && otherPE.initiatorType !== INITIATOR_TYPE.VIDEO || otherPE.initiatorType === INITIATOR_TYPE.VR) {
                    continue;
                }
                if (isCSS) {
                    if (!pe.isNear(otherPE, ANIMATION_MERGE_THRESHOLD_MS)) {
                        continue;
                    }
                } else if (!otherPE.intersects(pe)) {
                    continue;
                }
                pe.merge(otherPE);
                protoExpectations.splice(i, 1);
                --i;
            }
        }
        return newPEs;
    }

    function fixResponseAnimationStarts(protoExpectations) {
        protoExpectations.forEach(function (ape) {
            if (ape.type !== ProtoExpectation.ANIMATION_TYPE) {
                return;
            }
            protoExpectations.forEach(function (rpe) {
                if (rpe.type !== ProtoExpectation.RESPONSE_TYPE) {
                    return;
                }
                if (!ape.containsTimestampInclusive(rpe.end)) {
                    return;
                }
                if (ape.containsTimestampInclusive(rpe.start)) {
                    return;
                }
                ape.start = rpe.end;
                if (ape.associatedEvents !== undefined) {
                    ape.associatedEvents = ape.associatedEvents.filter(e => (!isImplFrameEvent(e) || e.start >= ape.start));
                }
            });
        });
        return protoExpectations;
    }

    function isImplFrameEvent(event) {
        return event.title === tr.model.helpers.IMPL_RENDERING_STATS;
    }

    function fixTapResponseTouchAnimations(protoExpectations) {
        function isTapResponse(pe) {
            return (pe.type === ProtoExpectation.RESPONSE_TYPE) && pe.containsTypeNames([INPUT_TYPE.TAP]);
        }

        function isTouchAnimation(pe) {
            return (pe.type === ProtoExpectation.ANIMATION_TYPE) && pe.containsTypeNames([INPUT_TYPE.TOUCH_MOVE]) && !pe.containsTypeNames([INPUT_TYPE.SCROLL_UPDATE, INPUT_TYPE.PINCH_UPDATE]);
        }

        const newPEs = [];
        while (protoExpectations.length) {
            const pe = protoExpectations.shift();
            newPEs.push(pe);
            const peIsTapResponse = isTapResponse(pe);
            const peIsTouchAnimation = isTouchAnimation(pe);
            if (!peIsTapResponse && !peIsTouchAnimation) {
                continue;
            }
            for (let i = 0; i < protoExpectations.length; ++i) {
                const otherPE = protoExpectations[i];
                if (!otherPE.intersects(pe)) continue;
                if (peIsTapResponse && !isTouchAnimation(otherPE)) continue;
                if (peIsTouchAnimation && !isTapResponse(otherPE)) continue;
                pe.type = ProtoExpectation.RESPONSE_TYPE;
                pe.merge(otherPE);
                protoExpectations.splice(i, 1);
                --i;
            }
        }
        return newPEs;
    }

    function findFrameEventsForAnimations(modelHelper, protoExpectations) {
        const newPEs = [];
        const frameEventsByPid = getSortedFrameEventsByProcess(modelHelper);
        for (const pe of protoExpectations) {
            if (pe.type !== ProtoExpectation.ANIMATION_TYPE) {
                newPEs.push(pe);
                continue;
            }
            const frameEvents = [];
            for (const pid of Object.keys(modelHelper.rendererHelpers)) {
                const range = tr.b.math.Range.fromExplicitRange(pe.start, pe.end);
                frameEvents.push.apply(frameEvents, range.filterArray(frameEventsByPid[pid], e => e.start));
            }
            if (frameEvents.length === 0 && !(pe.initiatorType === INITIATOR_TYPE.WEBGL || pe.initiatorType === INITIATOR_TYPE.VR)) {
                pe.type = ProtoExpectation.IGNORED_TYPE;
                newPEs.push(pe);
                continue;
            }
            pe.associatedEvents.addEventSet(frameEvents);
            newPEs.push(pe);
        }
        return newPEs;
    }

    function checkAllInputEventsHandled(modelHelper, sortedInputEvents, protoExpectations, warn) {
        const handledEvents = [];
        protoExpectations.forEach(function (protoExpectation) {
            protoExpectation.associatedEvents.forEach(function (event) {
                if ((event.title === CSS_ANIMATION_TITLE) && (event.subSlices.length > 0)) {
                    return;
                }
                if ((handledEvents.indexOf(event) >= 0) && (!isImplFrameEvent(event))) {
                    warn({
                        type: 'UserModelBuilder',
                        message: `double-handled event: ${event.typeName} @ ${event.start}`,
                        showToUser: false,
                    });
                    return;
                }
                handledEvents.push(event);
            });
        });
        sortedInputEvents.forEach(function (event) {
            if (handledEvents.indexOf(event) < 0) {
                warn({
                    type: 'UserModelBuilder',
                    message: `double-handled event: ${event.typeName} @ ${event.start}`,
                    showToUser: false,
                });
            }
        });
    }

    function findInputExpectations(modelHelper) {
        let warning;

        function warn(w) {
            if (warning) return;
            warning = w;
        }

        const sortedInputEvents = getSortedInputEvents(modelHelper);
        let protoExpectations = findProtoExpectations(modelHelper, sortedInputEvents, warn);
        protoExpectations = postProcessProtoExpectations(modelHelper, protoExpectations);
        checkAllInputEventsHandled(modelHelper, sortedInputEvents, protoExpectations, warn);
        if (warning) modelHelper.model.importWarning(warning);
        const expectations = [];
        protoExpectations.forEach(function (protoExpectation) {
            const ir = protoExpectation.createInteractionRecord(modelHelper.model);
            if (ir) {
                expectations.push(ir);
            }
        });
        return expectations;
    }

    return {
        findInputExpectations,
        compareEvents,
        CSS_ANIMATION_TITLE,
        VR_EXPECTATION_EVENTS,
        WEBXR_INSTANT_EVENTS,
    };
});
'use strict';
tr.exportTo('tr.b', function () {
    class FixedColorScheme {
        constructor(namesToColors) {
            this.namesToColors_ = namesToColors;
        }

        static fromNames(names) {
            const namesToColors = new Map();
            const generator = new tr.b.SinebowColorGenerator();
            for (const name of names) {
                namesToColors.set(name, generator.colorForKey(name));
            }
            return new FixedColorScheme(namesToColors);
        }

        getColor(name) {
            const color = this.namesToColors_.get(name);
            if (color === undefined) throw new Error('Unknown color: ' + name);
            return color;
        }
    }

    const MemoryColumnColorScheme = new FixedColorScheme(new Map([['used_memory_column', new tr.b.Color(0, 0, 255)], ['older_used_memory_column', new tr.b.Color(153, 204, 255)], ['tracing_memory_column', new tr.b.Color(153, 153, 153)]]));

    function FixedColorSchemeRegistry() {
    }

    FixedColorSchemeRegistry.lookUp = function (name) {
        const info = this.findTypeInfoMatching(info => info.metadata.name === name);
        if (!info) return undefined;
        return info.constructor();
    };
    const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
    tr.b.decorateExtensionRegistry(FixedColorSchemeRegistry, options);
    return {MemoryColumnColorScheme, FixedColorScheme, FixedColorSchemeRegistry,};
});
'use strict';
tr.exportTo('tr.e.chrome.chrome_processes', function () {
    const CHROME_PROCESS_NAMES = {
        BROWSER: 'browser_process',
        RENDERER: 'renderer_processes',
        ALL: 'all_processes',
        GPU: 'gpu_process',
        PPAPI: 'ppapi_process',
        UNKNOWN: 'unknown_processes',
    };
    const PROCESS_COLOR_SCHEME_NAME = 'ChromeProcessNames';
    const PROCESS_COLOR_SCHEME = tr.b.FixedColorScheme.fromNames(Object.values(CHROME_PROCESS_NAMES));
    tr.b.FixedColorSchemeRegistry.register(() => PROCESS_COLOR_SCHEME, {name: PROCESS_COLOR_SCHEME_NAME,});

    function canonicalizeName(name) {
        return name.toLowerCase().replace(' ', '_');
    }

    function canonicalizeProcessName(rawProcessName) {
        if (!rawProcessName) return CHROME_PROCESS_NAMES.UNKNOWN;
        const baseCanonicalName = canonicalizeName(rawProcessName);
        switch (baseCanonicalName) {
            case'renderer':
                return CHROME_PROCESS_NAMES.RENDERER;
            case'browser':
                return CHROME_PROCESS_NAMES.BROWSER;
        }
        if (Object.values(CHROME_PROCESS_NAMES).includes(baseCanonicalName)) {
            return baseCanonicalName;
        }
        return CHROME_PROCESS_NAMES.UNKNOWN;
    }

    return {
        CHROME_PROCESS_NAMES,
        PROCESS_COLOR_SCHEME,
        PROCESS_COLOR_SCHEME_NAME,
        canonicalizeName,
        canonicalizeProcessName,
    };
});
'use strict';
tr.exportTo('tr.metrics.sh', function () {
    function perceptualBlend(ir, index, score) {
        return Math.exp(1 - score);
    }

    function filterExpectationsByRange(irs, opt_range) {
        const filteredExpectations = [];
        irs.forEach(function (ir) {
            if (!(ir instanceof tr.model.um.UserExpectation)) return;
            if (!opt_range || opt_range.intersectsExplicitRangeInclusive(ir.start, ir.end)) {
                filteredExpectations.push(ir);
            }
        });
        return filteredExpectations;
    }

    function splitGlobalDumpsByBrowserName(model, opt_rangeOfInterest) {
        const chromeModelHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
        const browserNameToGlobalDumps = new Map();
        const globalDumpToBrowserHelper = new WeakMap();
        if (chromeModelHelper) {
            chromeModelHelper.browserHelpers.forEach(function (helper) {
                const globalDumps = skipDumpsThatDoNotIntersectRange(helper.process.memoryDumps.map(d => d.globalMemoryDump), opt_rangeOfInterest);
                globalDumps.forEach(function (globalDump) {
                    const existingHelper = globalDumpToBrowserHelper.get(globalDump);
                    if (existingHelper !== undefined) {
                        throw new Error('Memory dump ID clash across multiple browsers ' + 'with PIDs: ' + existingHelper.pid + ' and ' + helper.pid);
                    }
                    globalDumpToBrowserHelper.set(globalDump, helper);
                });
                makeKeyUniqueAndSet(browserNameToGlobalDumps, tr.e.chrome.chrome_processes.canonicalizeName(helper.browserName), globalDumps);
            });
        }
        const unclassifiedGlobalDumps = skipDumpsThatDoNotIntersectRange(model.globalMemoryDumps.filter(g => !globalDumpToBrowserHelper.has(g)), opt_rangeOfInterest);
        if (unclassifiedGlobalDumps.length > 0) {
            makeKeyUniqueAndSet(browserNameToGlobalDumps, 'unknown_browser', unclassifiedGlobalDumps);
        }
        return browserNameToGlobalDumps;
    }

    function makeKeyUniqueAndSet(map, key, value) {
        let uniqueKey = key;
        let nextIndex = 2;
        while (map.has(uniqueKey)) {
            uniqueKey = key + nextIndex;
            nextIndex++;
        }
        map.set(uniqueKey, value);
    }

    function skipDumpsThatDoNotIntersectRange(dumps, opt_range) {
        if (!opt_range) return dumps;
        return dumps.filter(d => opt_range.intersectsExplicitRangeInclusive(d.start, d.end));
    }

    function hasCategoryAndName(event, category, title) {
        return event.title === title && event.category && tr.b.getCategoryParts(event.category).includes(category);
    }

    return {hasCategoryAndName, filterExpectationsByRange, perceptualBlend, splitGlobalDumpsByBrowserName};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const CHROME_INTERNAL_URLS = ['', 'about:blank', 'data:text/html,pluginplaceholderdata', 'chrome-error://chromewebdata/'];
    const SCHEDULER_TOP_LEVEL_TASK_TITLE = 'ThreadControllerImpl::RunTask';
    const SCHEDULER_TOP_LEVEL_TASKS = new Set([SCHEDULER_TOP_LEVEL_TASK_TITLE, 'ThreadControllerImpl::DoWork', 'TaskQueueManager::ProcessTaskFromWorkQueue']);

    class EventFinderUtils {
        static hasCategoryAndName(event, category, title) {
            return event.title === title && event.category && tr.b.getCategoryParts(event.category).includes(category);
        }

        static* getMainThreadEvents(rendererHelper, eventTitle, eventCategory) {
            if (!rendererHelper.mainThread) return;
            for (const ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
                if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
                if (!this.hasCategoryAndName(ev, eventCategory, eventTitle)) {
                    continue;
                }
                yield ev;
            }
        }

        static getNetworkEventsInRange(process, range) {
            const networkEvents = [];
            for (const thread of Object.values(process.threads)) {
                const threadHelper = new tr.model.helpers.ChromeThreadHelper(thread);
                const events = threadHelper.getNetworkEvents();
                for (const event of events) {
                    if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
                        networkEvents.push(event);
                    }
                }
            }
            return networkEvents;
        }

        static getSortedMainThreadEventsByFrame(rendererHelper, eventTitle, eventCategory) {
            const eventsByFrame = new Map();
            const events = this.getMainThreadEvents(rendererHelper, eventTitle, eventCategory);
            for (const ev of events) {
                const frameIdRef = ev.args.frame;
                if (frameIdRef === undefined) continue;
                if (!eventsByFrame.has(frameIdRef)) {
                    eventsByFrame.set(frameIdRef, []);
                }
                eventsByFrame.get(frameIdRef).push(ev);
            }
            return eventsByFrame;
        }

        static getSortedMainThreadEventsByNavId(rendererHelper, eventTitle, eventCategory) {
            const eventsByNavId = new Map();
            const events = this.getMainThreadEvents(rendererHelper, eventTitle, eventCategory);
            for (const ev of events) {
                if (ev.args.data === undefined) continue;
                const navIdRef = ev.args.data.navigationId;
                if (navIdRef === undefined) continue;
                eventsByNavId.set(navIdRef, ev);
            }
            return eventsByNavId;
        }

        static findLastEventStartingOnOrBeforeTimestamp(sortedEvents, timestamp) {
            const firstIndexAfterTimestamp = tr.b.findFirstTrueIndexInSortedArray(sortedEvents, e => e.start > timestamp);
            if (firstIndexAfterTimestamp === 0) return undefined;
            return sortedEvents[firstIndexAfterTimestamp - 1];
        }

        static findLastEventStartingBeforeTimestamp(sortedEvents, timestamp) {
            const firstIndexAfterTimestamp = tr.b.findFirstTrueIndexInSortedArray(sortedEvents, e => e.start >= timestamp);
            if (firstIndexAfterTimestamp === 0) return undefined;
            return sortedEvents[firstIndexAfterTimestamp - 1];
        }

        static findNextEventStartingOnOrAfterTimestamp(sortedEvents, timestamp) {
            const firstIndexOnOrAfterTimestamp = tr.b.findFirstTrueIndexInSortedArray(sortedEvents, e => e.start >= timestamp);
            if (firstIndexOnOrAfterTimestamp === sortedEvents.length) {
                return undefined;
            }
            return sortedEvents[firstIndexOnOrAfterTimestamp];
        }

        static findNextEventStartingAfterTimestamp(sortedEvents, timestamp) {
            const firstIndexOnOrAfterTimestamp = tr.b.findFirstTrueIndexInSortedArray(sortedEvents, e => e.start > timestamp);
            if (firstIndexOnOrAfterTimestamp === sortedEvents.length) {
                return undefined;
            }
            return sortedEvents[firstIndexOnOrAfterTimestamp];
        }

        static findToplevelSchedulerTasks(mainThread) {
            const tasks = [];
            for (const task of mainThread.findTopmostSlices(slice => slice.category === 'toplevel' && SCHEDULER_TOP_LEVEL_TASKS.has(slice.title))) {
                tasks.push(task);
            }
            return tasks;
        }
    }

    return {EventFinderUtils, CHROME_INTERNAL_URLS, SCHEDULER_TOP_LEVEL_TASK_TITLE,};
});
'use strict';
tr.exportTo('tr.e.chrome', function () {
    const TIME_TO_INTERACTIVE_WINDOW_SIZE_MS = 5000;
    const ACTIVE_REQUEST_TOLERANCE = 2;
    const FCI_MIN_CLUSTER_SEPARATION_MS = 1000;
    const TASK_CLUSTER_HEAVINESS_THRESHOLD_MS = 250;
    const ENDPOINT_TYPES = {
        LONG_TASK_START: 'LONG_TASK_START',
        LONG_TASK_END: 'LONG_TASK_END',
        REQUEST_START: 'REQUEST_START',
        REQUEST_END: 'REQUEST_END'
    };

    function getEndpoints_(events, startType, endType) {
        const endpoints = [];
        for (const event of events) {
            endpoints.push({time: event.start, type: startType});
            endpoints.push({time: event.end, type: endType});
        }
        return endpoints;
    }

    function reachedTTIQuiscence_(timestamp, networkQuietWindowStart, mainThreadQuietWindowStart) {
        if (networkQuietWindowStart === undefined || mainThreadQuietWindowStart === undefined) {
            return false;
        }
        const mainThreadQuietForLongEnough = timestamp - mainThreadQuietWindowStart >= TIME_TO_INTERACTIVE_WINDOW_SIZE_MS;
        const networkQuietForLongEnough = timestamp - networkQuietWindowStart >= TIME_TO_INTERACTIVE_WINDOW_SIZE_MS;
        return mainThreadQuietForLongEnough && networkQuietForLongEnough;
    }

    function findInteractiveTime(searchBegin, searchEnd, domContentLoadedEnd, longTasksInWindow, networkRequests) {
        const longTaskEndpoints = getEndpoints_(longTasksInWindow, ENDPOINT_TYPES.LONG_TASK_START, ENDPOINT_TYPES.LONG_TASK_END);
        const networkRequestEndpoints = getEndpoints_(networkRequests, ENDPOINT_TYPES.REQUEST_START, ENDPOINT_TYPES.REQUEST_END);
        const endpoints = longTaskEndpoints.concat(networkRequestEndpoints);
        endpoints.sort((a, b) => a.time - b.time);
        let networkQuietWindowStart = searchBegin;
        let mainThreadQuietWindowStart = searchBegin;
        let interactiveCandidate = undefined;
        let activeRequests = 0;
        for (const endpoint of endpoints) {
            if (reachedTTIQuiscence_(endpoint.time, networkQuietWindowStart, mainThreadQuietWindowStart)) {
                interactiveCandidate = mainThreadQuietWindowStart;
                break;
            }
            switch (endpoint.type) {
                case ENDPOINT_TYPES.LONG_TASK_START:
                    mainThreadQuietWindowStart = undefined;
                    break;
                case ENDPOINT_TYPES.LONG_TASK_END:
                    mainThreadQuietWindowStart = endpoint.time;
                    break;
                case ENDPOINT_TYPES.REQUEST_START:
                    activeRequests++;
                    if (activeRequests > ACTIVE_REQUEST_TOLERANCE) {
                        networkQuietWindowStart = undefined;
                    }
                    break;
                case ENDPOINT_TYPES.REQUEST_END:
                    activeRequests--;
                    if (activeRequests === ACTIVE_REQUEST_TOLERANCE) {
                        networkQuietWindowStart = endpoint.time;
                    }
                    break;
                default:
                    throw new Error('Internal Error: Unhandled endpoint type.');
            }
        }
        if (interactiveCandidate === undefined && reachedTTIQuiscence_(searchEnd, networkQuietWindowStart, mainThreadQuietWindowStart)) {
            interactiveCandidate = mainThreadQuietWindowStart;
        }
        if (interactiveCandidate === undefined) return undefined;
        return Math.max(interactiveCandidate, domContentLoadedEnd);
    }

    function requiredFCIWindowSizeMs(timeSinceSearchBeginMs) {
        const timeCoefficient = 1 / 15 * Math.log(2);
        const timeSinceSearchBeginSeconds = tr.b.convertUnit(timeSinceSearchBeginMs, tr.b.UnitPrefixScale.METRIC.MILLI, tr.b.UnitPrefixScale.METRIC.NONE);
        const windowSizeSeconds = 4 * Math.exp(-timeCoefficient * timeSinceSearchBeginSeconds) + 1;
        return tr.b.convertUnit(windowSizeSeconds, tr.b.UnitPrefixScale.METRIC.NONE, tr.b.UnitPrefixScale.METRIC.MILLI);
    }

    class TaskCluster {
        constructor(tasksInClusterSorted) {
            if (tasksInClusterSorted.length === 0) {
                throw new Error('Internal Error: TaskCluster must have non zero tasks');
            }
            for (let i = 0; i < tasksInClusterSorted.length - 1; i++) {
                const durationBetweenTasks = tasksInClusterSorted[i + 1].start -
                    tasksInClusterSorted[i].end;
                if (durationBetweenTasks >= FCI_MIN_CLUSTER_SEPARATION_MS) {
                    throw new Error('Internal Error: Tasks in a TaskCluster cannot be ' + 'more than ' + FCI_MIN_CLUSTER_SEPARATION_MS + ' miliseconds apart');
                }
                if (durationBetweenTasks < -1e7) {
                    throw new Error('Internal Error: List of tasks used to construct ' + 'TaskCluster must be sorted.');
                }
            }
            this._clusterTasks = tasksInClusterSorted;
        }

        get start() {
            return this._clusterTasks[0].start;
        }

        get end() {
            return this._clusterTasks[this._clusterTasks.length - 1].end;
        }

        isHeavy() {
            return this.end - this.start > TASK_CLUSTER_HEAVINESS_THRESHOLD_MS;
        }
    }

    function findFCITaskClusters(sortedLongTasks) {
        const clusters = [];
        if (sortedLongTasks.length === 0) return clusters;
        const firstTask = sortedLongTasks[0];
        const restOfTasks = sortedLongTasks.slice(1);
        let currentClusterTasks = [firstTask];
        for (const currTask of restOfTasks) {
            const prevTask = currentClusterTasks[currentClusterTasks.length - 1];
            if (currTask.start - prevTask.end < FCI_MIN_CLUSTER_SEPARATION_MS) {
                currentClusterTasks.push(currTask);
            } else {
                clusters.push(new TaskCluster(currentClusterTasks));
                currentClusterTasks = [currTask];
            }
        }
        clusters.push(new TaskCluster(currentClusterTasks));
        return clusters;
    }

    function reachedFCIQuiescence_(timestamp, mainThreadQuietWindowStart, searchBegin) {
        const quietWindowSize = timestamp - mainThreadQuietWindowStart;
        const timeSinceSearchBegin = mainThreadQuietWindowStart - searchBegin;
        const requiredWindowSize = requiredFCIWindowSizeMs(timeSinceSearchBegin);
        return quietWindowSize > requiredWindowSize;
    }

    function findFirstCpuIdleTime(searchBegin, searchEnd, domContentLoadedEnd, longTasksInWindow) {
        const sortedLongTasks = longTasksInWindow.sort((a, b) => a.start - b.start);
        const taskClusters = findFCITaskClusters(sortedLongTasks);
        const heavyTaskClusters = taskClusters.filter(cluster => cluster.isHeavy());
        let quietWindowBegin = searchBegin;
        let fiCandidate = undefined;
        for (const cluster of heavyTaskClusters) {
            if (reachedFCIQuiescence_(cluster.start, quietWindowBegin, searchBegin)) {
                fiCandidate = quietWindowBegin;
                break;
            }
            quietWindowBegin = cluster.end;
        }
        if (fiCandidate === undefined) {
            if (reachedFCIQuiescence_(searchEnd, quietWindowBegin, searchBegin)) {
                fiCandidate = quietWindowBegin;
            } else {
                return undefined;
            }
        }
        return Math.max(fiCandidate, domContentLoadedEnd);
    }

    return {findInteractiveTime, findFirstCpuIdleTime, requiredFCIWindowSizeMs, findFCITaskClusters,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    const LOAD_SUBTYPE_NAMES = {SUCCESSFUL: 'Successful', FAILED: 'Failed',};
    const DOES_LOAD_SUBTYPE_NAME_EXIST = {};
    for (const key in LOAD_SUBTYPE_NAMES) {
        DOES_LOAD_SUBTYPE_NAME_EXIST[LOAD_SUBTYPE_NAMES[key]] = true;
    }

    function LoadExpectation(parentModel, initiatorTitle, start, duration, renderer, navigationStart, fmpEvent, dclEndEvent, cpuIdleTime, timeToInteractive, url, frameId) {
        if (!DOES_LOAD_SUBTYPE_NAME_EXIST[initiatorTitle]) {
            throw new Error(initiatorTitle + ' is not in LOAD_SUBTYPE_NAMES');
        }
        tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
        this.renderProcess = renderer;
        this.renderMainThread = undefined;
        this.routingId = undefined;
        this.parentRoutingId = undefined;
        this.loadFinishedEvent = undefined;
        this.navigationStart = navigationStart;
        this.fmpEvent = fmpEvent;
        this.domContentLoadedEndEvent = dclEndEvent;
        this.firstCpuIdleTime = cpuIdleTime;
        this.timeToInteractive = timeToInteractive;
        this.url = url;
        this.frameId = frameId;
    }

    LoadExpectation.prototype = {__proto__: tr.model.um.UserExpectation.prototype, constructor: LoadExpectation};
    tr.model.um.UserExpectation.subTypes.register(LoadExpectation, {
        stageTitle: 'Load',
        colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_load')
    });
    return {LOAD_SUBTYPE_NAMES, LoadExpectation,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    const LONG_TASK_THRESHOLD_MS = 50;
    const IGNORE_URLS = ['', 'about:blank',];

    function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
        const objects = rendererHelper.process.objects;
        const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
        if (frameLoaderInstances === undefined) return undefined;
        let snapshot;
        for (const instance of frameLoaderInstances) {
            if (!instance.isAliveAt(ts)) continue;
            const maybeSnapshot = instance.getSnapshotAt(ts);
            if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
            snapshot = maybeSnapshot;
        }
        return snapshot;
    }

    function findFirstMeaningfulPaintCandidates(rendererHelper) {
        const candidatesForFrameId = {};
        for (const ev of rendererHelper.process.getDescendantEvents()) {
            if (!tr.e.chrome.EventFinderUtils.hasCategoryAndName(ev, 'loading', 'firstMeaningfulPaintCandidate')) {
                continue;
            }
            if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
            const frameIdRef = ev.args.frame;
            if (frameIdRef === undefined) continue;
            let list = candidatesForFrameId[frameIdRef];
            if (list === undefined) {
                candidatesForFrameId[frameIdRef] = list = [];
            }
            list.push(ev);
        }
        return candidatesForFrameId;
    }

    function computeInteractivityMetricSample_(rendererHelper, navigationStart, fmpEvent, domContentLoadedEndEvent, searchWindowEnd) {
        if (domContentLoadedEndEvent === undefined || fmpEvent === undefined) {
            return {interactiveTime: undefined, firstCpuIdleTime: undefined};
        }
        const firstMeaningfulPaintTime = fmpEvent.start;
        const mainThreadTasks = tr.e.chrome.EventFinderUtils.findToplevelSchedulerTasks(rendererHelper.mainThread);
        const longTasks = mainThreadTasks.filter(task => task.duration >= LONG_TASK_THRESHOLD_MS);
        const longTasksInWindow = longTasks.filter(task => task.range.intersectsExplicitRangeInclusive(firstMeaningfulPaintTime, searchWindowEnd));
        const resourceLoadEvents = tr.e.chrome.EventFinderUtils.getNetworkEventsInRange(rendererHelper.process, tr.b.math.Range.fromExplicitRange(navigationStart.start, searchWindowEnd));
        const firstCpuIdleTime = tr.e.chrome.findFirstCpuIdleTime(firstMeaningfulPaintTime, searchWindowEnd, domContentLoadedEndEvent.start, longTasksInWindow);
        const interactiveTime = resourceLoadEvents.length > 0 ? tr.e.chrome.findInteractiveTime(firstMeaningfulPaintTime, searchWindowEnd, domContentLoadedEndEvent.start, longTasksInWindow, resourceLoadEvents) : undefined;
        return {interactiveTime, firstCpuIdleTime};
    }

    function constructLoadingExpectation_(rendererHelper, frameToDomContentLoadedEndEvents, navigationStart, fmpEvent, searchWindowEnd, url, frameId) {
        const dclTimesForFrame = frameToDomContentLoadedEndEvents.get(frameId) || [];
        const dclSearchRange = tr.b.math.Range.fromExplicitRange(navigationStart.start, searchWindowEnd);
        const dclTimesInWindow = dclSearchRange.filterArray(dclTimesForFrame, event => event.start);
        let domContentLoadedEndEvent = undefined;
        if (dclTimesInWindow.length !== 0) {
            domContentLoadedEndEvent = dclTimesInWindow[dclTimesInWindow.length - 1];
        }
        const {interactiveTime, firstCpuIdleTime} = computeInteractivityMetricSample_(rendererHelper, navigationStart, fmpEvent, domContentLoadedEndEvent, searchWindowEnd);
        const duration = (interactiveTime === undefined) ? searchWindowEnd - navigationStart.start : interactiveTime - navigationStart.start;
        return new tr.model.um.LoadExpectation(rendererHelper.modelHelper.model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, navigationStart.start, duration, rendererHelper.process, navigationStart, fmpEvent, domContentLoadedEndEvent, firstCpuIdleTime, interactiveTime, url, frameId);
    }

    function collectLoadExpectationsForRenderer(rendererHelper) {
        const samples = [];
        const frameToNavStartEvents = tr.e.chrome.EventFinderUtils.getSortedMainThreadEventsByFrame(rendererHelper, 'navigationStart', 'blink.user_timing');
        const frameToDomContentLoadedEndEvents = tr.e.chrome.EventFinderUtils.getSortedMainThreadEventsByFrame(rendererHelper, 'domContentLoadedEventEnd', 'blink.user_timing');

        function addSamples(frameIdRef, navigationStart, fmpCandidateEvents, searchWindowEnd, url) {
            let fmpMarkerEvent = tr.e.chrome.EventFinderUtils.findLastEventStartingOnOrBeforeTimestamp(fmpCandidateEvents, searchWindowEnd);
            if (fmpMarkerEvent !== undefined && navigationStart.start > fmpMarkerEvent.start) {
                fmpMarkerEvent = undefined;
            }
            samples.push(constructLoadingExpectation_(rendererHelper, frameToDomContentLoadedEndEvents, navigationStart, fmpMarkerEvent, searchWindowEnd, url, frameIdRef));
        }

        const candidatesForFrameId = findFirstMeaningfulPaintCandidates(rendererHelper);
        for (const [frameIdRef, navStartEvents] of frameToNavStartEvents) {
            const fmpCandidateEvents = candidatesForFrameId[frameIdRef] || [];
            let prevNavigation = {navigationEvent: undefined, url: undefined};
            for (let index = 0; index < navStartEvents.length; index++) {
                const currNavigation = navStartEvents[index];
                let url;
                let isLoadingMainFrame = false;
                if (currNavigation.args.data) {
                    url = currNavigation.args.data.documentLoaderURL;
                    isLoadingMainFrame = currNavigation.args.data.isLoadingMainFrame;
                } else {
                    const snapshot = findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, currNavigation.start);
                    if (snapshot) {
                        url = snapshot.args.documentLoaderURL;
                        isLoadingMainFrame = snapshot.args.isLoadingMainFrame;
                    }
                }
                if (!isLoadingMainFrame) continue;
                if (url === undefined || IGNORE_URLS.includes(url)) continue;
                if (prevNavigation.navigationEvent !== undefined) {
                    addSamples(frameIdRef, prevNavigation.navigationEvent, fmpCandidateEvents, currNavigation.start, prevNavigation.url);
                }
                prevNavigation = {navigationEvent: currNavigation, url};
            }
            if (prevNavigation.navigationEvent !== undefined) {
                addSamples(frameIdRef, prevNavigation.navigationEvent, fmpCandidateEvents, rendererHelper.modelHelper.chromeBounds.max, prevNavigation.url);
            }
        }
        return samples;
    }

    function findLoadExpectations(modelHelper) {
        const loads = [];
        const chromeHelper = modelHelper.model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
        for (const pid in chromeHelper.rendererHelpers) {
            const rendererHelper = chromeHelper.rendererHelpers[pid];
            if (rendererHelper.isChromeTracingUI) continue;
            loads.push.apply(loads, collectLoadExpectationsForRenderer(rendererHelper));
        }
        return loads;
    }

    return {findLoadExpectations,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    function StartupExpectation(parentModel, start, duration) {
        tr.model.um.UserExpectation.call(this, parentModel, '', start, duration);
    }

    StartupExpectation.prototype = {
        __proto__: tr.model.um.UserExpectation.prototype,
        constructor: StartupExpectation
    };
    tr.model.um.UserExpectation.subTypes.register(StartupExpectation, {
        stageTitle: 'Startup',
        colorId: tr.b.ColorScheme.getColorIdForReservedName('startup')
    });
    return {StartupExpectation,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    function getAllFrameEvents(modelHelper) {
        const frameEvents = [];
        frameEvents.push.apply(frameEvents, modelHelper.browserHelper.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds));
        for (const renderer of Object.values(modelHelper.rendererHelpers)) {
            frameEvents.push.apply(frameEvents, renderer.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds));
        }
        return frameEvents.sort(tr.importer.compareEvents);
    }

    function getStartupEvents(modelHelper) {
        function isStartupSlice(slice) {
            return slice.title === 'BrowserMainLoop::CreateThreads';
        }

        const events = modelHelper.browserHelper.getAllAsyncSlicesMatching(isStartupSlice);
        const deduper = new tr.model.EventSet();
        events.forEach(function (event) {
            const sliceGroup = event.parentContainer.sliceGroup;
            const slice = sliceGroup && sliceGroup.findFirstSlice();
            if (slice) {
                deduper.push(slice);
            }
        });
        return deduper.toArray();
    }

    function findStartupExpectations(modelHelper) {
        const openingEvents = getStartupEvents(modelHelper);
        const closingEvents = getAllFrameEvents(modelHelper);
        const startups = [];
        openingEvents.forEach(function (openingEvent) {
            closingEvents.forEach(function (closingEvent) {
                if (openingEvent.closingEvent) return;
                if (closingEvent.openingEvent) return;
                if (closingEvent.start <= openingEvent.start) return;
                if (openingEvent.parentContainer.parent.pid !== closingEvent.parentContainer.parent.pid) {
                    return;
                }
                openingEvent.closingEvent = closingEvent;
                closingEvent.openingEvent = openingEvent;
                const se = new tr.model.um.StartupExpectation(modelHelper.model, openingEvent.start, closingEvent.end - openingEvent.start);
                se.associatedEvents.push(openingEvent);
                se.associatedEvents.push(closingEvent);
                startups.push(se);
            });
        });
        return startups;
    }

    return {findStartupExpectations,};
});
'use strict';
tr.exportTo('tr.model', function () {
    function getAssociatedEvents(irs) {
        const allAssociatedEvents = new tr.model.EventSet();
        irs.forEach(function (ir) {
            ir.associatedEvents.forEach(function (event) {
                if (event instanceof tr.model.FlowEvent) return;
                allAssociatedEvents.push(event);
            });
        });
        return allAssociatedEvents;
    }

    function getUnassociatedEvents(model, associatedEvents) {
        const unassociatedEvents = new tr.model.EventSet();
        for (const proc of model.getAllProcesses()) {
            for (const thread of Object.values(proc.threads)) {
                for (const event of thread.sliceGroup.getDescendantEvents()) {
                    if (!associatedEvents.contains(event)) {
                        unassociatedEvents.push(event);
                    }
                }
            }
        }
        return unassociatedEvents;
    }

    function getTotalCpuDuration(events) {
        let cpuMs = 0;
        events.forEach(function (event) {
            if (event.cpuSelfTime) {
                cpuMs += event.cpuSelfTime;
            }
        });
        return cpuMs;
    }

    function getIRCoverageFromModel(model) {
        const associatedEvents = getAssociatedEvents(model.userModel.expectations);
        if (!associatedEvents.length) return undefined;
        const unassociatedEvents = getUnassociatedEvents(model, associatedEvents);
        const associatedCpuMs = getTotalCpuDuration(associatedEvents);
        const unassociatedCpuMs = getTotalCpuDuration(unassociatedEvents);
        const totalEventCount = associatedEvents.length + unassociatedEvents.length;
        const totalCpuMs = associatedCpuMs + unassociatedCpuMs;
        let coveredEventsCpuTimeRatio = undefined;
        if (totalCpuMs !== 0) {
            coveredEventsCpuTimeRatio = associatedCpuMs / totalCpuMs;
        }
        return {
            associatedEventsCount: associatedEvents.length,
            unassociatedEventsCount: unassociatedEvents.length,
            associatedEventsCpuTimeMs: associatedCpuMs,
            unassociatedEventsCpuTimeMs: unassociatedCpuMs,
            coveredEventsCountRatio: associatedEvents.length / totalEventCount,
            coveredEventsCpuTimeRatio
        };
    }

    return {getIRCoverageFromModel, getAssociatedEvents, getUnassociatedEvents,};
});
'use strict';
tr.exportTo('tr.model.um', function () {
    function IdleExpectation(parentModel, start, duration) {
        const initiatorTitle = '';
        tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
    }

    IdleExpectation.prototype = {__proto__: tr.model.um.UserExpectation.prototype, constructor: IdleExpectation};
    tr.model.um.UserExpectation.subTypes.register(IdleExpectation, {
        stageTitle: 'Idle',
        colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_idle')
    });
    return {IdleExpectation,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    const INSIGNIFICANT_MS = 1;

    class UserModelBuilder {
        constructor(model) {
            this.model = model;
            this.modelHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
        }

        static supportsModelHelper(modelHelper) {
            return modelHelper.browserHelper !== undefined;
        }

        buildUserModel() {
            if (!this.modelHelper || !this.modelHelper.browserHelper) return;
            try {
                for (const ue of this.findUserExpectations()) {
                    this.model.userModel.expectations.push(ue);
                }
                this.model.userModel.segments.push(...this.findSegments());
            } catch (error) {
                this.model.importWarning({type: 'UserModelBuilder', message: error, showToUser: true});
            }
        }

        findSegments() {
            let timestamps = new Set();
            for (const expectation of this.model.userModel.expectations) {
                timestamps.add(expectation.start);
                timestamps.add(expectation.end);
            }
            timestamps = [...timestamps];
            timestamps.sort((x, y) => x - y);
            const segments = [];
            for (let i = 0; i < timestamps.length - 1; ++i) {
                const segment = new tr.model.um.Segment(timestamps[i], timestamps[i + 1] - timestamps[i]);
                segments.push(segment);
                const segmentRange = tr.b.math.Range.fromExplicitRange(segment.start, segment.end);
                for (const expectation of this.model.userModel.expectations) {
                    const expectationRange = tr.b.math.Range.fromExplicitRange(expectation.start, expectation.end);
                    if (segmentRange.intersectsRangeExclusive(expectationRange)) {
                        segment.expectations.push(expectation);
                    }
                }
            }
            return segments;
        }

        findUserExpectations() {
            const expectations = [];
            expectations.push.apply(expectations, tr.importer.findStartupExpectations(this.modelHelper));
            expectations.push.apply(expectations, tr.importer.findLoadExpectations(this.modelHelper));
            expectations.push.apply(expectations, tr.importer.findInputExpectations(this.modelHelper));
            expectations.push.apply(expectations, this.findIdleExpectations(expectations));
            this.collectUnassociatedEvents_(expectations);
            return expectations;
        }

        collectUnassociatedEvents_(expectations) {
            const vacuumUEs = [];
            for (const expectation of expectations) {
                if (expectation instanceof tr.model.um.IdleExpectation || expectation instanceof tr.model.um.LoadExpectation || expectation instanceof tr.model.um.StartupExpectation) {
                    vacuumUEs.push(expectation);
                }
            }
            if (vacuumUEs.length === 0) return;
            const allAssociatedEvents = tr.model.getAssociatedEvents(expectations);
            const unassociatedEvents = tr.model.getUnassociatedEvents(this.model, allAssociatedEvents);
            for (const event of unassociatedEvents) {
                if (!(event instanceof tr.model.ThreadSlice)) continue;
                if (!event.isTopLevel) continue;
                for (let index = 0; index < vacuumUEs.length; ++index) {
                    const expectation = vacuumUEs[index];
                    if ((event.start >= expectation.start) && (event.start < expectation.end)) {
                        expectation.associatedEvents.addEventSet(event.entireHierarchy);
                        break;
                    }
                }
            }
        }

        findIdleExpectations(otherUEs) {
            if (this.model.bounds.isEmpty) return;
            const emptyRanges = tr.b.math.findEmptyRangesBetweenRanges(tr.b.math.convertEventsToRanges(otherUEs), this.model.bounds);
            const expectations = [];
            const model = this.model;
            for (const range of emptyRanges) {
                if (range.max < (range.min + INSIGNIFICANT_MS)) continue;
                expectations.push(new tr.model.um.IdleExpectation(model, range.min, range.max - range.min));
            }
            return expectations;
        }
    }

    function createCustomizeModelLinesFromModel(model) {
        const modelLines = [];
        modelLines.push('      audits.addEvent(model.browserMain,');
        modelLines.push('          {title: \'model start\', start: 0, end: 1});');
        const typeNames = {};
        for (const typeName in tr.e.cc.INPUT_EVENT_TYPE_NAMES) {
            typeNames[tr.e.cc.INPUT_EVENT_TYPE_NAMES[typeName]] = typeName;
        }
        let modelEvents = new tr.model.EventSet();
        for (const ue of model.userModel.expectations) {
            modelEvents.addEventSet(ue.sourceEvents);
        }
        modelEvents = modelEvents.toArray();
        modelEvents.sort(tr.importer.compareEvents);
        for (const event of modelEvents) {
            const startAndEnd = 'start: ' + parseInt(event.start) + ', ' + 'end: ' + parseInt(event.end) + '});';
            if (event instanceof tr.e.cc.InputLatencyAsyncSlice) {
                modelLines.push('      audits.addInputEvent(model, INPUT_TYPE.' +
                    typeNames[event.typeName] + ',');
            } else if (event.title === 'RenderFrameImpl::didCommitProvisionalLoad') {
                modelLines.push('      audits.addCommitLoadEvent(model,');
            } else if (event.title === 'InputHandlerProxy::HandleGestureFling::started') {
                modelLines.push('      audits.addFlingAnimationEvent(model,');
            } else if (event.title === tr.model.helpers.IMPL_RENDERING_STATS) {
                modelLines.push('      audits.addFrameEvent(model,');
            } else if (event.title === tr.importer.CSS_ANIMATION_TITLE) {
                modelLines.push('      audits.addEvent(model.rendererMain, {');
                modelLines.push('        title: \'Animation\', ' + startAndEnd);
                return;
            } else {
                throw new Error('You must extend createCustomizeModelLinesFromModel()' + 'to support this event:\n' + event.title + '\n');
            }
            modelLines.push('          {' + startAndEnd);
        }
        modelLines.push('      audits.addEvent(model.browserMain,');
        modelLines.push('          {' + 'title: \'model end\', ' + 'start: ' + (parseInt(model.bounds.max) - 1) + ', ' + 'end: ' + parseInt(model.bounds.max) + '});');
        return modelLines;
    }

    function createExpectedUELinesFromModel(model) {
        const expectedLines = [];
        const ueCount = model.userModel.expectations.length;
        for (let index = 0; index < ueCount; ++index) {
            const expectation = model.userModel.expectations[index];
            let ueString = '      {';
            ueString += 'title: \'' + expectation.title + '\', ';
            ueString += 'start: ' + parseInt(expectation.start) + ', ';
            ueString += 'end: ' + parseInt(expectation.end) + ', ';
            ueString += 'eventCount: ' + expectation.sourceEvents.length;
            ueString += '}';
            if (index < (ueCount - 1)) ueString += ',';
            expectedLines.push(ueString);
        }
        return expectedLines;
    }

    function createUEFinderTestCaseStringFromModel(model) {
        const filename = window.location.hash.substr(1);
        let testName = filename.substr(filename.lastIndexOf('/') + 1);
        testName = testName.substr(0, testName.indexOf('.'));
        try {
            const testLines = [];
            testLines.push('  /*');
            testLines.push('    This test was generated from');
            testLines.push('    ' + filename + '');
            testLines.push('   */');
            testLines.push('  test(\'' + testName + '\', function() {');
            testLines.push('    const verifier = new UserExpectationVerifier();');
            testLines.push('    verifier.customizeModelCallback = function(model) {');
            testLines.push.apply(testLines, createCustomizeModelLinesFromModel(model));
            testLines.push('    };');
            testLines.push('    verifier.expectedUEs = [');
            testLines.push.apply(testLines, createExpectedUELinesFromModel(model));
            testLines.push('    ];');
            testLines.push('    verifier.verify();');
            testLines.push('  });');
            return testLines.join('\n');
        } catch (error) {
            return error;
        }
    }

    return {UserModelBuilder, createUEFinderTestCaseStringFromModel,};
});
'use strict';
tr.exportTo('tr.ui.b', function () {
    function decorate(source, constr) {
        let elements;
        if (typeof source === 'string') {
            elements = Polymer.dom(tr.doc).querySelectorAll(source);
        } else {
            elements = [source];
        }
        for (let i = 0, el; el = elements[i]; i++) {
            if (!(el instanceof constr)) {
                constr.decorate(el);
            }
        }
    }

    function define(className, opt_parentConstructor, opt_tagNS) {
        if (typeof className === 'function') {
            throw new Error('Passing functions as className is deprecated. Please ' + 'use (className, opt_parentConstructor) to subclass');
        }
        className = className.toLowerCase();
        if (opt_parentConstructor && !opt_parentConstructor.tagName) {
            throw new Error('opt_parentConstructor was not ' + 'created by tr.ui.b.define');
        }
        let tagName = className;
        let tagNS = undefined;
        if (opt_parentConstructor) {
            if (opt_tagNS) {
                throw new Error('Must not specify tagNS if parentConstructor is given');
            }
            let parent = opt_parentConstructor;
            while (parent && parent.tagName) {
                tagName = parent.tagName;
                tagNS = parent.tagNS;
                parent = parent.parentConstructor;
            }
        } else {
            tagNS = opt_tagNS;
        }

        function f() {
            if (opt_parentConstructor && f.prototype.__proto__ !== opt_parentConstructor.prototype) {
                throw new Error(className + ' prototye\'s __proto__ field is messed up. ' + 'It MUST be the prototype of ' + opt_parentConstructor.tagName);
            }
            let el;
            if (tagNS === undefined) {
                el = tr.doc.createElement(tagName);
            } else {
                el = tr.doc.createElementNS(tagNS, tagName);
            }
            f.decorate.call(this, el, arguments);
            return el;
        }

        f.decorate = function (el) {
            el.__proto__ = f.prototype;
            el.decorate.apply(el, arguments[1]);
            el.constructor = f;
        };
        f.className = className;
        f.tagName = tagName;
        f.tagNS = tagNS;
        f.parentConstructor = (opt_parentConstructor ? opt_parentConstructor : undefined);
        f.toString = function () {
            if (!f.parentConstructor) {
                return f.tagName;
            }
            return f.parentConstructor.toString() + '::' + f.className;
        };
        return f;
    }

    function elementIsChildOf(el, potentialParent) {
        if (el === potentialParent) return false;
        let cur = el;
        while (Polymer.dom(cur).parentNode) {
            if (cur === potentialParent) return true;
            cur = Polymer.dom(cur).parentNode;
        }
        return false;
    }

    return {decorate, define, elementIsChildOf,};
});
'use strict';
tr.exportTo('tr.b.math', function () {
    function Rect() {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    }

    Rect.fromXYWH = function (x, y, w, h) {
        const rect = new Rect();
        rect.x = x;
        rect.y = y;
        rect.width = w;
        rect.height = h;
        return rect;
    };
    Rect.fromArray = function (ary) {
        if (ary.length !== 4) {
            throw new Error('ary.length must be 4');
        }
        const rect = new Rect();
        rect.x = ary[0];
        rect.y = ary[1];
        rect.width = ary[2];
        rect.height = ary[3];
        return rect;
    };
    Rect.prototype = {
        __proto__: Object.prototype, get left() {
            return this.x;
        }, get top() {
            return this.y;
        }, get right() {
            return this.x + this.width;
        }, get bottom() {
            return this.y + this.height;
        }, toString() {
            return 'Rect(' + this.x + ', ' + this.y + ', ' +
                this.width + ', ' + this.height + ')';
        }, toArray() {
            return [this.x, this.y, this.width, this.height];
        }, clone() {
            const rect = new Rect();
            rect.x = this.x;
            rect.y = this.y;
            rect.width = this.width;
            rect.height = this.height;
            return rect;
        }, enlarge(pad) {
            const rect = new Rect();
            this.enlargeFast(rect, pad);
            return rect;
        }, enlargeFast(out, pad) {
            out.x = this.x - pad;
            out.y = this.y - pad;
            out.width = this.width + 2 * pad;
            out.height = this.height + 2 * pad;
            return out;
        }, size() {
            return {width: this.width, height: this.height};
        }, scale(s) {
            const rect = new Rect();
            this.scaleFast(rect, s);
            return rect;
        }, scaleSize(s) {
            return Rect.fromXYWH(this.x, this.y, this.width * s, this.height * s);
        }, scaleFast(out, s) {
            out.x = this.x * s;
            out.y = this.y * s;
            out.width = this.width * s;
            out.height = this.height * s;
            return out;
        }, translate(v) {
            const rect = new Rect();
            this.translateFast(rect, v);
            return rect;
        }, translateFast(out, v) {
            out.x = this.x + v[0];
            out.y = this.x + v[1];
            out.width = this.width;
            out.height = this.height;
            return out;
        }, asUVRectInside(containingRect) {
            const rect = new Rect();
            rect.x = (this.x - containingRect.x) / containingRect.width;
            rect.y = (this.y - containingRect.y) / containingRect.height;
            rect.width = this.width / containingRect.width;
            rect.height = this.height / containingRect.height;
            return rect;
        }, intersects(that) {
            let ok = true;
            ok &= this.x < that.right;
            ok &= this.right > that.x;
            ok &= this.y < that.bottom;
            ok &= this.bottom > that.y;
            return ok;
        }, equalTo(rect) {
            return rect && (this.x === rect.x) && (this.y === rect.y) && (this.width === rect.width) && (this.height === rect.height);
        }
    };
    return {Rect,};
});
'use strict';
tr.exportTo('tr.ui.b', function () {
    function instantiateTemplate(selector, doc) {
        doc = doc || document;
        const el = Polymer.dom(doc).querySelector(selector);
        if (!el) {
            throw new Error('Element not found: ' + selector);
        }
        return doc.importNode(el.content, true);
    }

    function windowRectForElement(element) {
        const position = [element.offsetLeft, element.offsetTop];
        const size = [element.offsetWidth, element.offsetHeight];
        let node = element.offsetParent;
        while (node) {
            position[0] += node.offsetLeft;
            position[1] += node.offsetTop;
            node = node.offsetParent;
        }
        return tr.b.math.Rect.fromXYWH(position[0], position[1], size[0], size[1]);
    }

    function scrollIntoViewIfNeeded(el) {
        const pr = el.parentElement.getBoundingClientRect();
        const cr = el.getBoundingClientRect();
        if (cr.top < pr.top) {
            el.scrollIntoView(true);
        } else if (cr.bottom > pr.bottom) {
            el.scrollIntoView(false);
        }
    }

    function extractUrlString(url) {
        let extracted = url.replace(/url\((.*)\)/, '$1');
        extracted = extracted.replace(/\"(.*)\"/, '$1');
        return extracted;
    }

    function toThreeDigitLocaleString(value) {
        return value.toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3});
    }

    function isUnknownElementName(name) {
        return document.createElement(name) instanceof HTMLUnknownElement;
    }

    return {
        isUnknownElementName,
        toThreeDigitLocaleString,
        instantiateTemplate,
        windowRectForElement,
        scrollIntoViewIfNeeded,
        extractUrlString,
    };
});
'use strict';
tr.exportTo('tr.ui.b', function () {
    if (tr.isHeadless) return {};
    const THIS_DOC = document.currentScript.ownerDocument;
    const Overlay = tr.ui.b.define('overlay');
    Overlay.prototype = {
        __proto__: HTMLDivElement.prototype, decorate() {
            Polymer.dom(this).classList.add('overlay');
            this.parentEl_ = this.ownerDocument.body;
            this.visible_ = false;
            this.userCanClose_ = true;
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onClick_ = this.onClick_.bind(this);
            this.onFocusIn_ = this.onFocusIn_.bind(this);
            this.onDocumentClick_ = this.onDocumentClick_.bind(this);
            this.onClose_ = this.onClose_.bind(this);
            this.addEventListener('visible-change', tr.ui.b.Overlay.prototype.onVisibleChange_.bind(this), true);
            const createShadowRoot = this.createShadowRoot || this.webkitCreateShadowRoot;
            this.shadow_ = createShadowRoot.call(this);
            Polymer.dom(this.shadow_).appendChild(tr.ui.b.instantiateTemplate('#overlay-template', THIS_DOC));
            this.closeBtn_ = Polymer.dom(this.shadow_).querySelector('close-button');
            this.closeBtn_.addEventListener('click', this.onClose_);
            Polymer.dom(this.shadow_).querySelector('overlay-frame').addEventListener('click', this.onClick_);
            this.observer_ = new WebKitMutationObserver(this.didButtonBarMutate_.bind(this));
            this.observer_.observe(Polymer.dom(this.shadow_).querySelector('button-bar'), {childList: true});
            Object.defineProperty(this, 'title', {
                get() {
                    return Polymer.dom(Polymer.dom(this.shadow_).querySelector('title')).textContent;
                }, set(title) {
                    Polymer.dom(Polymer.dom(this.shadow_).querySelector('title')).textContent = title;
                }
            });
        }, set userCanClose(userCanClose) {
            this.userCanClose_ = userCanClose;
            this.closeBtn_.style.display = userCanClose ? 'block' : 'none';
        }, get buttons() {
            return Polymer.dom(this.shadow_).querySelector('button-bar');
        }, get visible() {
            return this.visible_;
        }, set visible(newValue) {
            if (this.visible_ === newValue) return;
            this.visible_ = newValue;
            const e = new tr.b.Event('visible-change');
            this.dispatchEvent(e);
        }, onVisibleChange_() {
            this.visible_ ? this.show_() : this.hide_();
        }, show_() {
            Polymer.dom(this.parentEl_).appendChild(this);
            if (this.userCanClose_) {
                this.addEventListener('keydown', this.onKeyDown_.bind(this));
                this.addEventListener('click', this.onDocumentClick_.bind(this));
                this.closeBtn_.addEventListener('click', this.onClose_);
            }
            this.parentEl_.addEventListener('focusin', this.onFocusIn_);
            this.tabIndex = 0;
            const elList = Polymer.dom(this).querySelectorAll('button, input, list, select, a');
            if (elList.length > 0) {
                if (elList[0] === this.closeBtn_) {
                    if (elList.length > 1) return elList[1].focus();
                } else {
                    return elList[0].focus();
                }
            }
            this.focus();
        }, hide_() {
            Polymer.dom(this.parentEl_).removeChild(this);
            this.parentEl_.removeEventListener('focusin', this.onFocusIn_);
            if (this.closeBtn_) {
                this.closeBtn_.removeEventListener('click', this.onClose_);
            }
            document.removeEventListener('keydown', this.onKeyDown_);
            document.removeEventListener('click', this.onDocumentClick_);
        }, onClose_(e) {
            this.visible = false;
            if ((e.type !== 'keydown') || (e.type === 'keydown' && e.keyCode === 27)) {
                e.stopPropagation();
            }
            e.preventDefault();
            tr.b.dispatchSimpleEvent(this, 'closeclick');
        }, onFocusIn_(e) {
            let node = e.target;
            while (node) {
                if (node === this) {
                    return;
                }
                node = node.parentNode;
            }
            tr.b.timeout(0).then(() => this.focus());
            e.preventDefault();
            e.stopPropagation();
        }, didButtonBarMutate_(e) {
            const hasButtons = this.buttons.children.length > 0;
            if (hasButtons) {
                Polymer.dom(this.shadow_).querySelector('button-bar').style.display = undefined;
            } else {
                Polymer.dom(this.shadow_).querySelector('button-bar').style.display = 'none';
            }
        }, onKeyDown_(e) {
            if (e.keyCode === 9 && e.shiftKey && e.target === this) {
                e.preventDefault();
                return;
            }
            if (e.keyCode !== 27) return;
            this.onClose_(e);
        }, onClick_(e) {
            e.stopPropagation();
        }, onDocumentClick_(e) {
            if (!this.userCanClose_) return;
            this.onClose_(e);
        }
    };
    Overlay.showError = function (msg, opt_err) {
        const o = new Overlay();
        o.title = 'Error';
        Polymer.dom(o).textContent = msg;
        if (opt_err) {
            const e = tr.b.normalizeException(opt_err);
            const stackDiv = document.createElement('pre');
            Polymer.dom(stackDiv).textContent = e.stack;
            stackDiv.style.paddingLeft = '8px';
            stackDiv.style.margin = 0;
            Polymer.dom(o).appendChild(stackDiv);
        }
        const b = document.createElement('button');
        Polymer.dom(b).textContent = 'OK';
        b.addEventListener('click', function () {
            o.visible = false;
        });
        Polymer.dom(o.buttons).appendChild(b);
        o.visible = true;
        return o;
    };
    return {Overlay,};
});
'use strict';
tr.exportTo('tr.importer', function () {
    const Timing = tr.b.Timing;

    function ImportOptions() {
        this.shiftWorldToZero = true;
        this.pruneEmptyContainers = true;
        this.showImportWarnings = true;
        this.trackDetailedModelStats = false;
        this.customizeModelCallback = undefined;
        const auditorTypes = tr.c.Auditor.getAllRegisteredTypeInfos();
        this.auditorConstructors = auditorTypes.map(function (typeInfo) {
            return typeInfo.constructor;
        });
    }

    function Import(model, opt_options) {
        if (model === undefined) {
            throw new Error('Must provide model to import into.');
        }
        this.importing_ = false;
        this.importOptions_ = opt_options || new ImportOptions();
        this.model_ = model;
        this.model_.importOptions = this.importOptions_;
    }

    Import.prototype = {
        __proto__: Object.prototype, importTraces(traces) {
            const progressMeter = {
                update(msg) {
                }
            };
            tr.b.Task.RunSynchronously(this.createImportTracesTask(progressMeter, traces));
        }, importTracesWithProgressDialog(traces) {
            if (tr.isHeadless) {
                throw new Error('Cannot use this method in headless mode.');
            }
            const overlay = tr.ui.b.Overlay();
            overlay.title = 'Importing...';
            overlay.userCanClose = false;
            overlay.msgEl = document.createElement('div');
            Polymer.dom(overlay).appendChild(overlay.msgEl);
            overlay.msgEl.style.margin = '20px';
            overlay.update = function (msg) {
                Polymer.dom(this.msgEl).textContent = msg;
            };
            overlay.visible = true;
            const promise = tr.b.Task.RunWhenIdle(this.createImportTracesTask(overlay, traces));
            promise.then(function () {
                overlay.visible = false;
            }, function (err) {
                overlay.visible = false;
            });
            return promise;
        }, createImportTracesTask(progressMeter, traces) {
            const importStartTimeMs = tr.b.Timing.getCurrentTimeMs();
            if (this.importing_) {
                throw new Error('Already importing.');
            }
            this.importing_ = true;
            const importTask = new tr.b.Task(function prepareImport() {
                progressMeter.update('I will now import your traces for you...');
            }, this);
            let lastTask = importTask;
            const importers = [];

            function addImportStage(title, callback) {
                lastTask = lastTask.after(() => progressMeter.update(title));
                lastTask.updatesUi = true;
                lastTask = lastTask.after(callback);
            }

            function addStageForEachImporter(title, callback) {
                lastTask = lastTask.after((task) => {
                    importers.forEach((importer, index) => {
                        const uiSubTask = task.subTask(() => {
                            progressMeter.update(`${title} ${index + 1} of ${importers.length}`);
                        });
                        uiSubTask.updatesUi = true;
                        task.subTask(() => callback(importer));
                    });
                });
            }

            addImportStage('Creating importers...', () => {
                traces = traces.slice(0);
                progressMeter.update('Creating importers...');
                for (let i = 0; i < traces.length; ++i) {
                    importers.push(this.createImporter_(traces[i]));
                }
                for (let i = 0; i < importers.length; i++) {
                    const subtraces = importers[i].extractSubtraces();
                    for (let j = 0; j < subtraces.length; j++) {
                        try {
                            traces.push(subtraces[j]);
                            importers.push(this.createImporter_(subtraces[j]));
                        } catch (error) {
                            this.model_.importWarning({
                                type: error.name,
                                message: error.message,
                                showToUser: true,
                            });
                            continue;
                        }
                    }
                }
                if (traces.length && !this.hasEventDataDecoder_(importers)) {
                    throw new Error('Could not find an importer for the provided eventData.');
                }
                importers.sort(function (x, y) {
                    return x.importPriority - y.importPriority;
                });
            });
            addStageForEachImporter('Importing clock sync markers', importer => importer.importClockSyncMarkers());
            addStageForEachImporter('Importing', importer => importer.importEvents());
            if (this.importOptions_.customizeModelCallback) {
                addImportStage('Customizing', () => {
                    this.importOptions_.customizeModelCallback(this.model_);
                });
            }
            addStageForEachImporter('Importing sample data', importer => importer.importSampleData());
            addImportStage('Autoclosing open slices...', () => {
                this.model_.autoCloseOpenSlices();
                this.model_.createSubSlices();
            });
            addStageForEachImporter('Finalizing import', importer => importer.finalizeImport());
            addImportStage('Initializing objects (step 1/2)...', () => this.model_.preInitializeObjects());
            if (this.importOptions_.pruneEmptyContainers) {
                addImportStage('Pruning empty containers...', () => this.model_.pruneEmptyContainers());
            }
            addImportStage('Merging kernel with userland...', () => this.model_.mergeKernelWithUserland());
            let auditors = [];
            addImportStage('Adding arbitrary data to model...', () => {
                auditors = this.importOptions_.auditorConstructors.map(auditorConstructor => new auditorConstructor(this.model_));
                auditors.forEach((auditor) => {
                    auditor.runAnnotate();
                    auditor.installUserFriendlyCategoryDriverIfNeeded();
                });
            });
            addImportStage('Computing final world bounds...', () => {
                this.model_.computeWorldBounds(this.importOptions_.shiftWorldToZero);
            });
            addImportStage('Building flow event map...', () => this.model_.buildFlowEventIntervalTree());
            addImportStage('Joining object refs...', () => this.model_.joinRefs());
            addImportStage('Cleaning up undeleted objects...', () => this.model_.cleanupUndeletedObjects());
            addImportStage('Sorting memory dumps...', () => this.model_.sortMemoryDumps());
            addImportStage('Finalizing memory dump graphs...', () => this.model_.finalizeMemoryGraphs());
            addImportStage('Initializing objects (step 2/2)...', () => this.model_.initializeObjects());
            addImportStage('Building event indices...', () => this.model_.buildEventIndices());
            addImportStage('Building UserModel...', () => {
                const userModelBuilder = new tr.importer.UserModelBuilder(this.model_);
                userModelBuilder.buildUserModel();
            });
            addImportStage('Sorting user expectations...', () => this.model_.userModel.sortExpectations());
            addImportStage('Running auditors...', () => {
                auditors.forEach(auditor => auditor.runAudit());
            });
            addImportStage('Updating alerts...', () => this.model_.sortAlerts());
            addImportStage('Update bounds...', () => this.model_.updateBounds());
            addImportStage('Looking for warnings...', () => {
                if (!this.model_.isTimeHighResolution) {
                    this.model_.importWarning({
                        type: 'low_resolution_timer',
                        message: 'Trace time is low resolution, trace may be unusable.',
                        showToUser: true
                    });
                }
            });
            lastTask.after(() => {
                this.importing_ = false;
                this.model_.stats.traceImportDurationMs = tr.b.Timing.getCurrentTimeMs() - importStartTimeMs;
            });
            return importTask;
        }, createImporter_(eventData) {
            const importerConstructor = tr.importer.Importer.findImporterFor(eventData);
            if (!importerConstructor) {
                throw new Error('Couldn\'t create an importer for the provided ' + 'eventData.');
            }
            return new importerConstructor(this.model_, eventData);
        }, hasEventDataDecoder_(importers) {
            for (let i = 0; i < importers.length; ++i) {
                if (!importers[i].isTraceDataContainer()) return true;
            }
            return false;
        }
    };
    return {ImportOptions, Import,};
});